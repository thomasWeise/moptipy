<!doctype html><html data-content_root=./ lang=en><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0"name=viewport><meta content="width=device-width,initial-scale=1"name=viewport><title>moptipy: Metaheuristic Optimization in Python — moptipy 0.9.172 documentation</title><link href="/moptipy/_static/pygments.css?v=b86133f3"rel=stylesheet><link href="/moptipy/_static/bizstyle.css?v=5283bb3d"rel=stylesheet><script src="/moptipy/_static/documentation_options.js?v=ad8658f5"></script><script src="/moptipy/_static/doctools.js?v=9bcbadda"></script><script src="/moptipy/_static/sphinx_highlight.js?v=dc90522c"></script><script src=_static/bizstyle.js></script><link href=https://thomasweise.github.io/moptipy/index.html rel=canonical><link href=genindex.html rel=index title=Index><link href=search.html rel=search title=Search><link href=modules.html rel=next title=moptipy><meta content="width=device-width,initial-scale=1.0"name=viewport><body><div aria-label=Related class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="General Index"accesskey=I href=genindex.html>index</a><li class=right><a title="Python Module Index"href=py-modindex.html>modules</a> |<li class=right><a accesskey=N href=modules.html title=moptipy>next</a> |<li class="nav-item nav-item-0"><a href=#>moptipy 0.9.172 documentation</a> »<li class="nav-item nav-item-this"><a href>moptipy: Metaheuristic Optimization in Python</a></ul></div><div class=document><div class=documentwrapper><div class=bodywrapper><div class=body role=main><section id=moptipy-metaheuristic-optimization-in-python><h1>moptipy: Metaheuristic Optimization in Python<a title="Link to this heading"class=headerlink href=#moptipy-metaheuristic-optimization-in-python>¶</a></h1><ul class=simple><li><p><a class="reference internal"href=genindex.html><span class="std std-ref">Index</span></a><li><p><a class="reference internal"href=py-modindex.html><span class="std std-ref">Module Index</span></a><li><p><a class="reference internal"href=search.html><span class="std std-ref">Search Page</span></a></ul><p><a class="reference external"href=https://github.com/thomasWeise/moptipy/actions/workflows/build.yml><img alt="make build"src=https://github.com/thomasWeise/moptipy/actions/workflows/build.yml/badge.svg></a> <a class="reference external"href=https://pypi.org/project/moptipy><img alt="pypi version"src=https://img.shields.io/pypi/v/moptipy></a> <a class="reference external"href=https://pypistats.org/packages/moptipy><img alt="pypi downloads"src=https://img.shields.io/pypi/dw/moptipy.svg></a> <a class="reference external"href=https://thomasweise.github.io/moptipy/tc/index.html><img alt="coverage report"src=https://shields.io/badge/pytest-coverage-009000></a> <a class="reference external"href=https://thomasweise.github.io><img alt=https://thomasweise.github.io src=https://shields.io/badge/home-thomasweise.github.io-009000></a><section id=introduction><h2>1. Introduction<a title="Link to this heading"class=headerlink href=#introduction>¶</a></h2><p><a class="reference external"href=./_static/moptipy_flyer.pdf><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> is a library with implementations of metaheuristic optimization methods in Python 3.12 that also offers an environment for replicable experiments. Metaheuristic optimization algorithms are methods for solving hard problems. <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> provides an <a class="reference external"href=./moptipy.api.html>API</a>, several <a class="reference external"href=./moptipy.algorithms.html#module-moptipy.algorithms>algorithm implementations</a>, as well as <a class="reference external"href=./moptipy.api.html#module-moptipy.api.experiment>experiment execution</a> and <a class="reference external"href=./moptipy.evaluation.html#module-moptipy.evaluation>evaluation</a> facilities for metaheuristics. <a class="reference external"href=http://thomasweise.github.io/talks/moptipy.pdf>Here</a> you can find a small presentation outlining some of the concepts of the system. <a class="reference external"href=./_static/moptipy_flyer.pdf><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> is structured with performance, ease-of-use, and generality in mind, but also based on an educational and research perspective. It is therefore (hopefully) suitable for practical industrial applications, scientific research, and for students who are just entering the field of metaheuristic optimization.<p>A metaheuristic algorithm can be a black-box method, which can solve problems without deeper knowledge about their nature. Such a black-box algorithm only requires methods to <a class="reference external"href=./moptipy.api.html#moptipy.api.operators.Op0>create</a> and <a class="reference external"href=./moptipy.api.html#moptipy.api.operators.Op1>modify</a> points in the <a class="reference external"href=./moptipy.api.html#module-moptipy.api.space>search space</a> and to <a class="reference external"href=./moptipy.api.html#module-moptipy.api.objective>evaluate their quality</a>. With these operations, it will try to discover better solutions step-by-step. Black-box metaheuristics are very general and can be adapted to almost any optimization problem. They allow us to plug in almost arbitrary <a class="reference external"href=./moptipy.api.html#module-moptipy.api.operators>search operators</a>, <a class="reference external"href=./moptipy.api.html#module-moptipy.api.space>search spaces</a>, and <a class="reference external"href=./moptipy.api.html#module-moptipy.api.objective>objective functions</a>. But it is also possible to develop algorithms that are tailored to specified problems. For example, one could either design the search operators and the optimization algorithm as a unit. Then, the algorithm could change its way to sample new points based on the information it gathers. Or one could design an algorithm for a specific search space, say, the <a class="reference external"href=./moptipy.algorithms.so.vector.html><code class="docutils literal notranslate"><span class=pre>n</span></code>-dimensional real numbers</a>, which could then make use of the special features of this space, such as arithmetic and geometric relationships of the points within it. Or one could design an algorithm for a specific problem, making use of specific features of the objective function. Finally, there are <a class="reference external"href=./moptipy.api.html#module-moptipy.api.mo_problem>multi-objective optimization problems</a> where multiple, potentially conflicting, criteria need to be optimized at once.<p>Within our <a class="reference external"href=./_static/moptipy_flyer.pdf><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> framework, you can implement algorithms of all of these types under a unified <a class="reference external"href=./moptipy.api.html>API</a>. Our package already provides a growing set of <a class="reference external"href=#implemented-algorithms>algorithms</a> and adaptations to different <a class="reference external"href=#implemented-search-spaces-and-operators>search spaces</a> as well as a set of well-known <a class="reference external"href=#implemented-problems>optimization problems</a>. What <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> <em>also</em> offers is an <a class="reference external"href=./moptipy.api.html#module-moptipy.api.experiment>experiment execution facility</a> that can collect detailed <a class="reference external"href=#data-formats>log information</a> and <a class="reference external"href=#evaluating-experiments>evaluate</a> the gathered results in a <a class="reference external"href=#reproducibility><em>reproducible</em> fashion</a>. The <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> API supports both single-objective and multi-objective optimization. A set of “<a class="reference external"href=#how-tos>How-Tos</a>” is given in <a class="reference external"href=#how-tos>Section 3</a> and a longer <a class="reference external"href=#examples>list of examples</a> is given in <a class="reference external"href=#examples>Section 7</a>. You can also take a look at our <a class="reference external"href=./_static/moptipy_flyer.pdf><code class="docutils literal notranslate"><span class=pre>moptipy</span></code> flyer</a>. Examples and practical applications of <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> can be found in the <a class="reference external"href=./apps><code class="docutils literal notranslate"><span class=pre>moptipyapps</span></code></a> package, which is available on <a class="reference external"href=https://github.com/thomasWeise/moptipyapps>GitHub</a> and in <a class="reference external"href=https://pypi.org/project/moptipyapps><code class="docutils literal notranslate"><span class=pre>PyPi</span></code></a>.</section><section id=installation><h2>2. Installation<a title="Link to this heading"class=headerlink href=#installation>¶</a></h2><p>In order to use this package and to, e.g., run the example codes, you need to first install it using <a class="reference external"href=https://pypi.org/project/pip><code class="docutils literal notranslate"><span class=pre>pip</span></code></a> or some other tool that can install packages from <a class="reference external"href=https://pypi.org>PyPi</a>. You can install the newest version of this library from <a class="reference external"href=https://pypi.org/project/moptipy>PyPi</a> using <a class="reference external"href=https://pypi.org/project/pip><code class="docutils literal notranslate"><span class=pre>pip</span></code></a> by doing<div class="highlight-shell notranslate"><div class=highlight><pre><span></span>pip<span class=w> </span>install<span class=w> </span>moptipy
</pre></div></div><p>This will install the latest official release of our package as well as <a class="reference external"href=./requirements_txt.html>all dependencies</a>. If you want to install the latest source code version from GitHub (which may not yet be officially released), you can do<div class="highlight-shell notranslate"><div class=highlight><pre><span></span>pip<span class=w> </span>install<span class=w> </span>git+https://github.com/thomasWeise/moptipy.git
</pre></div></div><p>If you want to install the latest source code version from GitHub (which may not yet be officially released) and you have set up a private/public key for GitHub, you can also do:<div class="highlight-shell notranslate"><div class=highlight><pre><span></span>git<span class=w> </span>clone<span class=w> </span>ssh://git@github.com/thomasWeise/moptipy
pip<span class=w> </span>install<span class=w> </span>moptipy
</pre></div></div><p>This may sometimes work better if you are having trouble reaching GitHub via <code class="docutils literal notranslate"><span class=pre>https</span></code> or <code class="docutils literal notranslate"><span class=pre>http</span></code>. All dependencies for using and running <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> are listed at <a class="reference external"href=./requirements_txt.html>here</a>. The additional dependencies for a <a class="reference external"href=./Makefile.html>full <code class="docutils literal notranslate"><span class=pre>make</span></code> build</a>, including unit tests, static analysis, and the generation of documentation are listed <a class="reference external"href=./requirements-dev_txt.html>here</a>.</section><section id=how-tos><h2>3. How-Tos<a title="Link to this heading"class=headerlink href=#how-tos>¶</a></h2><p>You can find many examples of how to use the <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> library in the folder “<a class="reference external"href=https://github.com/thomasWeise/moptipy/tree/main/examples><code class="docutils literal notranslate"><span class=pre>examples</span></code></a>”. Here, we talk mainly about directly applying one or multiple <a class="reference external"href=#implemented-algorithms>optimization algorithm(s)</a> to one or multiple <a class="reference external"href=#implemented-problems>optimization problem</a> instance(s). In <a class="reference external"href=#data-formats>Section 5 on Data Formats</a>, we give examples and specifications of the log files that our system produces and how you can export the data to other formats. Later, in <a class="reference external"href=#evaluating-experiments>Section 6 on Evaluating Experiments</a>, we provide several examples on how to evaluate and visualize the results of experiments. In <a class="reference external"href=#examples>Section 7 on examples</a>, we list all the examples that ship with moptipy.<section id=how-to-apply-1-optimization-algorithm-once-to-1-problem-instance><h3>3.1. How to Apply 1 Optimization Algorithm Once to 1 Problem Instance<a title="Link to this heading"class=headerlink href=#how-to-apply-1-optimization-algorithm-once-to-1-problem-instance>¶</a></h3><p>The most basic task that we can do in the domain of optimization is to apply one <a class="reference external"href=#implemented-algorithms>algorithm</a> to one instance of an <a class="reference external"href=#implemented-problems>optimization problem</a>. In our framework, we refer to this as an “execution.” You can prepare an execution using the class <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution><code class="docutils literal notranslate"><span class=pre>Execution</span></code></a> in the module <a class="reference external"href=./moptipy.api.html#module-moptipy.api.execution>moptipy.api.execution</a>. This class follows the <a class="reference external"href=https://python-patterns.guide/gang-of-four/builder>builder design pattern</a>. A builder is basically an object that allows you to step-by-step set the parameters of another, more complicated object that should be created. Once you have set all parameters, you can create the object. In our case, the class <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution><code class="docutils literal notranslate"><span class=pre>Execution</span></code></a> allows you to compose all the elements necessary for the algorithm run and then it performs it and provides you the end results of that execution.<p>So first, you create an instance <code class="docutils literal notranslate"><span class=pre>ex</span></code> of <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution><code class="docutils literal notranslate"><span class=pre>Execution</span></code></a>. Then you set the <a class="reference external"href=./moptipy.api.html#moptipy.api.algorithm.Algorithm>algorithm</a> that should be applied via the method <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_algorithm><code class="docutils literal notranslate"><span class=pre>ex.set_algorithm(...)</span></code></a>. Then you set the <a class="reference external"href=./moptipy.api.html#moptipy.api.objective.Objective>objective function</a> via the method <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_objective><code class="docutils literal notranslate"><span class=pre>ex.set_objective(...)</span></code></a>.<p>Then, via <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_solution_space><code class="docutils literal notranslate"><span class=pre>ex.set_solution_space(...)</span></code></a> you set the solution <a class="reference external"href=./moptipy.api.html#moptipy.api.space.Space>space</a> that contains all possible solutions and is explored by the algorithm. The solution space is an instance of the class <a class="reference external"href=./moptipy.api.html#moptipy.api.space.Space><code class="docutils literal notranslate"><span class=pre>Space</span></code></a>. It provides all methods necessary to create a solution data structure, to copy the contents of one solution data structure to another one, to convert solution data structures to and from strings, and to verify whether a solution data structure is valid. It is used by the optimization algorithm for instantiating the solution data structures and for copying them. It is used internally by the <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> system to automatically maintain copies of the current best solution, to check if the solutions are indeed valid once the algorithm finishes, and to convert the solution to a string to store it in the <a class="reference external"href=#log-files>log files</a>.<p>If the search and solution spaces are different, then you can also set a search <a class="reference external"href=./moptipy.api.html#moptipy.api.space.Space>space</a> via <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_search_space><code class="docutils literal notranslate"><span class=pre>ex.set_search_space(...)</span></code></a> and an <a class="reference external"href=./moptipy.api.html#module-moptipy.api.encoding>encoding</a> via <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_encoding><code class="docutils literal notranslate"><span class=pre>ex.set_encoding(...)</span></code></a>. This is not necessary if the algorithm works directly on the solutions (as in our example below).<p>Each application of an <a class="reference external"href=./moptipy.api.html#module-moptipy.api.algorithm>optimization algorithm</a> to a problem instance will also be provided with a <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.get_random>random number generator</a> and it <em>must</em> only use this random number generator for randomization and no other sources of randomness. You can set the seed for this random number generator via <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_rand_seed><code class="docutils literal notranslate"><span class=pre>ex.set_rand_seed(...)</span></code></a>. If you create two identical executions and set the same seeds for both of them, the algorithms will make the same random decisions and hence should return the same results.<p>Furthermore, you can also set the maximum number of candidate solutions that the optimization algorithm is allowed to investigate via <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_max_fes><code class="docutils literal notranslate"><span class=pre>ex.set_max_fes(...)</span></code></a>, the maximum runtime budget in milliseconds via <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_max_time_millis><code class="docutils literal notranslate"><span class=pre>ex.set_max_time_millis(...)</span></code></a>, and a goal objective value via <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_goal_f><code class="docutils literal notranslate"><span class=pre>ex.set_goal_f(...)</span></code></a> (the algorithm should stop after reaching it). Notice that optimization algorithms may not terminate unless the system tells them to, i.e., unless <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.should_terminate><code class="docutils literal notranslate"><span class=pre>process.should_terminate()</span></code></a> returns <code class="docutils literal notranslate"><span class=pre>True</span></code>, which is triggered by the termination conditions you define as stated above. Therefore, you should always specify at least either a maximum number of objective function evaluations or a runtime limit. If you only specify a goal objective value and the algorithm cannot reach it, it may not terminate.<p>Finally, you can also set the path to a log file via <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_log_file><code class="docutils literal notranslate"><span class=pre>ex.set_log_file(...)</span></code></a>. If you specify a log file, the system will automatically gather system information and collect the end result. Via <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_log_improvements><code class="docutils literal notranslate"><span class=pre>ex.set_log_improvements(True)</span></code></a>, you can instruct the system to also collect the progress of the algorithm in terms of improving moves by default. In the rare case that you want to log every single move that the algorithm makes, you could call <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_log_all_fes><code class="docutils literal notranslate"><span class=pre>ex.set_log_all_fes(True)</span></code></a>. All the collected data will be stored in a <a class="reference external"href=#log-files>text file</a> <em>after</em> the algorithm has completed and you have left the process scope (see below).</p><a href=./_static/process_architecture.svg> <img alt="The process architecture of the moptipy framework."src=./_static/process_architecture.svg style=float:left;width:50%;min-width:30%;max-width:60%;padding-top:.5em;padding-bottom:.5em;padding-right:2em> </a><p>Anyway, after you have completed building the execution, you can run the process you have configured via <code class="docutils literal notranslate"><span class=pre>ex.execute()</span></code>. This method returns an instance of <a class="reference external"href=./moptipy.api.html#module-moptipy.api.process><code class="docutils literal notranslate"><span class=pre>Process</span></code></a>. From the algorithm perspective, this instance provides all the information and tools that is needed to create, copy, and evaluate solutions, as well as the termination criterion that tells it when to stop. For us, the algorithm user, it provides the information about the end result, the consumed FEs, and the end result quality. In the code below, we illustrate how to extract these information. Notice that you <em>must</em> always use the instances of <code class="docutils literal notranslate"><span class=pre>Process</span></code> in a <a class="reference external"href=https://peps.python.org/pep-0343><code class="docutils literal notranslate"><span class=pre>with</span></code> block</a>: Once this block is left, the log file will be written. If you do not use a <code class="docutils literal notranslate"><span class=pre>with</span></code> block, no log file will be generated.<p>Let us now look at a concrete example, which is also available as file <a class="reference external"href=./examples/single_run_rls_onemax_py.html>examples/single_run_rls_onemax</a>. As example domain, we use <a class="reference external"href=./moptipy.spaces.html#module-moptipy.spaces.bitstrings>bit strings</a> of length <code class="docutils literal notranslate"><span class=pre>n</span> <span class=pre>=</span> <span class=pre>10</span></code> and try to solve the well-known <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.onemax><code class="docutils literal notranslate"><span class=pre>OneMax</span></code></a> problem using the well-known <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.rls><code class="docutils literal notranslate"><span class=pre>RLS</span></code></a>.<div class="highlight-python notranslate"><div class=highlight><pre><span></span><span class=kn>from</span><span class=w> </span><span class=nn>moptipy.algorithms.so.rls</span><span class=w> </span><span class=kn>import</span> <span class=n>RLS</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.api.execution</span><span class=w> </span><span class=kn>import</span> <span class=n>Execution</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.bitstrings.onemax</span><span class=w> </span><span class=kn>import</span> <span class=n>OneMax</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.bitstrings.op0_random</span><span class=w> </span><span class=kn>import</span> <span class=n>Op0Random</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.bitstrings.op1_flip1</span><span class=w> </span><span class=kn>import</span> <span class=n>Op1Flip1</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.spaces.bitstrings</span><span class=w> </span><span class=kn>import</span> <span class=n>BitStrings</span>
<span class=kn>from</span><span class=w> </span><span class=nn>pycommons.io.temp</span><span class=w> </span><span class=kn>import</span> <span class=n>temp_file</span>

<span class=n>space</span> <span class=o>=</span> <span class=n>BitStrings</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>  <span class=c1># search in bit strings of length 10</span>
<span class=n>problem</span> <span class=o>=</span> <span class=n>OneMax</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>  <span class=c1># we maximize the number of 1 bits</span>
<span class=n>algorithm</span> <span class=o>=</span> <span class=n>RLS</span><span class=p>(</span>  <span class=c1># create RLS that</span>
    <span class=n>Op0Random</span><span class=p>(),</span>  <span class=c1># starts with a random bit string and</span>
    <span class=n>Op1Flip1</span><span class=p>())</span>  <span class=c1># flips exactly one bit in each step</span>

<span class=c1># We work with a temporary log file which is automatically deleted after this</span>
<span class=c1># experiment. For a real experiment, you would not use the `with` block and</span>
<span class=c1># instead put the path to the file that you want to create into `tf` by doing</span>
<span class=c1># `from pycommons.io.path import Path; tf = Path("mydir/my_file.txt")`.</span>
<span class=k>with</span> <span class=n>temp_file</span><span class=p>()</span> <span class=k>as</span> <span class=n>tf</span><span class=p>:</span>  <span class=c1># create temporary file `tf`</span>
    <span class=n>ex</span> <span class=o>=</span> <span class=n>Execution</span><span class=p>()</span>  <span class=c1># begin configuring execution</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_solution_space</span><span class=p>(</span><span class=n>space</span><span class=p>)</span>  <span class=c1># set solution space</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_objective</span><span class=p>(</span><span class=n>problem</span><span class=p>)</span>  <span class=c1># set objective function</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_algorithm</span><span class=p>(</span><span class=n>algorithm</span><span class=p>)</span>  <span class=c1># set algorithm</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_rand_seed</span><span class=p>(</span><span class=mi>199</span><span class=p>)</span>  <span class=c1># set random seed to 199</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_log_file</span><span class=p>(</span><span class=n>tf</span><span class=p>)</span>  <span class=c1># set log file = temp file `tf`</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_max_fes</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span>  <span class=c1># allow at most 100 function evaluations</span>
    <span class=k>with</span> <span class=n>ex</span><span class=o>.</span><span class=n>execute</span><span class=p>()</span> <span class=k>as</span> <span class=n>process</span><span class=p>:</span>  <span class=c1># now run the algorithm*problem combination</span>
        <span class=n>end_result</span> <span class=o>=</span> <span class=n>process</span><span class=o>.</span><span class=n>create</span><span class=p>()</span>  <span class=c1># create empty record to receive result</span>
        <span class=n>process</span><span class=o>.</span><span class=n>get_copy_of_best_y</span><span class=p>(</span><span class=n>end_result</span><span class=p>)</span>  <span class=c1># obtain end result</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>"Best solution found: </span><span class=si>{</span><span class=n>process</span><span class=o>.</span><span class=n>to_str</span><span class=p>(</span><span class=n>end_result</span><span class=p>)</span><span class=si>}</span><span class=s2>"</span><span class=p>)</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>"Quality of best solution: </span><span class=si>{</span><span class=n>process</span><span class=o>.</span><span class=n>get_best_f</span><span class=p>()</span><span class=si>}</span><span class=s2>"</span><span class=p>)</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>"Consumed Runtime: </span><span class=si>{</span><span class=n>process</span><span class=o>.</span><span class=n>get_consumed_time_millis</span><span class=p>()</span><span class=si>}</span><span class=s2>ms"</span><span class=p>)</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>"Total FEs: </span><span class=si>{</span><span class=n>process</span><span class=o>.</span><span class=n>get_consumed_fes</span><span class=p>()</span><span class=si>}</span><span class=s2>"</span><span class=p>)</span>

    <span class=nb>print</span><span class=p>(</span><span class=s2>"</span><span class=se>\n</span><span class=s2>Now reading and printing all the logged data:"</span><span class=p>)</span>
    <span class=nb>print</span><span class=p>(</span><span class=n>tf</span><span class=o>.</span><span class=n>read_all_str</span><span class=p>())</span>  <span class=c1># instead, we load and print the log file</span>
<span class=c1># The temp file is deleted as soon as we leave the `with` block.</span>
</pre></div></div><p>The output we would get from this program could look something like this:<div class="highlight-text notranslate"><div class=highlight><pre><span></span>Best solution found: TTTTTTTTTT
Quality of best solution: 0
Consumed Runtime: 129ms
Total FEs: 17

Now reading and printing all the logged data:
BEGIN_STATE
totalFEs: 17
totalTimeMillis: 129
bestF: 0
lastImprovementFE: 17
lastImprovementTimeMillis: 129
END_STATE
BEGIN_SETUP
p.name: ProcessWithoutSearchSpace
p.class: moptipy.api._process_no_ss._ProcessNoSS
p.maxFEs: 100
p.goalF: 0
p.randSeed: 199
...
END_SETUP
BEGIN_SYS_INFO
...
END_SYS_INFO
BEGIN_RESULT_Y
TTTTTTTTTT
END_RESULT_Y
</pre></div></div><p>You can also compare this output to the <a class="reference external"href=#example-for-single-objective-optimization>example for log files</a> further down this text.</section><section id=how-to-run-a-series-of-experiments><h3>3.2. How to Run a Series of Experiments<a title="Link to this heading"class=headerlink href=#how-to-run-a-series-of-experiments>¶</a></h3><p>When we develop algorithms or do research, then we cannot just apply an algorithm once to a problem instance and call it a day. Instead, we will apply multiple algorithms (or algorithm setups) to multiple problem instances and execute several runs for each algorithm * instance combination. Our system of course also provides the facilities for this.<p>The concept for this is rather simple. We distinguish “instances” and “setups.” An “instance” can be anything that a represents one specific problem instance. It could be a string with its identifying name, it could be the <a class="reference external"href=./moptipy.api.html#moptipy.api.objective.Objective>objective function</a> itself, or a data structure with the instance data (as is the case for the Job Shop Scheduling Problem used in our book, where we use the class <a class="reference external"href=./moptipy.examples.jssp.html#module-moptipy.examples.jssp.instance>Instance</a>). The important thing is that the <code class="docutils literal notranslate"><span class=pre>__str__</span></code> method of the instance object will return a short string that can be used in file names of <a class="reference external"href=#log-files>log files</a>.<p>The second concept to understand here are “setups.” A “setup” is basically an almost fully configured <a class="reference external"href=./moptipy.api.html#module-moptipy.api.execution><code class="docutils literal notranslate"><span class=pre>Execution</span></code></a> (see the <a class="reference external"href=#how-to-apply-1-optimization-algorithm-once-to-1-problem-instance>previous section</a> for a detailed discussion of Executions.) The only things that need to be left blank are the log file path and random seed, which will be filled automatically by our system.<p>You will basically provide a sequence of <a class="reference external"href=https://docs.python.org/3/library/typing.html#typing.Callable><code class="docutils literal notranslate"><span class=pre>Callable</span></code></a>s, i.e., functions or <a class="reference external"href=https://docs.python.org/3/reference/expressions.html#lambda>lambda</a>s, each of which will return one “instance.” Additionally, you provide a sequence of callables (functions or lambdas), each of which receiving one “instance” as input and should return an almost fully configured <a class="reference external"href=./moptipy.api.html#module-moptipy.api.execution><code class="docutils literal notranslate"><span class=pre>Execution</span></code></a>. You also provide the number of runs to be executed per “setup” * “instance” combination and a base directory path identifying the directory where one log file should be written for each run.<p><code class="docutils literal notranslate"><span class=pre>moptipy</span></code> also supports <a class="reference external"href=#parallel-and-distributed-experiments>parallel and distributed experiments</a>.<p>All of this is passed to the function <a class="reference external"href=./moptipy.api.html#moptipy.api.experiment.run_experiment><code class="docutils literal notranslate"><span class=pre>run_experiment</span></code></a> in module <a class="reference external"href=./moptipy.api.html#module-moptipy.api.experiment><code class="docutils literal notranslate"><span class=pre>moptipy.api.experiment</span></code></a>.<p>This function will do all the work and generate a <a class="reference external"href=#file-names-and-folder-structure>folder structure</a> of log files. It will spawn the right number of processes, use your functions to generate “instances” and “setups,” and execute them. It will also <a class="reference external"href=./moptipy.utils.html#moptipy.utils.nputils.rand_seeds_from_str>automatically determine</a> the random seed for each run. The seed sequence is determined from the instance name using a <a class="reference external"href=./moptipy.utils.html#moptipy.utils.nputils.rand_seeds_from_str>deterministic procedure</a> and therefore <a class="reference external"href=#reproducibility>reproducible</a>. The random seed sequence per instance will be the same for all algorithm setups. This means that different algorithms would still start with the same solutions if they sample the first solution in the same way.<p>The system will even do “warmup” runs, i.e., very short dummy runs with the algorithms that are just used to make sure that the interpreter has seen all code before actually doing the experiments. This avoids situations where the first actual run is slower than the others due to additional interpreter action, i.e., it reduces the bias of time measurements.<p>Below, we show one example for the automated experiment execution facility, which applies two algorithms to four problem instances with five runs per setup. We use again the <a class="reference external"href=./moptipy.spaces.html#module-moptipy.spaces.bitstrings>bit strings domain</a>. We explore two problems (<a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.onemax><code class="docutils literal notranslate"><span class=pre>OneMax</span></code></a> and <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.leadingones><code class="docutils literal notranslate"><span class=pre>LeadingOnes</span></code></a>) of two different sizes each, leading to four problem instances in total. We apply the well-known <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.rls><code class="docutils literal notranslate"><span class=pre>RLS</span></code></a> as well as the trivial <a class="reference external"href=./moptipy.algorithms.html#module-moptipy.algorithms.random_sampling>random sampling</a>.<p>The code below is available as file <a class="reference external"href=./examples/experiment_2_algorithms_4_problems_py.html>examples/experiment_2_algorithms_4_problems</a>. Besides executing the experiment, it also prints the end results obtained from parsing the log files (see <a class="reference external"href=#end-result-csv-files>Section 5.2.</a> for more information).<div class="highlight-python notranslate"><div class=highlight><pre><span></span><span class=kn>from</span><span class=w> </span><span class=nn>moptipy.algorithms.so.rls</span><span class=w> </span><span class=kn>import</span> <span class=n>RLS</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.algorithms.random_sampling</span><span class=w> </span><span class=kn>import</span> <span class=n>RandomSampling</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.api.execution</span><span class=w> </span><span class=kn>import</span> <span class=n>Execution</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.api.experiment</span><span class=w> </span><span class=kn>import</span> <span class=n>run_experiment</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.evaluation.end_results</span><span class=w> </span><span class=kn>import</span> <span class=n>from_logs</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.bitstrings.leadingones</span><span class=w> </span><span class=kn>import</span> <span class=n>LeadingOnes</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.bitstrings.onemax</span><span class=w> </span><span class=kn>import</span> <span class=n>OneMax</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.bitstrings.op0_random</span><span class=w> </span><span class=kn>import</span> <span class=n>Op0Random</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.bitstrings.op1_flip1</span><span class=w> </span><span class=kn>import</span> <span class=n>Op1Flip1</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.spaces.bitstrings</span><span class=w> </span><span class=kn>import</span> <span class=n>BitStrings</span>
<span class=kn>from</span><span class=w> </span><span class=nn>pycommons.io.temp</span><span class=w> </span><span class=kn>import</span> <span class=n>temp_dir</span>

<span class=c1># The four problems we want to try to solve:</span>
<span class=n>problems</span> <span class=o>=</span> <span class=p>[</span><span class=k>lambda</span><span class=p>:</span> <span class=n>OneMax</span><span class=p>(</span><span class=mi>10</span><span class=p>),</span>  <span class=c1># 10-dimensional OneMax</span>
            <span class=k>lambda</span><span class=p>:</span> <span class=n>OneMax</span><span class=p>(</span><span class=mi>32</span><span class=p>),</span>  <span class=c1># 32-dimensional OneMax</span>
            <span class=k>lambda</span><span class=p>:</span> <span class=n>LeadingOnes</span><span class=p>(</span><span class=mi>10</span><span class=p>),</span>  <span class=c1># 10-dimensional LeadingOnes</span>
            <span class=k>lambda</span><span class=p>:</span> <span class=n>LeadingOnes</span><span class=p>(</span><span class=mi>32</span><span class=p>)]</span>  <span class=c1># 32-dimensional LeadingOnes</span>


<span class=k>def</span><span class=w> </span><span class=nf>make_rls</span><span class=p>(</span><span class=n>problem</span><span class=p>)</span> <span class=o>-></span> <span class=n>Execution</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Create an RLS Execution.</span>

<span class=sd>    :param problem: the problem (OneMax or LeadingOnes)</span>
<span class=sd>    :returns: the execution</span>
<span class=sd>    """</span>
    <span class=n>ex</span> <span class=o>=</span> <span class=n>Execution</span><span class=p>()</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_solution_space</span><span class=p>(</span><span class=n>BitStrings</span><span class=p>(</span><span class=n>problem</span><span class=o>.</span><span class=n>n</span><span class=p>))</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_objective</span><span class=p>(</span><span class=n>problem</span><span class=p>)</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_algorithm</span><span class=p>(</span><span class=n>RLS</span><span class=p>(</span>  <span class=c1># create RLS that</span>
        <span class=n>Op0Random</span><span class=p>(),</span>  <span class=c1># starts with a random bit string and</span>
        <span class=n>Op1Flip1</span><span class=p>()))</span>  <span class=c1># flips one bit in each step</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_max_fes</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span>  <span class=c1># permit 100 FEs</span>
    <span class=k>return</span> <span class=n>ex</span>


<span class=k>def</span><span class=w> </span><span class=nf>make_random_sampling</span><span class=p>(</span><span class=n>problem</span><span class=p>)</span> <span class=o>-></span> <span class=n>Execution</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Create a Random Sampling Execution.</span>

<span class=sd>    :param problem: the problem (OneMax or LeadingOnes)</span>
<span class=sd>    :returns: the execution</span>
<span class=sd>    """</span>
    <span class=n>ex</span> <span class=o>=</span> <span class=n>Execution</span><span class=p>()</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_solution_space</span><span class=p>(</span><span class=n>BitStrings</span><span class=p>(</span><span class=n>problem</span><span class=o>.</span><span class=n>n</span><span class=p>))</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_objective</span><span class=p>(</span><span class=n>problem</span><span class=p>)</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_algorithm</span><span class=p>(</span><span class=n>RandomSampling</span><span class=p>(</span><span class=n>Op0Random</span><span class=p>()))</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_max_fes</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>ex</span>


<span class=c1># We execute the whole experiment in a temp directory.</span>
<span class=c1># For a real experiment, you would put an existing directory path in `td`</span>
<span class=c1># by doing `from pycommons.io.path import Path; td = directory_path("mydir")`</span>
<span class=c1># and not use the `with` block.</span>
<span class=k>with</span> <span class=n>temp_dir</span><span class=p>()</span> <span class=k>as</span> <span class=n>td</span><span class=p>:</span>  <span class=c1># create temporary directory `td`</span>
    <span class=n>run_experiment</span><span class=p>(</span><span class=n>base_dir</span><span class=o>=</span><span class=n>td</span><span class=p>,</span>  <span class=c1># set the base directory for log files</span>
                   <span class=n>instances</span><span class=o>=</span><span class=n>problems</span><span class=p>,</span>  <span class=c1># define the problem instances</span>
                   <span class=n>setups</span><span class=o>=</span><span class=p>[</span><span class=n>make_rls</span><span class=p>,</span>  <span class=c1># provide RLS run creator</span>
                           <span class=n>make_random_sampling</span><span class=p>],</span>  <span class=c1># provide RS run creator</span>
                   <span class=n>n_runs</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>  <span class=c1># we will execute 5 runs per setup</span>

    <span class=k>for</span> <span class=n>er</span> <span class=ow>in</span> <span class=n>from_logs</span><span class=p>(</span><span class=n>td</span><span class=p>):</span>  <span class=c1># parse all log files and print end results</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>er</span><span class=o>.</span><span class=n>algorithm</span><span class=si>}</span><span class=s2> on </span><span class=si>{</span><span class=n>er</span><span class=o>.</span><span class=n>instance</span><span class=si>}</span><span class=s2>: </span><span class=si>{</span><span class=n>er</span><span class=o>.</span><span class=n>best_f</span><span class=si>}</span><span class=s2>"</span><span class=p>)</span>
<span class=c1># The temp directory is deleted as soon as we leave the `with` block.</span>
</pre></div></div><p>The output of this program, minus the status information, could look roughly like this:<div class="highlight-text notranslate"><div class=highlight><pre><span></span>rs on onemax_10: 0
rs on onemax_10: 2
rs on onemax_10: 1
rs on onemax_10: 2
rs on onemax_10: 1
rs on onemax_32: 8
rs on onemax_32: 8
rs on onemax_32: 8
rs on onemax_32: 9
rs on onemax_32: 9
rs on leadingones_32: 26
rs on leadingones_32: 26
rs on leadingones_32: 25
rs on leadingones_32: 26
rs on leadingones_32: 23
rs on leadingones_10: 4
rs on leadingones_10: 0
rs on leadingones_10: 3
rs on leadingones_10: 3
rs on leadingones_10: 0
rls_flip1 on onemax_10: 0
rls_flip1 on onemax_10: 0
rls_flip1 on onemax_10: 0
rls_flip1 on onemax_10: 0
rls_flip1 on onemax_10: 0
rls_flip1 on onemax_32: 2
rls_flip1 on onemax_32: 1
rls_flip1 on onemax_32: 2
rls_flip1 on onemax_32: 2
rls_flip1 on onemax_32: 1
rls_flip1 on leadingones_32: 18
rls_flip1 on leadingones_32: 23
rls_flip1 on leadingones_32: 28
rls_flip1 on leadingones_32: 16
rls_flip1 on leadingones_32: 29
rls_flip1 on leadingones_10: 0
rls_flip1 on leadingones_10: 0
rls_flip1 on leadingones_10: 0
rls_flip1 on leadingones_10: 0
rls_flip1 on leadingones_10: 0
</pre></div></div><p>You can simply launch the main process several times in parallel in the same folder to achieve parallelism. Actually, you can also execute experiments in a <em>distributed</em> fashion like this: All you have to do is to share the folder for the log files among all computer nodes. Then, in this shared folder, execute the experiment on each node. The system will then automatically ensure that no work is done twice and the experiment runs in a distributed fashion with almost no overhead.<p>The trick is that we create the random seeds in a deterministic fashion so that each experiment on each node will have the same seeds and, hence, the <a class="reference external"href=#file-names-and-folder-structure>same names for the log files</a>. The log files are created emptily right before a run starts and filled with data once the run is completed. Since file creation is atomic in distributed file systems, the system can then automatically ensure that no run is performed by more than one node. This is an extremely simple yet very robust method for distribution with very low overhead.</section><section id=how-to-solve-an-optimization-problem><h3>3.3. How to Solve an Optimization Problem<a title="Link to this heading"class=headerlink href=#how-to-solve-an-optimization-problem>¶</a></h3><p>If you want to solve an optimization problem with <a class="reference external"href=./>moptipy</a>, then you need at least the following three things:<ol class="arabic simple"><li><p>a space <code class="docutils literal notranslate"><span class=pre>Y</span></code> of possible solutions,<li><p>an objective function <code class="docutils literal notranslate"><span class=pre>f</span></code> rating the solutions, i.e., which maps elements <code class="docutils literal notranslate"><span class=pre>y</span></code> of <code class="docutils literal notranslate"><span class=pre>Y</span></code> to either integer or float numbers, where <em>smaller</em> values are better, and<li><p>an optimization algorithm that navigates through <code class="docutils literal notranslate"><span class=pre>Y</span></code> and tries to find solutions <code class="docutils literal notranslate"><span class=pre>y</span></code> in <code class="docutils literal notranslate"><span class=pre>Y</span></code> with low corresponding values <code class="docutils literal notranslate"><span class=pre>f(y)</span></code>.</ol><p>You may need more components, but if you have these three, then you can <a class="reference external"href=#how-to-run-a-series-of-experiments>run an experiment</a>.<section id=define-a-new-problem-type><h4>3.3.1. Define a New Problem Type<a title="Link to this heading"class=headerlink href=#define-a-new-problem-type>¶</a></h4><p>At the core of all optimization problems lies the objective function. All objective functions in <a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> are instances of the class <a class="reference external"href=./moptipy.api.html#moptipy.api.objective.Objective>Objective</a>. If you want to add a new optimization problem, you must derive a new subclass from this class.<p>There are two functions you must be implemented:<ul class=simple><li><p><a class="reference external"href=./moptipy.api.html#moptipy.api.objective.Objective.evaluate><code class="docutils literal notranslate"><span class=pre>evaluate(x)</span></code></a> receives a candidate solution <code class="docutils literal notranslate"><span class=pre>x</span></code> as input and must return either an <code class="docutils literal notranslate"><span class=pre>int</span></code> or a <code class="docutils literal notranslate"><span class=pre>float</span></code> rating its quality (smaller values are <em>better</em>) and<li><p><code class="docutils literal notranslate"><span class=pre>__str__()</span></code> returns a string representation of the objective function and may be used in file names and folder structures (depending on how you execute your experiments). It therefore must not contain spaces and other dodgy characters.</ul><p>Additionally, you <em>may</em> implement the following two functions<ul class=simple><li><p><a class="reference external"href=./moptipy.api.html#moptipy.api.objective.Objective.lower_bound><code class="docutils literal notranslate"><span class=pre>lower_bound()</span></code></a> returns either an <code class="docutils literal notranslate"><span class=pre>int</span></code> or a <code class="docutils literal notranslate"><span class=pre>float</span></code> with the lower bound of the objective value. This value does not need to be an objective value that can actually be reached, but if you implement this function, then the value must be small enough so that it is <em>impossible</em> to ever reach a smaller objective value. If we execute an experiment and no goal objective value is specified, then the system will automatically use this lower bound if it is present. Then, if any solution <code class="docutils literal notranslate"><span class=pre>x</span></code> with <code class="docutils literal notranslate"><span class=pre>f.evaluate(x)==f.lower_bound()</span></code> is encountered, the optimization process is automatically stopped. Furthermore, after the optimization process is stopped, it is verified that the final solution does not have an objective value smaller than the lower bound. If it does, then we throw an exception.<li><p><a class="reference external"href=./moptipy.api.html#moptipy.api.objective.Objective.upper_bound><code class="docutils literal notranslate"><span class=pre>upper_bound()</span></code></a> returns either an <code class="docutils literal notranslate"><span class=pre>int</span></code> or a <code class="docutils literal notranslate"><span class=pre>float</span></code> with the upper bound of the objective value. This value does not need to be an objective value that can actually be reached, but if you implement this function, then the value must be large enough so that it is <em>impossible</em> to ever reach a larger objective value. This function, if present, is used to validate the objective value of the final result of the optimization process.</ul><p>OK, with this information we are basically able to implement our own problem. Here, we define the task “sort n numbers” as optimization problem. Basically, we want that our optimization algorithm works on <a class="reference external"href=./moptipy.spaces.html#module-moptipy.spaces.permutations>permutations</a> of <code class="docutils literal notranslate"><span class=pre>n</span></code> numbers and is searching for the sorted permutation. As objective value, we count the number of “sorting errors” in a permutation. If the number at index <code class="docutils literal notranslate"><span class=pre>i</span></code> is bigger than the number at index <code class="docutils literal notranslate"><span class=pre>i+1</span></code>, then this is a sorting error. If <code class="docutils literal notranslate"><span class=pre>n=5</span></code>, then the permutation <code class="docutils literal notranslate"><span class=pre>0;1;2;3;4</span></code> has no sorting error, i.e., the best possible objective value <code class="docutils literal notranslate"><span class=pre>0</span></code>. The permutation <code class="docutils literal notranslate"><span class=pre>4;3;2;1;0</span></code> has <code class="docutils literal notranslate"><span class=pre>n-1=4</span></code> sorting errors, i.e., is the worst possible solution. The permutation <code class="docutils literal notranslate"><span class=pre>3;4;2;0;1</span></code> as <code class="docutils literal notranslate"><span class=pre>2</span></code> sorting errors.<p>From these thoughts, we also know that we can implement <code class="docutils literal notranslate"><span class=pre>lower_bound()</span></code> to return <code class="docutils literal notranslate"><span class=pre>0</span></code> and <code class="docutils literal notranslate"><span class=pre>upper_bound()</span></code> to return <code class="docutils literal notranslate"><span class=pre>n-1</span></code>. <code class="docutils literal notranslate"><span class=pre>__str__</span></code> could be <code class="docutils literal notranslate"><span class=pre>"sort"</span> <span class=pre>+</span> <span class=pre>n</span></code>, i.e., <code class="docutils literal notranslate"><span class=pre>sort5</span></code> in the above example where <code class="docutils literal notranslate"><span class=pre>n=5</span></code>.<p>We provide the corresponding code in <a class="reference external"href=#applying-an-own-algorithm-to-an-own-problem>Section 3.3.3</a> below.</section><section id=define-a-new-algorithm><h4>3.3.2. Define a New Algorithm<a title="Link to this heading"class=headerlink href=#define-a-new-algorithm>¶</a></h4><p>While <a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> comes with several <a class="reference external"href=#implemented-algorithms>well-known algorithms</a> out-of-the-box, you can of course also implement your own <a class="reference external"href=./moptipy.api.html#moptipy.api.algorithm.Algorithm>algorithms</a>. These can then make use of the existing <a class="reference external"href=./moptipy.api.html#moptipy.api.space.Space>spaces</a> and <a class="reference external"href=./moptipy.api.html#module-moptipy.api.operators>search operators</a> – or not. Let us here create an example algorithm implementation that does <em>not</em> use any of the pre-defined <a class="reference external"href=./moptipy.api.html#module-moptipy.api.operators>search operators</a>.<p>All optimization algorithms must be subclasses of the class <a class="reference external"href=./moptipy.api.html#moptipy.api.algorithm.Algorithm>Algorithm</a>. Each of them must implement two methods, as described in the <a class="reference external"href=./moptipy.api.html#module-moptipy.api.algorithm>documentation</a>:<ul class=simple><li><p><a class="reference external"href=./moptipy.api.html#moptipy.api.algorithm.Algorithm.solve><code class="docutils literal notranslate"><span class=pre>solve(process)</span></code></a> receives an instance of <a class="reference external"href=./moptipy.api.html#module-moptipy.api.process><code class="docutils literal notranslate"><span class=pre>Process</span></code></a>, which provides the operations to work with the search space, to evaluate solutions, the termination criterion, and the random number generator.<li><p><code class="docutils literal notranslate"><span class=pre>__str__()</span></code> must return a short string representation identifying the algorithm and its setup. This string will be used in file and folder names and therefore must not contain spaces or otherwise dodgy characters.</ul><p>Additionally, you may need to implement the following methods if the algorithm has other components:<ul class=simple><li><p><a class="reference external"href=./moptipy.api.html#moptipy.api.component.Component.initialize><code class="docutils literal notranslate"><span class=pre>initialize()</span></code></a> initializes all sub-components of the algorithms and is called <em>before</em> each run. The base class <a class="reference external"href=./moptipy.api.html#moptipy.api.component.Component><code class="docutils literal notranslate"><span class=pre>Component</span></code></a>, from which all elements of the optimization API are derived, already has this method. If a new algorithm uses, for example, a <a class="reference external"href=./moptipy.algorithms.modules.html#module-moptipy.algorithms.modules.selection>selection</a> algorithm, a <a class="reference external"href=./moptipy.algorithms.modules.html#module-moptipy.algorithms.modules.selection>temperature schedule</a>, or a <a class="reference external"href=./moptipy.api.html#module-moptipy.api.operators>search operator</a>, it needs to invoke the <code class="docutils literal notranslate"><span class=pre>initialize()</span></code> methods of these components from its own <code class="docutils literal notranslate"><span class=pre>initialize()</span></code> method.<li><p><a class="reference external"href=./moptipy.api.html#moptipy.api.component.Component.log_parameters_to><code class="docutils literal notranslate"><span class=pre>log_parameters_to(...)</span></code></a> is used to store all the configuration parameters of an algorithm to a <a class="reference external"href=./moptipy.utils.html#moptipy.utils.logger.KeyValueLogSection>log section</a>. If the algorithm has any sub-components, it must here invoke the <code class="docutils literal notranslate"><span class=pre>log_parameters_to(...)</span></code> method of these components. In this case, it can pass different <a class="reference external"href=./moptipy.utils.html#moptipy.utils.logger.KeyValueLogSection.scope>prefix scopes</a> to the <code class="docutils literal notranslate"><span class=pre>log_parameters_to(...)</span></code> methods of its components. Then, different prefixes can be added to each component’s parameter keys, ensuring that all keys are unique.</ul><p>The instance <code class="docutils literal notranslate"><span class=pre>process</span></code> of <a class="reference external"href=./moptipy.api.html#module-moptipy.api.process><code class="docutils literal notranslate"><span class=pre>Process</span></code></a> passed to the function <a class="reference external"href=./moptipy.api.html#moptipy.api.algorithm.Algorithm.solve><code class="docutils literal notranslate"><span class=pre>solve</span></code></a> is a key element of our <a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> API. If the algorithm needs a data structure to hold a point in the search space, it should invoke <a class="reference external"href=./moptipy.api.html#moptipy.api.space.Space.create><code class="docutils literal notranslate"><span class=pre>process.create()</span></code></a>. If it needs to copy the point <code class="docutils literal notranslate"><span class=pre>source</span></code> to the point <code class="docutils literal notranslate"><span class=pre>dest</span></code>, it should invoke <a class="reference external"href=./moptipy.api.html#moptipy.api.space.Space.copy><code class="docutils literal notranslate"><span class=pre>process.copy(dest,</span> <span class=pre>source)</span></code></a>.<p>If it wants to know the quality of the point <code class="docutils literal notranslate"><span class=pre>x</span></code>, it should invoke <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.evaluate><code class="docutils literal notranslate"><span class=pre>process.evaluate(x)</span></code></a>. This function will forward the call to the actual objective function (see, e.g., <a class="reference external"href=#define-a-new-problem-type>Section 3.3.1</a> above). However, it will do more: It will automatically keep track of the best-so-far solution and, if needed, build logging information in memory.<p>Before every single call to <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.evaluate><code class="docutils literal notranslate"><span class=pre>process.evaluate()</span></code></a>, you should invoke <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.should_terminate><code class="docutils literal notranslate"><span class=pre>process.should_terminate()</span></code></a>. This function returns <code class="docutils literal notranslate"><span class=pre>True</span></code> if the optimization algorithm should stop whatever it is doing and return. This can happen when a solution of sufficiently good quality is reached, when the maximum number of FEs is exhausted, or when the computational budget in terms of runtime is exhausted.<p>Since many optimization algorithms make random choices, the function <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.get_random><code class="docutils literal notranslate"><span class=pre>process.get_random()</span></code></a> returns a <a class="reference external"href=https://numpy.org/doc/stable/reference/random/generator.html>random number generator</a>. This generator <em>must</em> be the only source of randomness used by an algorithm. It will automatically be seeded by our system, allowing for <a class="reference external"href=https://www.acm.org/publications/policies/artifact-review-and-badging-current>repeatable and reproducible</a> runs.<p>The <code class="docutils literal notranslate"><span class=pre>process</span></code> also can provide information about the best-so-far <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.get_copy_of_best_y>solution</a> or <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.get_copy_of_best_x>point in the search space</a>, the consumed <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.get_consumed_time_millis>runtime</a> and <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.get_consumed_fes>FEs</a>, as well as <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.get_last_improvement_fe>when the last improvement was achieved</a>. Anyway, all interaction between the algorithm and the actual optimization algorithm will happen through the <code class="docutils literal notranslate"><span class=pre>process</span></code> object.<p>Equipped with this information, we can develop a simple and rather stupid algorithm to attack the sorting problem. The search space that we use are the <a class="reference external"href=./moptipy.spaces.html#module-moptipy.spaces.permutations>permutations</a> of <code class="docutils literal notranslate"><span class=pre>n</span></code> numbers. (These will be internally represented as <a class="reference external"href=https://numpy.org/doc/stable/reference/arrays.ndarray.html>numpy <code class="docutils literal notranslate"><span class=pre>ndarray</span></code>s</a>, but we do not need to bother with this, as we this is done automatically for us.) Our algorithm should start with allocating a point <code class="docutils literal notranslate"><span class=pre>x_cur</span></code> in the search space, filling it with the numbers <code class="docutils literal notranslate"><span class=pre>0..n-1</span></code>, and shuffling it randomly (because we want to start at a random solution). For the shuffling, it will use than random number generator provided by <code class="docutils literal notranslate"><span class=pre>process</span></code>. It will evaluate this solution and remember its quality in variable <code class="docutils literal notranslate"><span class=pre>f_cur</span></code>. It will also allocate a second container <code class="docutils literal notranslate"><span class=pre>x_new</span></code> for permutations.<p>In each step, our algorithm will copy <code class="docutils literal notranslate"><span class=pre>x_cur</span></code> to <code class="docutils literal notranslate"><span class=pre>x_new</span></code>. Then, it will use the random number generator to draw two numbers <code class="docutils literal notranslate"><span class=pre>i</span></code> and <code class="docutils literal notranslate"><span class=pre>j</span></code> from <code class="docutils literal notranslate"><span class=pre>0..n-1</span></code>. It will swap the two numbers at these indices in <code class="docutils literal notranslate"><span class=pre>x_new</span></code>, i.e., exchange <code class="docutils literal notranslate"><span class=pre>x_new[i],</span> <span class=pre>x_new[j]</span> <span class=pre>=</span> <span class=pre>x_new[j],</span> <span class=pre>x_new[i]</span></code>. We then evaluate <code class="docutils literal notranslate"><span class=pre>x_new</span></code> and if the resulting objective value <code class="docutils literal notranslate"><span class=pre>f_new</span></code> is better than <code class="docutils literal notranslate"><span class=pre>f_cur</span></code>, we swap <code class="docutils literal notranslate"><span class=pre>x_new</span></code> and <code class="docutils literal notranslate"><span class=pre>x_cur</span></code> (which is faster than copying <code class="docutils literal notranslate"><span class=pre>x_new</span></code> to <code class="docutils literal notranslate"><span class=pre>x_cur</span></code>) and store <code class="docutils literal notranslate"><span class=pre>f_new</span></code> in <code class="docutils literal notranslate"><span class=pre>f_cur</span></code>. We repeat this until <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.should_terminate><code class="docutils literal notranslate"><span class=pre>process.should_terminate()</span></code></a> becomes <code class="docutils literal notranslate"><span class=pre>True</span></code>. All of this is implemented in the source code example below in <a class="reference external"href=#applying-an-own-algorithm-to-an-own-problem>Section 3.3.3</a>.<p>Finally, as a side note: Our system can automatically store the results of optimization processes in <a class="reference external"href=#log-files>log file</a>. The <code class="docutils literal notranslate"><span class=pre>process</span></code> API also allows your algorithm to store additional information in these files: First, you can check with <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.has_log><code class="docutils literal notranslate"><span class=pre>process.has_log()</span></code></a> if the process was configured to store information in a log file. If this function returns <code class="docutils literal notranslate"><span class=pre>True</span></code>, then you can create a <a class="reference external"href=#log-file-sections>section</a> with a given <code class="docutils literal notranslate"><span class=pre>title</span></code> in the log files that should contain one single string <code class="docutils literal notranslate"><span class=pre>text</span></code> by calling <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.add_log_section><code class="docutils literal notranslate"><span class=pre>process.add_log_section(title,</span> <span class=pre>text)</span></code></a>. Make sure that all section <code class="docutils literal notranslate"><span class=pre>title</span></code>s are unique. All such sections will be appended at the end of the log files, wrapped in <code class="docutils literal notranslate"><span class=pre>BEGIN_title</span></code> and <code class="docutils literal notranslate"><span class=pre>END_title</span></code> markers, as prescribed by <a class="reference external"href=#log-file-sections>our log file format</a>.</section><section id=applying-an-own-algorithm-to-an-own-problem><h4>3.3.3. Applying an Own Algorithm to an Own Problem<a title="Link to this heading"class=headerlink href=#applying-an-own-algorithm-to-an-own-problem>¶</a></h4><p>The following code combines our <a class="reference external"href=#define-a-new-algorithm>own algorithm</a> and our <a class="reference external"href=#define-a-new-problem-type>own problem type</a> that we discussed in the prior two sections and executes an experiment. It is available as file <a class="reference external"href=./examples/experiment_own_algorithm_and_problem_py.html>examples/experiment_own_algorithm_and_problem</a>. Notice how we provide functions for generating both the problem instances (here the objective functions) and the algorithm setups exactly as we described in <a class="reference external"href=#how-to-run-a-series-of-experiments>Section 3.2.</a> above.<div class="highlight-python notranslate"><div class=highlight><pre><span></span><span class=kn>from</span><span class=w> </span><span class=nn>moptipy.api.algorithm</span><span class=w> </span><span class=kn>import</span> <span class=n>Algorithm</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.api.execution</span><span class=w> </span><span class=kn>import</span> <span class=n>Execution</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.api.experiment</span><span class=w> </span><span class=kn>import</span> <span class=n>run_experiment</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.api.objective</span><span class=w> </span><span class=kn>import</span> <span class=n>Objective</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.api.process</span><span class=w> </span><span class=kn>import</span> <span class=n>Process</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.evaluation.end_results</span><span class=w> </span><span class=kn>import</span> <span class=n>from_logs</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.spaces.permutations</span><span class=w> </span><span class=kn>import</span> <span class=n>Permutations</span>
<span class=kn>from</span><span class=w> </span><span class=nn>pycommons.io.temp</span><span class=w> </span><span class=kn>import</span> <span class=n>temp_dir</span>


<span class=k>class</span><span class=w> </span><span class=nc>MySortProblem</span><span class=p>(</span><span class=n>Objective</span><span class=p>):</span>
<span class=w>    </span><span class=sd>"""An objective function that rates how well a permutation is sorted."""</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>n</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Initialize: Set the number of values to sort.</span>

<span class=sd>        :param n: the scale of the problem</span>
<span class=sd>        """</span>
        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>()</span>
        <span class=c1>#: the number of numbers to sort</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>n</span> <span class=o>=</span> <span class=n>n</span>

    <span class=k>def</span><span class=w> </span><span class=nf>evaluate</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span> <span class=o>-></span> <span class=nb>int</span><span class=p>:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Compute how often a bigger number follows a smaller one.</span>

<span class=sd>        :param x: the permutation</span>
<span class=sd>        """</span>
        <span class=n>errors</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># we start at zero errors</span>
        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>  <span class=c1># for i in 0..n-2</span>
            <span class=k>if</span> <span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>></span> <span class=n>x</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]:</span>  <span class=c1># that's a sorting error!</span>
                <span class=n>errors</span> <span class=o>+=</span> <span class=mi>1</span>  <span class=c1># so we increase the number</span>
        <span class=k>return</span> <span class=n>errors</span>  <span class=c1># return result</span>

    <span class=k>def</span><span class=w> </span><span class=nf>lower_bound</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=nb>int</span><span class=p>:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Get the lower bound: 0 errors is the optimum.</span>

<span class=sd>        Implementing this function is optional, but it can help in two ways:</span>
<span class=sd>        First, the optimization processes can be stopped automatically when a</span>
<span class=sd>        solution of this quality is reached. Second, the lower bound is also</span>
<span class=sd>        checked when the end results of the optimization process are verified.</span>

<span class=sd>        :returns: 0</span>
<span class=sd>        """</span>
        <span class=k>return</span> <span class=mi>0</span>

    <span class=k>def</span><span class=w> </span><span class=nf>upper_bound</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=nb>int</span><span class=p>:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Get the upper bound: n-1 errors is the worst.</span>

<span class=sd>        Implementing this function is optional, but it can help, e.g., when</span>
<span class=sd>        the results of the optimization process are automatically checked.</span>

<span class=sd>        :returns: n-1</span>
<span class=sd>        """</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__str__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Get the name of this problem.</span>

<span class=sd>        This name is used in the directory structure and file names of the</span>
<span class=sd>        log files.</span>

<span class=sd>        :returns: "sort" + n</span>
<span class=sd>        """</span>
        <span class=k>return</span> <span class=sa>f</span><span class=s2>"sort</span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>n</span><span class=si>}</span><span class=s2>"</span>


<span class=k>class</span><span class=w> </span><span class=nc>MyAlgorithm</span><span class=p>(</span><span class=n>Algorithm</span><span class=p>):</span>
<span class=w>    </span><span class=sd>"""An example for a simple rigidly structured optimization algorithm."""</span>

    <span class=k>def</span><span class=w> </span><span class=nf>solve</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>process</span><span class=p>:</span> <span class=n>Process</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Solve the problem encapsulated in the provided process.</span>

<span class=sd>        :param process: the process instance which provides random numbers,</span>
<span class=sd>            functions for creating, copying, and evaluating solutions, as well</span>
<span class=sd>            as the termination criterion</span>
<span class=sd>        """</span>
        <span class=n>random</span> <span class=o>=</span> <span class=n>process</span><span class=o>.</span><span class=n>get_random</span><span class=p>()</span>  <span class=c1># get the random number generator</span>
        <span class=n>x_cur</span> <span class=o>=</span> <span class=n>process</span><span class=o>.</span><span class=n>create</span><span class=p>()</span>  <span class=c1># create the record for the current solution</span>
        <span class=n>x_new</span> <span class=o>=</span> <span class=n>process</span><span class=o>.</span><span class=n>create</span><span class=p>()</span>  <span class=c1># create the record for the new solution</span>
        <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>x_cur</span><span class=p>)</span>  <span class=c1># get the scale of problem as length of the solution</span>

        <span class=n>x_cur</span><span class=p>[:]</span> <span class=o>=</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>  <span class=c1># We start by initializing the initial solution</span>
        <span class=n>random</span><span class=o>.</span><span class=n>shuffle</span><span class=p>(</span><span class=n>x_cur</span><span class=p>)</span>  <span class=c1># as [0...n-1] and then randomly shuffle it.</span>
        <span class=n>f_cur</span> <span class=o>=</span> <span class=n>process</span><span class=o>.</span><span class=n>evaluate</span><span class=p>(</span><span class=n>x_cur</span><span class=p>)</span>  <span class=c1># compute solution quality</span>

        <span class=k>while</span> <span class=ow>not</span> <span class=n>process</span><span class=o>.</span><span class=n>should_terminate</span><span class=p>():</span>  <span class=c1># repeat until we are finished</span>
            <span class=n>process</span><span class=o>.</span><span class=n>copy</span><span class=p>(</span><span class=n>x_new</span><span class=p>,</span> <span class=n>x_cur</span><span class=p>)</span>  <span class=c1># copy current to new solution</span>
            <span class=n>i</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>integers</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>  <span class=c1># choose the first random index</span>
            <span class=n>j</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>integers</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>  <span class=c1># choose the second random index</span>
            <span class=n>x_new</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>x_new</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>x_new</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>x_new</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>  <span class=c1># swap values at i and j</span>
            <span class=n>f_new</span> <span class=o>=</span> <span class=n>process</span><span class=o>.</span><span class=n>evaluate</span><span class=p>(</span><span class=n>x_new</span><span class=p>)</span>  <span class=c1># evaluate the new solution</span>
            <span class=k>if</span> <span class=n>f_new</span> <span class=o><</span> <span class=n>f_cur</span><span class=p>:</span>  <span class=c1># if it is better than current solution</span>
                <span class=n>x_new</span><span class=p>,</span> <span class=n>x_cur</span> <span class=o>=</span> <span class=n>x_cur</span><span class=p>,</span> <span class=n>x_new</span>  <span class=c1># swap current and new solution</span>
                <span class=n>f_cur</span> <span class=o>=</span> <span class=n>f_new</span>  <span class=c1># and remember quality of new solution</span>

    <span class=k>def</span><span class=w> </span><span class=fm>__str__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=w>        </span><span class=sd>"""</span>
<span class=sd>        Get the name of this algorithm.</span>

<span class=sd>        This name is then used in the directory path and file name of the</span>
<span class=sd>        log files.</span>

<span class=sd>        :returns: myAlgo</span>
<span class=sd>        """</span>
        <span class=k>return</span> <span class=s2>"myAlgo"</span>


<span class=c1># The four problems we want to try to solve:</span>
<span class=n>problems</span> <span class=o>=</span> <span class=p>[</span><span class=k>lambda</span><span class=p>:</span> <span class=n>MySortProblem</span><span class=p>(</span><span class=mi>5</span><span class=p>),</span>  <span class=c1># sort 5 numbers</span>
            <span class=k>lambda</span><span class=p>:</span> <span class=n>MySortProblem</span><span class=p>(</span><span class=mi>10</span><span class=p>),</span>  <span class=c1># sort 10 numbers</span>
            <span class=k>lambda</span><span class=p>:</span> <span class=n>MySortProblem</span><span class=p>(</span><span class=mi>100</span><span class=p>)]</span>  <span class=c1># sort 100 numbers</span>


<span class=k>def</span><span class=w> </span><span class=nf>make_execution</span><span class=p>(</span><span class=n>problem</span><span class=p>)</span> <span class=o>-></span> <span class=n>Execution</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Create an application of our algorithm to our problem.</span>

<span class=sd>    :param problem: the problem (MySortProblem)</span>
<span class=sd>    :returns: the execution</span>
<span class=sd>    """</span>
    <span class=n>ex</span> <span class=o>=</span> <span class=n>Execution</span><span class=p>()</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_solution_space</span><span class=p>(</span>
        <span class=n>Permutations</span><span class=o>.</span><span class=n>standard</span><span class=p>(</span><span class=n>problem</span><span class=o>.</span><span class=n>n</span><span class=p>))</span>  <span class=c1># we use permutations of [0..n-1]</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_objective</span><span class=p>(</span><span class=n>problem</span><span class=p>)</span>  <span class=c1># set the objective function</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_algorithm</span><span class=p>(</span><span class=n>MyAlgorithm</span><span class=p>())</span>  <span class=c1># apply our algorithm</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_max_fes</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span>  <span class=c1># permit 100 FEs</span>
    <span class=k>return</span> <span class=n>ex</span>


<span class=c1># We execute the whole experiment in a temp directory.</span>
<span class=c1># For a real experiment, you would put an existing directory path in `td`</span>
<span class=c1># by doing `from pycommons.io.path import Path; td = directory_path("mydir")`</span>
<span class=c1># and not use the `with` block.</span>
<span class=k>with</span> <span class=n>temp_dir</span><span class=p>()</span> <span class=k>as</span> <span class=n>td</span><span class=p>:</span>  <span class=c1># create temporary directory `td`</span>
    <span class=n>run_experiment</span><span class=p>(</span><span class=n>base_dir</span><span class=o>=</span><span class=n>td</span><span class=p>,</span>  <span class=c1># set the base directory for log files</span>
                   <span class=n>instances</span><span class=o>=</span><span class=n>problems</span><span class=p>,</span>  <span class=c1># define the problem instances</span>
                   <span class=n>setups</span><span class=o>=</span><span class=p>[</span><span class=n>make_execution</span><span class=p>],</span>  <span class=c1># creator for our algorithm</span>
                   <span class=n>n_runs</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>  <span class=c1># we will execute 5 runs per setup</span>
    <span class=k>for</span> <span class=n>er</span> <span class=ow>in</span> <span class=n>from_logs</span><span class=p>(</span><span class=n>td</span><span class=p>):</span>  <span class=c1># parse all log files and print end results</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>er</span><span class=o>.</span><span class=n>algorithm</span><span class=si>}</span><span class=s2> on </span><span class=si>{</span><span class=n>er</span><span class=o>.</span><span class=n>instance</span><span class=si>}</span><span class=s2>: </span><span class=si>{</span><span class=n>er</span><span class=o>.</span><span class=n>best_f</span><span class=si>}</span><span class=s2>"</span><span class=p>)</span>
<span class=c1># The temp directory is deleted as soon as we leave the `with` block.</span>
</pre></div></div><p>The output of this program, minus status output, could look like this:<div class="highlight-text notranslate"><div class=highlight><pre><span></span>myAlgo on sort10: 2
myAlgo on sort10: 2
myAlgo on sort10: 1
myAlgo on sort10: 1
myAlgo on sort10: 2
myAlgo on sort100: 35
myAlgo on sort100: 41
myAlgo on sort100: 33
myAlgo on sort100: 34
myAlgo on sort100: 35
myAlgo on sort5: 1
myAlgo on sort5: 1
myAlgo on sort5: 1
myAlgo on sort5: 1
myAlgo on sort5: 1
</pre></div></div></section></section></section><section id=implemented-algorithms-search-spaces-and-problems><h2>4. Implemented Algorithms, Search Spaces, and Problems<a title="Link to this heading"class=headerlink href=#implemented-algorithms-search-spaces-and-problems>¶</a></h2><p>Here we list the <a class="reference external"href=#implemented-algorithms>algorithms</a>, <a class="reference external"href=#implemented-search-spaces-and-operators>search spaces</a>, and <a class="reference external"href=#implemented-problems>optimization problems</a> that we implement in our <a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> framework.<section id=implemented-algorithms><h3>4.1. Implemented Algorithms<a title="Link to this heading"class=headerlink href=#implemented-algorithms>¶</a></h3><p>The following algorithms are completely black-box and work for both single- and multi-objective optimization. (Well, <em>work</em> here is relative … they are basically the worst possible algorithms you could choose and are only included for the sake of completeness.)<ul class=simple><li><p><a class="reference external"href=./moptipy.algorithms.html#module-moptipy.algorithms.single_random_sample>Single Random Sample</a> creates and evaluates exactly one single random solution.<li><p><a class="reference external"href=./moptipy.algorithms.html#module-moptipy.algorithms.random_sampling>Random Sampling</a> keeps creating random solutions until the computational budget is exhausted.<li><p><a class="reference external"href=./moptipy.algorithms.html#module-moptipy.algorithms.random_sampling>Random Walk</a> creates a random solution and then keeps applying the unary search operator and always accepts the result.</ul><section id=single-objective-optimization><h4>4.1.1. Single-Objective Optimization<a title="Link to this heading"class=headerlink href=#single-objective-optimization>¶</a></h4><p>Here we list optimization algorithms that optimize a <em>single</em> <a class="reference external"href=./moptipy.api.html#moptipy.api.objective.Objective>objective function</a>.<section id=single-objective-optimization-with-arbitrary-search-spaces><h5>4.1.1.1. Single-Objective Optimization with Arbitrary Search Spaces<a title="Link to this heading"class=headerlink href=#single-objective-optimization-with-arbitrary-search-spaces>¶</a></h5><p>The first set of algorithms is general, i.e., can work with arbitrary <a class="reference external"href=#implemented-search-spaces-and-operators>search spaces</a>.<ul class=simple><li><p>The simple <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.hill_climber>Hill Climber</a> creates a random solution as initial best-so-far solution and then iteratively applies the unary search operator to the best-so-far solution. When the result of the unary operator is better, it becomes the new best-so-far solution, otherwise it is discarded.<li><p>The <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.hill_climber_with_restarts>Hill Climber with Restarts</a> works exactly like the hill climber, but restarts at a new random solution after a fixed number of unsuccessful moves.<li><p>A Random Local Search (<a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.rls>RLS</a>) also known as (1+1) EA works like the <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.hill_climber>Hill Climber</a> as well, but accepts a new solution if it is <em>not worse</em> than the best-so-far solution (instead of requiring it to be strictly <em>better</em>, as the hill climber does).<li><p>The <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.ea>(μ+λ) EA</a>, where “EA” stands for “Evolutionary Algorithm,” is a simple population-based metaheuristic that starts with a population of <code class="docutils literal notranslate"><span class=pre>mu</span></code> random solutions. In each iteration, it retains only the <code class="docutils literal notranslate"><span class=pre>mu</span></code> best solutions from the population (“best” in terms of the objective value, ties are broken such that newer solutions are preferred). It then applies the unary operator and the binary operator to generate <code class="docutils literal notranslate"><span class=pre>lambda</span></code> new solutions and adds them to the population. The <code class="docutils literal notranslate"><span class=pre>(1+1)</span> <span class=pre>EA</span></code> with <code class="docutils literal notranslate"><span class=pre>br=0</span></code> probability to use the binary operator is equivalent to <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.rls>RLS</a>.<li><p>The <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.general_ea>general EA</a> is a generalized version of the (μ+λ) EA that can additionally be configured with a <a class="reference external"href=./moptipy.algorithms.so.fitnesses.html>fitness assignment process</a> and both survival and mating <a class="reference external"href=./moptipy.algorithms.modules.html#module-moptipy.algorithms.modules.selection>selection algorithms</a>.<li><p>Simulated Annealing (<a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.simulated_annealing>SA</a>) is similar to <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.rls>RLS</a> but sometimes accepts worsening moves. The probability to accept such moves gets smaller the worse the moves are and the longer the search continues.<li><p>The (μ+λ) Memetic Algorithm (<a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.ma>MA</a>) works like the <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.ea>(μ+λ) EA</a> but it applies the binary search operator at a rate of 100%. (In other words, it never uses the unary search operator). It refines the results of the nullary and binary search operators by using them as starting points of another algorithm, say an <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.simulated_annealing>SA</a> or <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.rls>RLS</a>, which is executed for a pre-defined number of steps.<li><p>The above <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.ma>MA</a> can be configured to use <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.rls>RLS</a> as local search. This special case is also implemented as hard-coded <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.marls>MA-RLS</a>, which should be a little bit more speed-efficient (due to hard-coding the local search instead of plugging it in), but otherwise it takes the exactly same route through the search space.<li><p>The <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.general_ma>general MA</a> is a generalized version of the (μ+λ) MA that can additionally be configured with a <a class="reference external"href=./moptipy.algorithms.so.fitnesses.html>fitness assignment process</a> and both survival and mating <a class="reference external"href=./moptipy.algorithms.modules.html#module-moptipy.algorithms.modules.selection>selection algorithms</a>.<li><p>The Plant Propagation Algorithm (<a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.ppa>PPA</a>) is a population-based metaheuristic that allocates both the number of new solutions to be derived from an existing solution via the unary search operator as well as the step size to be used by this operator based on the normalized objective value of the solution.</ul></section><section id=single-objective-optimization-with-continuous-search-space><h5>4.1.1.2. Single-Objective Optimization with Continuous Search Space<a title="Link to this heading"class=headerlink href=#single-objective-optimization-with-continuous-search-space>¶</a></h5><p>The algorithms listed here are intended for single-objective optimization of <a class="reference external"href=./moptipy.spaces.html#moptipy.spaces.vectorspace.VectorSpace>continuous search spaces</a>. They <em>only</em> work with search spaces that are instances of <a class="reference external"href=./moptipy.spaces.html#moptipy.spaces.vectorspace.VectorSpace><code class="docutils literal notranslate"><span class=pre>VectorSpace</span></code></a>. Such spaces are defined by box-constraints over the <em>n</em>-dimensional real numbers.<ul class=simple><li><p>The quasi-Newton method by Broyden, Fletcher, Goldfarb, and Shanno (<a class="reference external"href=./moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.BGFS>BFGS</a>), wrapped from <a class="reference external"href=https://docs.scipy.org/doc/scipy/reference/optimize.minimize-bfgs.html>SciPy</a>.<li><p>The Conjugate Gradient (<a class="reference external"href=./moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.CG>CG</a>) algorithm, wrapped from <a class="reference external"href=https://docs.scipy.org/doc/scipy/reference/optimize.minimize-cg.html>SciPy</a>.<li><p>The Covariance Matrix Adaptation Evolution Strategies <a class="reference external"href=./moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.cmaes_lib.CMAES>CMA-ES</a>, <a class="reference external"href=./moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.cmaes_lib.SepCMAES>Separable CMA-ES</a>, and <a class="reference external"href=./moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.cmaes_lib.BiPopCMAES>BIPOP-CMA-ES</a> from the library <a class="reference external"href=https://pypi.org/project/cmaes>cmaes</a>.<li><p>Differential Evolution (<a class="reference external"href=./moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.DE>DE</a>), wrapped from <a class="reference external"href=https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.differential_evolution.html>SciPy</a>.<li><p>The Downhill Simplex method based on the <a class="reference external"href=./moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.NelderMead>Nelder-Mead</a>, wrapped from <a class="reference external"href=https://docs.scipy.org/doc/scipy/reference/optimize.minimize-neldermead.html>SciPy</a>.<li><p><a class="reference external"href=./moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.Powell>Powell’s Algorithm</a>, wrapped from <a class="reference external"href=https://docs.scipy.org/doc/scipy/reference/optimize.minimize-powell.html>SciPy</a>.<li><p>The Sequential Least Squares Programming (<a class="reference external"href=./moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.SLSQP>SLSQP</a> algorithm, wrapped from <a class="reference external"href=https://docs.scipy.org/doc/scipy/reference/optimize.minimize-slsqp.html>SciPy</a>).<li><p>The Truncated Newton Method (<a class="reference external"href=./moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.TNC>TNC</a>), wrapped from <a class="reference external"href=https://docs.scipy.org/doc/scipy/reference/optimize.minimize-tnc.html>SciPy</a>.</ul></section></section><section id=multi-objective-optimization><h4>4.1.2. Multi-Objective Optimization<a title="Link to this heading"class=headerlink href=#multi-objective-optimization>¶</a></h4><p>The algorithms listed here are suitable for <a class="reference external"href=./moptipy.api.html#moptipy.api.mo_problem.MOProblem>multi-objective optimization</a>. In other words, they try to minimize multiple <a class="reference external"href=./moptipy.api.html#moptipy.api.objective.Objective>objective functions</a> at once.<ul class=simple><li><p><a class="reference external"href=./moptipy.algorithms.mo.html#moptipy.algorithms.mo.morls.MORLS>Multi-Objective Random Local Search</a> (MORLS) works exactly as <a class="reference external"href=./moptipy.algorithms.so.html#moptipy.algorithms.so.rls.RLS>RLS</a>, but it accepts a solution if it is not dominated by the current solution. This is <em>not</em> a good algorithm.<li><p>The Fast Elitist Non-Dominated Sorting Genetic Algorithm (<a class="reference external"href=./moptipy.algorithms.mo.html#module-moptipy.algorithms.mo.nsga2>NSGA-II</a>) is maybe the most popular multi-objective evolutionary algorithm.</ul></section></section><section id=implemented-search-spaces-and-operators><h3>4.2. Implemented Search Spaces and Operators<a title="Link to this heading"class=headerlink href=#implemented-search-spaces-and-operators>¶</a></h3><ul class=simple><li><p><a class="reference external"href=./moptipy.spaces.html#moptipy.spaces.bitstrings.BitStrings>Bit Strings</a> of a fixed length <code class="docutils literal notranslate"><span class=pre>n</span></code> are represented as <code class="docutils literal notranslate"><span class=pre>numpy</span></code> arrays as well. Here, each value can either be <code class="docutils literal notranslate"><span class=pre>True</span></code> or <code class="docutils literal notranslate"><span class=pre>False</span></code>.</p> <ul><li><p>Nullary Operators:</p> <ul><li><p><a class="reference external"href=./moptipy.operators.bitstrings.html#moptipy.operators.bitstrings.op0_random.Op0Random>random initialization</a> fills the string with random bits</ul><li><p>Unary Operators:</p> <ul><li><p><a class="reference external"href=./moptipy.operators.bitstrings.html#moptipy.operators.bitstrings.op1_flip1.Op1Flip1>flip 1</a> flips one single bit.<li><p><a class="reference external"href=./moptipy.operators.bitstrings.html#moptipy.operators.bitstrings.op1_m_over_n_flip.Op1MoverNflip.op1>flip m/n</a> flips each bit independently with probability <code class="docutils literal notranslate"><span class=pre>m/n</span></code>.<li><p><a class="reference external"href=./moptipy.operators.bitstrings.html#module-moptipy.operators.bitstrings.op1_flip_m>flip m</a> is an operator with step width where the exact number of bits to flip can be determined.</ul><li><p>Binary Operators:</p> <ul><li><p><a class="reference external"href=./moptipy.operators.bitstrings.html#moptipy.operators.bitstrings.op2_uniform.Op2Uniform>uniform crossover</a> randomly chooses, for each bit, from which of the two source strings it will be copied.</ul></ul><li><p><a class="reference external"href=./moptipy.spaces.html#module-moptipy.spaces.permutations>Permutations</a> with and without Repetitions are represented as numpy arrays of integers. A permutation of the values “1,2,3”, for example, is an arrangement containing these values in any order. In <code class="docutils literal notranslate"><span class=pre>moptipy</span></code>, the space <code class="docutils literal notranslate"><span class=pre>Permutation</span></code> is defined over any arrangement of a given base string. For example, if a base string is “1,2,2,3”, then any arrangement containing one “1”, two “2”s, and one “3” is then an element of this space. This allows us to represent both normal permutations as well as those with repetitions.</p> <ul><li><p>Nullary Operators:</p> <ul><li><p><a class="reference external"href=./moptipy.operators.permutations.html#moptipy.operators.permutations.op0_shuffle.Op0Shuffle>Fisher-Yates shuffle</a> creates uniformly randomly distributed permutations.</ul><li><p>Unary Operators:</p> <ul><li><p><a class="reference external"href=./moptipy.operators.permutations.html#module-moptipy.operators.permutations.op1_insert1>insert_1</a> removes one element from a permutation and inserts it elsewhere.<li><p><a class="reference external"href=./moptipy.operators.permutations.html#moptipy.operators.permutations.op1_swap2.Op1Swap2>swap 2</a> swaps exactly two (different) values.<li><p><a class="reference external"href=./moptipy.operators.permutations.html#moptipy.operators.permutations.op1_swapn.Op1SwapN>swap n</a> performs a random number of swaps.<li><p><a class="reference external"href=./moptipy.operators.permutations.html#module-moptipy.operators.permutations.op1_swap_exactly_n>swap_exactly_n</a> is a unary operator with step size that will change/swap exactly a given number of elements for permutations where each element occurs once and which will try to swap that many in permutations with repetitions (where it might not be possible to swap exactly the required number of elements).<li><p><a class="reference external"href=./moptipy.operators.permutations.html#module-moptipy.operators.permutations.op1_swap_try_n>swap_try_n</a> is a unary operator very similar to the <code class="docutils literal notranslate"><span class=pre>swap_exactly_n</span></code> operator, but it invests much less effort to achieve the number of prescribed swaps and thus is both much faster but also more likely to perform less swaps.</ul><li><p>Binary Operators:</p> <ul><li><p><a class="reference external"href=./moptipy.operators.permutations.html#moptipy.operators.permutations.op2_gap.Op2GeneralizedAlternatingPosition>generalized alternating position crossover</a> chooses, for each index, from which of the two source permutations the (next not-yet-used) value should be copied<li><p><a class="reference external"href=./moptipy.operators.permutations.html#moptipy.operators.permutations.op2_ox2.Op2OrderBased>order-based crossover</a> randomly selects a set of indices and copies the elements from first source permutation to the same indices in the destination string. It then copies the remaining elements from the second source, maintaining the order in which they appear in the second source string.</ul></ul><li><p><a class="reference external"href=./moptipy.spaces.html#module-moptipy.spaces.signed_permutations>Signed Permutations</a> with and without Repetitions are represented as numpy arrays of integers. They cannot contain the value <code class="docutils literal notranslate"><span class=pre>0</span></code>. All other values may occur either positive or negative, e.g., <code class="docutils literal notranslate"><span class=pre>5</span></code> or <code class="docutils literal notranslate"><span class=pre>-5</span></code>.</p> <ul><li><p>Nullary Operators:</p> <ul><li><p><a class="reference external"href=./moptipy.operators.signed_permutations.html#module-moptipy.operators.signed_permutations.op0_shuffle_and_flip>shuffle-and-flip</a> creates uniformly randomly distributed signed permutations.</ul><li><p>Unary Operators:</p> <ul><li><p><a class="reference external"href=./moptipy.operators.signed_permutations.html#module-moptipy.operators.signed_permutations.op1_swap_2_or_flip>swap 2 or flip</a> either swaps exactly two (different) values or flips the sign of one value.</ul></ul><li><p><a class="reference external"href=./moptipy.spaces.html#module-moptipy.spaces.ordered_choices>Ordered Choices</a> are a hybrid of permutations and combinations. Given are <code class="docutils literal notranslate"><span class=pre>n</span></code> choices, i.e., sets of different values. Each choice could contain any number of different values. Any two choices must either be disjoint or contain the values. Now an element of the space contains one value from each choice and the order matters. So permutations and permutations with repetitions can be represented as ordered choices.</p> <ul><li><p>Nullary Operators:</p> <ul><li><p><a class="reference external"href=./moptipy.operators.ordered_choices.html#module-moptipy.operators.ordered_choices>choose_and_shuffle</a> picks one random value from each choice and shuffles them.</ul></ul><li><p><a class="reference external"href=./moptipy.spaces.html#moptipy.spaces.vectorspace.VectorSpace><code class="docutils literal notranslate"><span class=pre>n</span></code>-dimensional spaces of real numbers</a> are subsets of the <code class="docutils literal notranslate"><span class=pre>n</span></code>-dimensional real numbers. They are <code class="docutils literal notranslate"><span class=pre>numpy</span></code> arrays representing vectors of length <code class="docutils literal notranslate"><span class=pre>n</span></code>. On each dimension, a <a class="reference external"href=./moptipy.spaces.html#moptipy.spaces.vectorspace.VectorSpace.lower_bound>lower</a> and an <a class="reference external"href=./moptipy.spaces.html#moptipy.spaces.vectorspace.VectorSpace.upper_bound>upper bound</a> are imposed.</p> <ul><li><p>Nullary Operators:</p> <ul><li><p><a class="reference external"href=./moptipy.operators.vectors.html#module-moptipy.operators.vectors.op0_uniform>uniform sampling</a> samples a point from the uniform distribution resulting from the lower- and upper bound of the search space.</ul></ul></ul></section><section id=implemented-problems><h3>4.3. Implemented Problems<a title="Link to this heading"class=headerlink href=#implemented-problems>¶</a></h3><p>Within this package, we implement a subset of basic problems that are useful for testing different aspects of the algorithms and spaces we provide. <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> itself is not intended to be a collection of optimization problems, but more a collection of algorithms, spaces, and operators. We do need a set of examples to <a class="reference external"href=#unit-tests-and-static-analysis>unit test</a> these components, so a set of <a class="reference external"href=./moptipy.examples.html#module-moptipy.examples>example problems</a> is indeed provided. More examples and practical applications of <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> can be found in the <a class="reference external"href=./apps><code class="docutils literal notranslate"><span class=pre>moptipyapps</span></code></a> package, which is available on <a class="reference external"href=https://github.com/thomasWeise/moptipyapps>GitHub</a> and in <a class="reference external"href=https://pypi.org/project/moptipyapps><code class="docutils literal notranslate"><span class=pre>PyPi</span></code></a>. The <code class="docutils literal notranslate"><span class=pre>moptipyapps</span></code> package is where we will include future examples and benchmark cases, such as for the Quadratic Assignment Problem (<a class="reference external"href=./apps/#the-quadratic-assignment-problem-qap>QAP</a>), the Traveling Salesperson Problem (<a class="reference external"href=./apps/#the-traveling-salesperson-problem-tsp>TSP</a>), the Traveling Tournament Problem (<a class="reference external"href=./apps/#the-traveling-tournament-problem-ttp>TTP</a>), Two-Dimensional <a class="reference external"href=./apps/#two-dimensional-bin-packing-problem>Bin Packing</a>, or <a class="reference external"href=./apps/#dynamic-controller-synthesis>Dynamic Control</a>.<ul class=simple><li><p><a class="reference external"href=./moptipy.spaces.html#moptipy.spaces.bitstrings.BitStrings>Bit Strings</a> of a fixed length <code class="docutils literal notranslate"><span class=pre>n</span></code>:</p> <ul><li><p>The minimization version of the <a class="reference external"href=./moptipy.examples.bitstrings.html#moptipy.examples.bitstrings.ising1d.Ising1d>1D Ising Model</a>, where the goal is to ensure that all bits have the same values as their neighbors.<li><p>The minimization version of the <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.jump>Jump</a> problem, which is equivalent to OneMax, but has a deceptive region right before the optimum.<li><p>The minimization version of the well-known <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.leadingones>LeadingOnes</a> problem, where the goal is to maximize the length of the trailing substring of all <code class="docutils literal notranslate"><span class=pre>True</span></code> bits.<li><p>The minimization version of the well-known <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.onemax>OneMax</a> problem, where the goal is to maximize the number of <code class="docutils literal notranslate"><span class=pre>True</span></code> bits in a string.<li><p>The minimization version of the <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.trap>Trap</a> problem, which is equivalent of OneMax, but with the optimum and worst-possible solution swapped. This problem is therefore highly deceptive.<li><p>The <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.w_model>W-Model</a>, a problem that exhibits tunable neutrality, epistasis, ruggedness, and deceptiveness.<li><p>The minimization version of the well-known <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.zeromax>ZeroMax</a> problem, which is the exact opposite of OneMax and has the goal to find the bit string of all <code class="docutils literal notranslate"><span class=pre>False</span></code> values.</ul><li><p><a class="reference external"href=./moptipy.spaces.html#moptipy.spaces.permutations.Permutations>Permutations</a> (with and without Repetitions):</p> <ul><li><p>The NP-hard Job Shop Scheduling Problem (<a class="reference external"href=./moptipy.examples.jssp.html#module-moptipy.examples.jssp>JSSP</a>), where the goal is to find an assignment of jobs to machines with the minimum makespan. On <a class="reference external"href=https://thomasweise.github.io/oa_data/>https://thomasweise.github.io/oa_data/</a>, we provide several zip archives with results obtained with <a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> on the JSSP.</ul><li><p><a class="reference external"href=./moptipy.spaces.html#moptipy.spaces.vectorspace.VectorSpace><code class="docutils literal notranslate"><span class=pre>n</span></code>-dimensional spaces of real numbers</a></p> <ul><li><p><a class="reference external"href=./moptipy.examples.vectors.html#module-moptipy.examples.vectors.ackley>Ackley’s Function</a><li><p><a class="reference external"href=./moptipy.examples.vectors.html#module-moptipy.examples.vectors.sphere>Sphere Function</a></ul></ul></section></section><section id=data-formats><h2>5. Data Formats<a title="Link to this heading"class=headerlink href=#data-formats>¶</a></h2><p>We develop several data formats to store and evaluate the results of computational experiments with our <a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> software. Here you can find their basic definitions. On <a class="reference external"href=https://thomasweise.github.io/oa_data/>https://thomasweise.github.io/oa_data/</a>, we provide several zip archives with results obtained with our software. For example, you could download the <a class="reference external"href=https://thomasweise.github.io/oa_data/jssp/jssp_hcr_swapn.tar.xz>results</a> of the <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.hill_climber_with_restarts>hill climber with restarts</a> on the Job Shop Scheduling Problem (<a class="reference external"href=./moptipy.examples.jssp.html#module-moptipy.examples.jssp>JSSP</a>) using the <a class="reference external"href=./moptipy.operators.permutations.html#module-moptipy.operators.permutations.op1_swapn>operator <code class="docutils literal notranslate"><span class=pre>swapn</span></code></a> that swaps a randomly chosen number of (different) job IDs, for different restart settings. The files and folders in this archive will then exactly comply to the structure discussed here.<section id=log-files><h3>5.1. Log Files<a title="Link to this heading"class=headerlink href=#log-files>¶</a></h3><p>The philosophy of our log files is:<ol class="arabic simple"><li><p>One log file per algorithm run. We always store each run of an algorithm into a single, separate file. This has several advantages: If you execute several runs in parallel, there cannot be any problems when writing the log files. If, instead, we would store multiple runs in a single file, then some synchronization is needed if multiple processes work on the runs for the same setup. Each log file and run is also self-contained. If runs are executed in a distributed fashion, then we can store data about the node where the run is executed in the log file. We can also store the results of the runs right in the log files without requiring any special treatment to identify to which run the results belong (because there only is one run they could belong to). And so on.<li><p>Each log file contains all information needed to fully understand the algorithm run, such as</p> <ol class="arabic simple"><li><p>The results in numerical form, e.g., the <a class="reference external"href=#the-section-state>best achieved objective value</a>.<li><p>The result in textual form, e.g., the textual representation of the <a class="reference external"href=#the-result-sections>best solution discovered</a> This allows us to later load, use, or validate the result.<li><p>The <a class="reference external"href=#the-section-setup>random seed</a> used.<li><p>The <a class="reference external"href=#the-section-setup>termination criteria</a> used, i.e., the maximum objective function evaluations or the maximum runtime or the goal objective value.<li><p>The algorithm name and <a class="reference external"href=#the-section-setup>configuration</a>. This allows us to later understand what we did here and to reproduce the algorithm setup.<li><p>The problem instance name and <a class="reference external"href=#the-section-setup>parameters</a>. This makes sure that we know which problem instance did we solve.<li><p>The <a class="reference external"href=#the-section-sys_info>system configuration</a>, such as the CPU nd operating system and Python version and <a class="reference external"href=#the-section-sys_info>library versions</a>. We need to this to understand and reproduce time-dependent measures or to understand situations where changes in the underlying system configuration may have led to different results.<li><p><a class="reference external"href=#the-error-sections>Errors</a>, if any occurred. We can guard against errors using <a class="reference external"href=#unit-tests-and-static-analysis>unit tests</a>, but it may still happen that a run of the optimization algorithm crashed. Our system tries to catch as detailed error information as possible and store it in the log files in order to allow us to figure out what went wrong.<li><p>The <a class="reference external"href=#the-section-progress>progress</a> that the algorithm made over time, if capturing this information <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_log_improvements>was demanded</a>.<li><p>The <a class="reference external"href=#the-archive_j_x-and-archive_j_y-sections>contents of the archive</a> of non-dominated solutions, if we perform <a class="reference external"href=#example-log-file-for-multi-objective-optimization>multi-objective optimization</a>.<li><p>The <a class="reference external"href=#the-archive_qualities-section>objective values</a> of the solutions in the archive of non-dominated solutions, if we perform <a class="reference external"href=#example-log-file-for-multi-objective-optimization>multi-objective optimization</a>.</ol></ol><p>All of this information is stored (almost) automatically. Experiments with <a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> are intended to be self-documenting, such that you can still see what was going on if you open a log file of someone else or one of your log files five years after the experiment. Each log file contains all the information, so you will not end up with a situation where you have a “results file” but cannot find the matching setup information because it was stored elsewhere.<p>By capturing and storing as much information about the setup, configuration, and parameters of each run automatically, we also try to prevent situations where a vital piece of information turns out to be missing some time after the experiment. For example, the library author himself has encountered situations where he still, e.g., had the result of a run but did not store how long it took to get it. And did no longer remember when this information was needed. In such a case we have no choice but to repeat the experiment. Unless our system is clever enough to automatically store such data. <a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> is 😁.<section id=file-names-and-folder-structure><h4>5.1.1. File Names and Folder Structure<a title="Link to this heading"class=headerlink href=#file-names-and-folder-structure>¶</a></h4><p>One independent run of an algorithm on one problem instance produces one log file. Each run is identified by the algorithm that is applied, the problem instance to which it is applied, and the random seed. This tuple is reflected in the file name. <code class="docutils literal notranslate"><span class=pre>rls_swap2_demo_0x5a9363100a272f12.txt</span></code>, for example, represents the algorithm <code class="docutils literal notranslate"><span class=pre>rls_swap2</span></code> applied to the problem instance <code class="docutils literal notranslate"><span class=pre>demo</span></code> and started with random seed <code class="docutils literal notranslate"><span class=pre>0x5a9363100a272f12</span></code> (where <code class="docutils literal notranslate"><span class=pre>0x</span></code> stands for hexademical notation). The log files are grouped in a <code class="docutils literal notranslate"><span class=pre>algorithm</span></code>/<code class="docutils literal notranslate"><span class=pre>instance</span></code> folder structure. In the above example, there would be a folder <code class="docutils literal notranslate"><span class=pre>rls_swap2</span></code> containing a folder <code class="docutils literal notranslate"><span class=pre>demo</span></code>, which, in turn, contains all the log files from all runs of that algorithm on this instance.</section><section id=log-file-sections><h4>5.1.2. Log File Sections<a title="Link to this heading"class=headerlink href=#log-file-sections>¶</a></h4><p>A log file is a simple text file divided into several sections. Each section <code class="docutils literal notranslate"><span class=pre>X</span></code> begins with the line <code class="docutils literal notranslate"><span class=pre>BEGIN_X</span></code> and ends with the line <code class="docutils literal notranslate"><span class=pre>END_X</span></code>. There are three types of sections:<ul class=simple><li><p><em><a class="reference external"href=./moptipy.utils.html#moptipy.utils.logger.CsvLogSection>Semicolon-separated values</a></em> can hold a series of data values, where each row is divided into multiple values and the values are separated by <code class="docutils literal notranslate"><span class=pre>;</span></code>. We use ‘;’, as both ‘.’ and ‘,’ might be misinterpreted as decimal or fractional separaters under different locales, whereas ‘;’, to the best of our knowledge, is rarely used for such purposes. We will still call such sections “CSV” sections (comma-separated-values), though, as most people know what CSV is and the structure basically is exactly that, except that we use ‘;’ instead of ‘,’.<li><p><em><a class="reference external"href=./moptipy.utils.html#moptipy.utils.logger.KeyValueLogSection>Key-values</a></em> sections represent, well, values for keys in form of a mapping compatible with <a class="reference external"href=https://yaml.org/spec/1.2.2/#mapping>YAML</a>. In other words, each line contains a key, followed by <code class="docutils literal notranslate"><span class=pre>:</span> </code>, followed by the value. The keys can be hierarchically structured in scopes, for example <code class="docutils literal notranslate"><span class=pre>a.b</span></code> and <code class="docutils literal notranslate"><span class=pre>a.c</span></code> indicate two keys <code class="docutils literal notranslate"><span class=pre>b</span></code> and <code class="docutils literal notranslate"><span class=pre>c</span></code> that belong to scope <code class="docutils literal notranslate"><span class=pre>a</span></code>. This allows representing complex data such as <a class="reference external"href=#the-section-setup>configuration parameters</a> in a rather straight-forward, easy-to-parse canonical way. All keys within a section must be unique, i.e., if a section contains a value under key <code class="docutils literal notranslate"><span class=pre>a.a</span></code>, it cannot contain the same key <code class="docutils literal notranslate"><span class=pre>a.a</span></code> again, even with the same value.<li><p><em><a class="reference external"href=./moptipy.utils.html#moptipy.utils.logger.TextLogSection>Raw text</a></em> sections contain text without a general or a priori structure, e.g., the string representation of the best solutions found. Obviously, such raw text cannot contain things such as section delimiters or other reserved keywords. Apart from that, basically any type of data may be stored there. This is useful for, for instance, storing the <a class="reference external"href=#the-result-sections>final solutions</a> of runs or <a class="reference external"href=#the-error-sections>exceptions caught during the runs</a>.</ul><p>In all the above sections, the character <code class="docutils literal notranslate"><span class=pre>#</span></code> is removed from output. The character <code class="docutils literal notranslate"><span class=pre>#</span></code> indicates a starting comment and can only be written by the routines dedicated to produce comments.<section id=the-section-progress><h5>5.1.2.1 The Section <code class="docutils literal notranslate"><span class=pre>PROGRESS</span></code><a title="Link to this heading"class=headerlink href=#the-section-progress>¶</a></h5><p>When setting up an algorithm execution, you can specify whether or not you want to <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_log_improvements>log the progress</a> of the algorithm. If and only if you choose to log the progress, the <code class="docutils literal notranslate"><span class=pre>PROGRESS</span></code> section will be contained in the log file. Notice that this section can be long if the algorithm makes many improvements. You can also choose if you want to <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_log_all_fes>log all algorithm steps</a> or <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_log_improvements>only the improving moves</a>, the latter being the default behavior. If you really log all algorithm steps, then your log files will contain one line for every objective function evaluation (FE) you perform. It can thus become quite large. In our Job Shop Scheduling example in the <a class="reference external"href=https://thomasweise.github.io/oa>Optimization Algorithms</a> book, for example, we can do several million FEs within the two minutes of runtime granted to each run. This then would equate to several millions of lines in the <code class="docutils literal notranslate"><span class=pre>PROGRESS</span></code> section of each log file. So normally you would rather only log the improving moves, which would often be between a few ten to a few thousand of lines, which is usually acceptable. Notice that even if you do not choose to log the algorithm’s progress at all, the <a class="reference external"href=#the-section-state>section <code class="docutils literal notranslate"><span class=pre>STATE</span></code></a> with the objective value of the best solution encountered, the FE when it was found, and the consumed runtime, as well as the <a class="reference external"href=#the-result-sections><code class="docutils literal notranslate"><span class=pre>RESULT_*</span></code> sections</a> with the best encountered candidate solution and point in the search space, and also the <a class="reference external"href=#the-section-setup><code class="docutils literal notranslate"><span class=pre>SETUP</span></code></a> and <a class="reference external"href=#the-section-sys_info><code class="docutils literal notranslate"><span class=pre>SYS_INFO</span></code></a> still will be included in the log files.<p>The <code class="docutils literal notranslate"><span class=pre>PROGRESS</span></code> section contains log points describing the algorithm progress over time in a semicolon-separated values format with one data point per line. It has an internal header describing the data columns. There will at least be the following columns:<ol class="arabic simple"><li><p><code class="docutils literal notranslate"><span class=pre>fes</span></code> denoting the integer number of performed objective value evaluations<li><p><code class="docutils literal notranslate"><span class=pre>timeMS</span></code> the clock time that has passed since the start of the run, measured in milliseconds and stored as integer value. Python actually provides the system clock time in terms of nanoseconds, however, we always round up to the next highest millisecond. We believe that milliseconds are a more reasonable time measure here and a higher resolution is probably not helpful anyway. Due to the upwards-rounding, the lowest possible time at which a log point can occur is at <code class="docutils literal notranslate"><span class=pre>1</span></code> millisecond.<li><p><code class="docutils literal notranslate"><span class=pre>f</span></code> the best-so-far objective value, if only improving moves are logged, or the current objective value, if all moves are logged.</ol><p>This configuration is denoted by the header <code class="docutils literal notranslate"><span class=pre>fes;timeMS;f</span></code>. After this header and until <code class="docutils literal notranslate"><span class=pre>END_PROGRESS</span></code>, each line will contain one data point with values for the specified columns.<p>If you perform multi-objective optimization, then one additional column will be added for each objective function. The column header will be <code class="docutils literal notranslate"><span class=pre>fi</span></code> with <code class="docutils literal notranslate"><span class=pre>i</span></code> being the zero-based index of the (<code class="docutils literal notranslate"><span class=pre>i+1</span></code>th) objective function. <code class="docutils literal notranslate"><span class=pre>f</span></code> then stands for the <a class="reference external"href=./moptipy.api.html#moptipy.api.mo_problem.MOProblem.evaluate>scalarized</a> version of the objective values.<p>You can copy the contents of this section together with the header into calculation software such as Microsoft Excel or LibreOffice Calc and choose <code class="docutils literal notranslate"><span class=pre>;</span></code> as separator when applying the text-to-column feature. This way, you can directly work on the raw data if you want.<p>Notice that for each FE, there will be at most one data point but there might be multiple data points per millisecond. This is especially true if we log all FEs. Usually, we would log one data point for every improvement of the objective value, though.</section><section id=the-section-state><h5>5.1.2.2 The Section <code class="docutils literal notranslate"><span class=pre>STATE</span></code><a title="Link to this heading"class=headerlink href=#the-section-state>¶</a></h5><p>The end state when the run terminates is logged in the section <code class="docutils literal notranslate"><span class=pre>STATE</span></code> in a <a class="reference external"href=https://yaml.org/spec/1.2.2/#mapping>YAML</a>-compatible key-value format. It holds at least the following keys:<ul class=simple><li><p><code class="docutils literal notranslate"><span class=pre>totalFEs</span></code> the total number of objective function evaluations performed, as integer<li><p><code class="docutils literal notranslate"><span class=pre>totalTimeMillis</span></code> the total number of clock time milliseconds elapsed since the begin of the run, as integer<li><p><code class="docutils literal notranslate"><span class=pre>bestF</span></code> the best objective function value encountered during the run<li><p><code class="docutils literal notranslate"><span class=pre>lastImprovementFE</span></code> the index of the last objective function evaluation where the objective value improved, as integer<li><p><code class="docutils literal notranslate"><span class=pre>lastImprovementTimeMillis</span></code> the time in milliseconds at which the last objective function value improvement was registered, as integer</ul><p>In case that multi-objective optimization is performed, please note the following things:<ul class=simple><li><p><code class="docutils literal notranslate"><span class=pre>bestF</span></code> then corresponds to the best <a class="reference external"href=./moptipy.api.html#moptipy.api.mo_problem.MOProblem.evaluate>scalarization</a> result, i.e., the best value achieved by the scalarization of the objective value vector during the search,<li><p><code class="docutils literal notranslate"><span class=pre>bestFs</span></code>, the vector of objective values corresponding to the solution obtaining <code class="docutils literal notranslate"><span class=pre>bestF</span></code>, is also provided (values are semicolon-separated),<li><p><code class="docutils literal notranslate"><span class=pre>archiveSize</span></code> is the number of non-dominated solutions collected in the archive, and<li><p>the values of <code class="docutils literal notranslate"><span class=pre>lastImprovementFE</span></code> and <code class="docutils literal notranslate"><span class=pre>lastImprovementTimeMillis</span></code> may not be reliable anymore: Whenever a solution enters the archive or the best scalarization is improved, this is recorded as improvement. However, since the archive size is always limited and the archive may be pruned due when it reaches its maximum size, it could be that a solution enters the archive which is actually not non-dominated with respect to the whole search but only with respect to the current archive. In other words, <code class="docutils literal notranslate"><span class=pre>lastImprovementFE</span></code> and <code class="docutils literal notranslate"><span class=pre>lastImprovementTimeMillis</span></code> may represent a move that is actually not an absolute improvement.</ul></section><section id=the-section-setup><h5>5.1.2.3 The Section <code class="docutils literal notranslate"><span class=pre>SETUP</span></code><a title="Link to this heading"class=headerlink href=#the-section-setup>¶</a></h5><p>In this <a class="reference external"href=https://yaml.org/spec/1.2.2/#mapping>YAML</a>-compatible key-value section, we log information about the configuration of the optimization algorithm as well as the parameters of the problem instance solved. There are at least the following keys:<ul class=simple><li><p><a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process>process</a> wrapper parameters (scope <code class="docutils literal notranslate"><span class=pre>p</span></code>):</p> <ul><li><p><code class="docutils literal notranslate"><span class=pre>p.name</span></code>: the name of the process wrapper, i.e., a short mnemonic describing its purpose<li><p><code class="docutils literal notranslate"><span class=pre>p.class</span></code>: the python class of the process wrapper<li><p><code class="docutils literal notranslate"><span class=pre>p.maxTimeMillis</span></code>: the maximum clock time in milliseconds, if specified<li><p><code class="docutils literal notranslate"><span class=pre>p.maxFEs</span></code>: the maximum number of objective function evaluations (FEs), if specified<li><p><code class="docutils literal notranslate"><span class=pre>p.goalF</span></code>: the goal objective value, if specified (or computed via the <code class="docutils literal notranslate"><span class=pre>lower_bound()</span></code> of the <a class="reference external"href=./moptipy.api.html#moptipy.api.objective.Objective>objective function</a>)<li><p><code class="docutils literal notranslate"><span class=pre>p.randSeed</span></code>: the random seed (a 64bit unsigned integer) in decimal notation<li><p><code class="docutils literal notranslate"><span class=pre>p.randSeed(hex)</span></code>: the random seed in hexadecimal notation<li><p><code class="docutils literal notranslate"><span class=pre>p.randGenType</span></code>: the class of the random number generator<li><p><code class="docutils literal notranslate"><span class=pre>p.randBitGenType</span></code>: the class of the bit generator used by the random number generator<li><p><code class="docutils literal notranslate"><span class=pre>p.lowerBound</span></code> the lower bound of the (scalarized) objective values that this process can produce (if finite)<li><p><code class="docutils literal notranslate"><span class=pre>p.upperBound</span></code> the upper bound of the (scalarized) objective values that this process can produce (if finite) If multi-objective optimization is performed, the following parameters are added:<li><p><code class="docutils literal notranslate"><span class=pre>p.archiveMaxSize</span></code>: the maximum size of the archive of non-dominated solutions after pruning<li><p><code class="docutils literal notranslate"><span class=pre>p.archivePruneLimit</span></code>: the archive size limit above which pruning will be triggered.</ul><li><p><a class="reference external"href=./moptipy.api.html#moptipy.api.algorithm.Algorithm>algorithm</a> parameters: scope <code class="docutils literal notranslate"><span class=pre>a</span></code>, includes algorithm <code class="docutils literal notranslate"><span class=pre>name</span></code>, <code class="docutils literal notranslate"><span class=pre>class</span></code>, etc.<li><p>solution <a class="reference external"href=./moptipy.api.html#moptipy.api.space.Space>space</a> scope <code class="docutils literal notranslate"><span class=pre>y</span></code>, includes <code class="docutils literal notranslate"><span class=pre>name</span></code> and <code class="docutils literal notranslate"><span class=pre>class</span></code> of solution space<li><p><a class="reference external"href=./moptipy.api.html#moptipy.api.objective.Objective>objective function</a> information: scope <code class="docutils literal notranslate"><span class=pre>f</span></code>. If multi-objective optimization is performed, this is the scope of the <a class="reference external"href=./moptipy.api.html#moptipy.api.mo_problem.MOProblem>multi-objective problem</a>. There will be a sub-scope <code class="docutils literal notranslate"><span class=pre>f.fi</span></code> for the <code class="docutils literal notranslate"><span class=pre>i</span></code>th objective function (<code class="docutils literal notranslate"><span class=pre>i</span></code> starts at <code class="docutils literal notranslate"><span class=pre>0</span></code>).<li><p>search <a class="reference external"href=./moptipy.api.html#moptipy.api.space.Space>space</a> information (if search space is different from solution space): scope <code class="docutils literal notranslate"><span class=pre>x</span></code><li><p><a class="reference external"href=./moptipy.api.html#moptipy.api.encoding.Encoding>encoding</a> information (if encoding is defined): scope <code class="docutils literal notranslate"><span class=pre>g</span></code><li><p><a class="reference external"href=./moptipy.api.html#moptipy.api.mo_archive.MOArchivePruner>archive pruner</a> information (in case of multi-objective optimization): scope <code class="docutils literal notranslate"><span class=pre>ap</span></code>.</ul><p>If you implement an own <a class="reference external"href=./moptipy.api.html#moptipy.api.algorithm.Algorithm>algorithm</a>, <a class="reference external"href=./moptipy.api.html#moptipy.api.objective.Objective>objective function</a>, <a class="reference external"href=./moptipy.api.html#moptipy.api.space.Space>space</a>, or your own <a class="reference external"href=./moptipy.api.html#module-moptipy.api.operators>search operators</a>, then you can overwrite the method <a class="reference external"href=./moptipy.api.html#moptipy.api.component.Component.log_parameters_to><code class="docutils literal notranslate"><span class=pre>log_parameters_to(logger)</span></code></a>. This method will automatically be invoked when writing the log files of a run. It should <em>always</em> start with calling the super implementation (<code class="docutils literal notranslate"><span class=pre>super().log_parameters_to(logger)</span></code>). After that, you can store key-value pairs describing the parameterization of your component. This way, such information can be preserved in log files.<p>We strongly suggest to always do that if you define your own components. It is a very easy way to make sure that your results are reproducible, easy-to-understand, and self-documenting.</section><section id=the-section-sys-info><h5>5.1.2.4 The Section <code class="docutils literal notranslate"><span class=pre>SYS_INFO</span></code><a title="Link to this heading"class=headerlink href=#the-section-sys-info>¶</a></h5><p>The system information section is again a key-value section. It holds key-value pairs describing features of the machine on which the experiment was executed. This includes information about the CPU, the operating system, the Python installation, as well as the version information of packages used by moptipy. If your <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> application uses additional Python libraries, then it is strongly suggested to also include their versions in the log files. This can be done by invoking the function <a class="reference external"href=./moptipy.utils.html#moptipy.utils.sys_info.add_dependency><code class="docutils literal notranslate"><span class=pre>add_dependency</span></code></a> <strong>before</strong> running any experiment. This way, you can add the name of a library that your application depends on. The system will then automatically get the version information of that library and include it into the log files.</section><section id=the-result-sections><h5>5.1.2.5 The <code class="docutils literal notranslate"><span class=pre>RESULT</span></code> Sections<a title="Link to this heading"class=headerlink href=#the-result-sections>¶</a></h5><p>The textual representation of the best encountered solution (whose objective value is noted as <code class="docutils literal notranslate"><span class=pre>bestF</span></code> in section <code class="docutils literal notranslate"><span class=pre>STATE</span></code>) is stored in the section <code class="docutils literal notranslate"><span class=pre>RESULT_Y</span></code>. Since we can use many different solution spaces, this section just contains raw text.<p>If the search and solution space are different, the section <code class="docutils literal notranslate"><span class=pre>RESULT_X</span></code> is included. It then holds the point in the search space corresponding to the solution presented in <code class="docutils literal notranslate"><span class=pre>RESULT_Y</span></code>.<p>Both sections are plain texts, the results of the <a class="reference external"href=./moptipy.api.html#moptipy.api.space.Space.to_str><code class="docutils literal notranslate"><span class=pre>to_str</span></code></a> method of the corresponding <a class="reference external"href=./moptipy.api.html#moptipy.api.space.Space><code class="docutils literal notranslate"><span class=pre>Space</span></code></a> instances for the search and solution spaces. It is therefore possible to design suitable text representations for arbitrary solution data structures and have them properly stored in the log files.</section><section id=the-error-sections><h5>5.1.2.6 The <code class="docutils literal notranslate"><span class=pre>ERROR</span></code> Sections<a title="Link to this heading"class=headerlink href=#the-error-sections>¶</a></h5><p>Our package has mechanisms to catch and store errors that occurred during the experiments. Each type of error will be stored in a separate log section and each such sections may store the class of the error in form <code class="docutils literal notranslate"><span class=pre>exceptionType:</span> <span class=pre>error-class</span></code>, the error message in the form <code class="docutils literal notranslate"><span class=pre>exceptionValue:</span> <span class=pre>error-message</span></code> and the stack trace line by line after a line header <code class="docutils literal notranslate"><span class=pre>exceptionStackTrace:</span></code>. The following exception sections are currently supported:<ul class=simple><li><p>If an exception is encountered during the algorithm run, it will be store in section <code class="docutils literal notranslate"><span class=pre>ERROR_IN_RUN</span></code>.<li><p>If an exception occurred in the context of the optimization process, it will be stored in <code class="docutils literal notranslate"><span class=pre>ERROR_IN_CONTEXT</span></code>. This may be an error during the execution of the algorithm, or, more likely, an error in the code that accesses the process data afterwards, e.g., that processes the best solution encountered.<li><p>If the validation of the finally returned candidate solution failed, the resulting error will be stored in section <code class="docutils literal notranslate"><span class=pre>ERROR_INVALID_Y</span></code>.<li><p>If the internally remembered best objective value does not match to the objective value of the internally remembered best solution after re-evaluating it at the end, the corresponding information will be stored in section <code class="docutils literal notranslate"><span class=pre>ERROR_BEST_F_MISMATCH</span></code>.<li><p>If the validation of the finally returned point in the search space failed, the resulting error will be stored in section <code class="docutils literal notranslate"><span class=pre>ERROR_INVALID_X</span></code>.<li><p>If an inconsistency in the time measurement is discovered, this will result in the section <code class="docutils literal notranslate"><span class=pre>ERROR_TIMING</span></code>. Such an error may be caused when the computer clock is adjusted during the run of an optimization algorithm. It will also occur if an algorithm terminates without performing even a single objective function evaluation.<li><p>In the unlikely case that an exception occurs during the writing of the log but writing can somehow continue, this exception will be stored in section <code class="docutils literal notranslate"><span class=pre>ERROR_IN_LOG</span></code>.</ul></section><section id=the-archive-qualities-section><h5>5.1.2.7 The <code class="docutils literal notranslate"><span class=pre>ARCHIVE_QUALITIES</span></code> Section<a title="Link to this heading"class=headerlink href=#the-archive-qualities-section>¶</a></h5><p>If multi-objective optimization is performed, the <code class="docutils literal notranslate"><span class=pre>process</span></code> object will automatically collect an archive of non-dominated solutions. In the CSV-formatted section <code class="docutils literal notranslate"><span class=pre>ARCHIVE_QUALITIES</span></code> of the log files, we will find one row per non-dominated solution in the archive. The first number in the row is the scalarized overall solution quality <code class="docutils literal notranslate"><span class=pre>f</span></code>, followed by the value <code class="docutils literal notranslate"><span class=pre>fi</span></code> of the <code class="docutils literal notranslate"><span class=pre>i</span></code>th objective function (<code class="docutils literal notranslate"><span class=pre>i</span></code> starts at <code class="docutils literal notranslate"><span class=pre>0</span></code>). The solutions corresponding to row <code class="docutils literal notranslate"><span class=pre>j</span></code> of this section appear in the <code class="docutils literal notranslate"><span class=pre>ARCHIVE_j_X</span></code> and <code class="docutils literal notranslate"><span class=pre>ARCHIVE_j_Y</span></code> sections (<code class="docutils literal notranslate"><span class=pre>j</span></code> starts at <code class="docutils literal notranslate"><span class=pre>0</span></code>).</section><section id=the-archive-j-x-and-archive-j-y-sections><h5>5.1.2.8 The <code class="docutils literal notranslate"><span class=pre>ARCHIVE_j_X</span></code> and <code class="docutils literal notranslate"><span class=pre>ARCHIVE_j_Y</span></code> Sections<a title="Link to this heading"class=headerlink href=#the-archive-j-x-and-archive-j-y-sections>¶</a></h5><p>In multi-objective optimization, the <code class="docutils literal notranslate"><span class=pre>process</span></code> object will automatically collect an archive of non-dominated solutions. The sections <code class="docutils literal notranslate"><span class=pre>ARCHIVE_j_X</span></code> contains the point in the search space and <code class="docutils literal notranslate"><span class=pre>ARCHIVE_j_Y</span></code> the point in the solution space corresponding to the <code class="docutils literal notranslate"><span class=pre>j</span></code>th element of the archive. The sections are plain texts, the results of the <a class="reference external"href=./moptipy.api.html#moptipy.api.space.Space.to_str><code class="docutils literal notranslate"><span class=pre>to_str</span></code></a> method of the corresponding <a class="reference external"href=./moptipy.api.html#moptipy.api.space.Space><code class="docutils literal notranslate"><span class=pre>Space</span></code></a> instances for the search and solution spaces.</section></section><section id=example-for-single-objective-optimization><h4>5.1.3. Example for Single-Objective Optimization<a title="Link to this heading"class=headerlink href=#example-for-single-objective-optimization>¶</a></h4><p>You can execute the following Python code to obtain an example log file. This code is also available in file <a class="reference external"href=./examples/log_file_jssp_py.html>examples/log_file_jssp.py</a>:<div class="highlight-python notranslate"><div class=highlight><pre><span></span><span class=kn>from</span><span class=w> </span><span class=nn>moptipy.algorithms.so.rls</span><span class=w> </span><span class=kn>import</span> <span class=n>RLS</span>  <span class=c1># the algorithm we use</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.jssp.experiment</span><span class=w> </span><span class=kn>import</span> <span class=n>run_experiment</span>  <span class=c1># the runner</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.permutations.op0_shuffle</span><span class=w> </span><span class=kn>import</span> <span class=n>Op0Shuffle</span>  <span class=c1># 0-ary op</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.permutations.op1_swap2</span><span class=w> </span><span class=kn>import</span> <span class=n>Op1Swap2</span>  <span class=c1># 1-ary op</span>
<span class=kn>from</span><span class=w> </span><span class=nn>pycommons.io.temp</span><span class=w> </span><span class=kn>import</span> <span class=n>temp_dir</span>  <span class=c1># temp directory tool</span>

<span class=c1># We work in a temporary directory, i.e., delete all generated files on exit.</span>
<span class=c1># For a real experiment, you would put an existing directory path in `td`</span>
<span class=c1># by doing `from pycommons.io.path import Path; td = directory_path("mydir")`</span>
<span class=c1># and not use the `with` block.</span>
<span class=k>with</span> <span class=n>temp_dir</span><span class=p>()</span> <span class=k>as</span> <span class=n>td</span><span class=p>:</span>  <span class=c1># create temp directory</span>
    <span class=c1># Execute an experiment consisting of exactly one run.</span>
    <span class=c1># As example domain, we use the job shop scheduling problem (JSSP).</span>
    <span class=n>run_experiment</span><span class=p>(</span>
        <span class=n>base_dir</span><span class=o>=</span><span class=n>td</span><span class=p>,</span>  <span class=c1># working directory = temporary directory</span>
        <span class=n>algorithms</span><span class=o>=</span><span class=p>[</span>  <span class=c1># the set of algorithms to use: we use only 1</span>
            <span class=c1># an algorithm is created via a lambda</span>
            <span class=k>lambda</span> <span class=n>_</span><span class=p>,</span> <span class=n>pwr</span><span class=p>:</span> <span class=n>RLS</span><span class=p>(</span><span class=n>Op0Shuffle</span><span class=p>(</span><span class=n>pwr</span><span class=p>),</span> <span class=n>Op1Swap2</span><span class=p>())],</span>
        <span class=n>instances</span><span class=o>=</span><span class=p>(</span><span class=s2>"demo"</span><span class=p>,),</span>  <span class=c1># use the demo JSSP instance</span>
        <span class=n>n_runs</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># perform exactly one run</span>
    <span class=c1># The random seed is automatically generated based on the instance name.</span>
    <span class=nb>print</span><span class=p>(</span><span class=n>td</span><span class=o>.</span><span class=n>resolve_inside</span><span class=p>(</span>  <span class=c1># so we know algorithm, instance, and seed</span>
        <span class=s2>"rls_swap2/demo/rls_swap2_demo_0x5a9363100a272f12.txt"</span><span class=p>)</span>
          <span class=o>.</span><span class=n>read_all_str</span><span class=p>())</span>  <span class=c1># read file into string (which then gets printed)</span>
<span class=c1># When leaving "while", the temp directory will be deleted</span>
</pre></div></div><p>The example log file printed by the above code will then look something like this:<div class="highlight-text notranslate"><div class=highlight><pre><span></span>BEGIN_PROGRESS
fes;timeMS;f
1;1;267
5;1;235
10;1;230
20;1;227
25;1;205
40;1;200
84;2;180
END_PROGRESS
BEGIN_STATE
totalFEs: 84
totalTimeMillis: 2
bestF: 180
lastImprovementFE: 84
lastImprovementTimeMillis: 2
END_STATE
BEGIN_SETUP
p.name: LoggingProcessWithSearchSpace
p.class: moptipy.api._process_ss_log._ProcessSSLog
p.maxTimeMillis: 120000
p.goalF: 180
p.randSeed: 6526669205530947346
p.randSeed(hex): 0x5a9363100a272f12
p.randGenType: numpy.random._generator.Generator
p.randBitGenType: numpy.random._pcg64.PCG64
a.name: rls_swap2
a.class: moptipy.algorithms.rls.RLS
a.op0.name: shuffle
a.op0.class: moptipy.operators.permutations.op0_shuffle.Op0Shuffle
a.op1.name: swap2
a.op1.class: moptipy.operators.permutations.op1_swap2.Op1Swap2
y.name: gantt_demo
y.class: moptipy.examples.jssp.gantt_space.GanttSpace
y.shape: (5, 4, 3)
y.dtype: h
y.inst.name: demo
y.inst.class: moptipy.examples.jssp.instance.Instance
y.inst.machines: 5
y.inst.jobs: 4
y.inst.makespanLowerBound: 180
y.inst.makespanUpperBound: 482
y.inst.dtype: b
f.name: makespan
f.class: moptipy.examples.jssp.makespan.Makespan
x.name: perm4w5r
x.class: moptipy.spaces.permutations.Permutations
x.nvars: 20
x.dtype: b
x.min: 0
x.max: 3
x.repetitions: 5
g.name: operation_based_encoding
g.class: moptipy.examples.jssp.ob_encoding.OperationBasedEncoding
g.dtypeMachineIdx: b
g.dtypeJobIdx: b
g.dtypeJobTime: h
END_SETUP
BEGIN_SYS_INFO
session.start: 2022-05-03 08:49:14.883057+00:00
session.node: home
session.procesId: 0xc4b9
session.cpuAffinity: 0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15
session.ipAddress: 192.168.1.105
version.moptipy: 0.8.5
version.numpy: 1.21.5
version.numba: 0.55.1
version.matplotlib: 3.5.1
version.psutil: 5.9.0
hardware.machine: x86_64
hardware.nPhysicalCpus: 8
hardware.nLogicalCpus: 16
hardware.cpuMhz: (2200MHz..3700MHz)*16
hardware.byteOrder: little
hardware.cpu: AMD Ryzen 7 2700X Eight-Core Processor
hardware.memSize: 16719478784
python.version: 3.10.4 (main, Apr  2 2022, 09:04:19) [GCC 11.2.0]
python.implementation: CPython
os.name: Linux
os.release: 5.15.0-27-generic
os.version: 28-Ubuntu SMP Thu Apr 14 04:55:28 UTC 2022
END_SYS_INFO
BEGIN_RESULT_Y
1;20;30;0;30;40;3;145;165;2;170;180;1;0;20;0;40;60;2;60;80;3;165;180;2;0;30;0;60;80;1;80;130;3;130;145;1;30;60;3;60;90;0;90;130;2;130;170;3;0;50;2;80;92;1;130;160;0;160;170
END_RESULT_Y
BEGIN_RESULT_X
2;1;3;1;0;0;2;0;1;2;3;1;0;2;1;3;0;3;2;3
END_RESULT_X
</pre></div></div></section><section id=example-log-file-for-multi-objective-optimization><h4>5.1.4. Example Log File for Multi-Objective Optimization<a title="Link to this heading"class=headerlink href=#example-log-file-for-multi-objective-optimization>¶</a></h4><p>You can execute the following Python code to obtain an example log file for <a class="reference external"href=./moptipy.api.html#module-moptipy.api.mo_problem>multi-objective optimization</a>. Under <code class="docutils literal notranslate"><span class=pre>moptipy</span></code>, every multi-objective problem also specifies a default scalarization, making it and its log files compatible with single-objective optimization. The optimization algorithms can, however, perform Pareto optimization, which is fully respected and whose archive of non-dominated solutions are stored in the log files. This code is also available in file <a class="reference external"href=./examples/mo_example_nsga2_bits_py.html>examples/mo_example_nsga2_bits.py</a>:<div class="highlight-python notranslate"><div class=highlight><pre><span></span><span class=kn>from</span><span class=w> </span><span class=nn>moptipy.algorithms.mo.nsga2</span><span class=w> </span><span class=kn>import</span> <span class=n>NSGA2</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.api.mo_execution</span><span class=w> </span><span class=kn>import</span> <span class=n>MOExecution</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.bitstrings.leadingones</span><span class=w> </span><span class=kn>import</span> <span class=n>LeadingOnes</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.bitstrings.zeromax</span><span class=w> </span><span class=kn>import</span> <span class=n>ZeroMax</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.mo.problem.weighted_sum</span><span class=w> </span><span class=kn>import</span> <span class=n>WeightedSum</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.bitstrings.op0_random</span><span class=w> </span><span class=kn>import</span> <span class=n>Op0Random</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.bitstrings.op1_flip1</span><span class=w> </span><span class=kn>import</span> <span class=n>Op1Flip1</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.bitstrings.op2_uniform</span><span class=w> </span><span class=kn>import</span> <span class=n>Op2Uniform</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.spaces.bitstrings</span><span class=w> </span><span class=kn>import</span> <span class=n>BitStrings</span>
<span class=kn>from</span><span class=w> </span><span class=nn>pycommons.io.temp</span><span class=w> </span><span class=kn>import</span> <span class=n>temp_file</span>

<span class=n>solution_space</span> <span class=o>=</span> <span class=n>BitStrings</span><span class=p>(</span><span class=mi>16</span><span class=p>)</span>  <span class=c1># We search a bit string of length 16,</span>
<span class=n>f1</span> <span class=o>=</span> <span class=n>ZeroMax</span><span class=p>(</span><span class=mi>16</span><span class=p>)</span>                 <span class=c1># that has as many 0s in it as possible</span>
<span class=n>f2</span> <span class=o>=</span> <span class=n>LeadingOnes</span><span class=p>(</span><span class=mi>16</span><span class=p>)</span>             <span class=c1># and the longest leading sequence of 1s.</span>
<span class=c1># These are, of course, two conflicting goals.</span>
<span class=c1># Each multi-objective optimization problem is defined by several objective</span>
<span class=c1># functions *and* a way to scalarize the vector of objective values.</span>
<span class=c1># The scalarization is only used by the system to decide for one single best</span>
<span class=c1># solution in the end *and* if we actually apply a single-objective algorithm</span>
<span class=c1># to the problem instead of a multi-objective one. (Here we will apply a</span>
<span class=c1># multi-objective algorithm, though.)</span>
<span class=c1># Here, we decide for a weighted sum scalarization, weighting the number of</span>
<span class=c1># zeros half as much as the number of leading ones.</span>
<span class=n>problem</span> <span class=o>=</span> <span class=n>WeightedSum</span><span class=p>([</span><span class=n>f1</span><span class=p>,</span> <span class=n>f2</span><span class=p>],</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>])</span>

<span class=c1># NSGA-II is the most well-known multi-objective optimization algorithm.</span>
<span class=c1># It works directly on the multiple objectives. It does not require the</span>
<span class=c1># scalarization above at all. The scalarization is _only_ used internally in</span>
<span class=c1># the `Process` objects to ensure compatibility with single-objective</span>
<span class=c1># optimization and for being able to remember a single "best" solution.</span>
<span class=n>algorithm</span> <span class=o>=</span> <span class=n>NSGA2</span><span class=p>(</span>  <span class=c1># Create the NSGA-II algorithm.</span>
    <span class=n>Op0Random</span><span class=p>(),</span>    <span class=c1># start with a random bit string and</span>
    <span class=n>Op1Flip1</span><span class=p>(),</span>     <span class=c1># flips single bits as mutation</span>
    <span class=n>Op2Uniform</span><span class=p>(),</span>   <span class=c1># performs uniform crossover</span>
    <span class=mi>10</span><span class=p>,</span> <span class=mf>0.05</span><span class=p>)</span>  <span class=c1># population size = 10, crossover rate = 0.05</span>

<span class=c1># We work with a temporary log file which is automatically deleted after this</span>
<span class=c1># experiment. For a real experiment, you would not use the `with` block and</span>
<span class=c1># instead put the path to the file that you want to create into `tf` by doing</span>
<span class=c1># `from pycommons.io.path import Path; tf = Path("mydir/my_file.txt")`.</span>
<span class=k>with</span> <span class=n>temp_file</span><span class=p>()</span> <span class=k>as</span> <span class=n>tf</span><span class=p>:</span>  <span class=c1># create temporary file `tf`</span>
    <span class=n>ex</span> <span class=o>=</span> <span class=n>MOExecution</span><span class=p>()</span>  <span class=c1># begin configuring execution</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_solution_space</span><span class=p>(</span><span class=n>solution_space</span><span class=p>)</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_objective</span><span class=p>(</span><span class=n>problem</span><span class=p>)</span>      <span class=c1># set the multi-objective problem</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_algorithm</span><span class=p>(</span><span class=n>algorithm</span><span class=p>)</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_rand_seed</span><span class=p>(</span><span class=mi>200</span><span class=p>)</span>          <span class=c1># set random seed to 200</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_log_improvements</span><span class=p>(</span><span class=kc>True</span><span class=p>)</span>  <span class=c1># log all improving moves</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_log_file</span><span class=p>(</span><span class=n>tf</span><span class=p>)</span>            <span class=c1># set log file = temp file `tf`</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_max_fes</span><span class=p>(</span><span class=mi>300</span><span class=p>)</span>            <span class=c1># allow at most 300 function evaluations</span>
    <span class=k>with</span> <span class=n>ex</span><span class=o>.</span><span class=n>execute</span><span class=p>():</span>             <span class=c1># now run the algorithm*problem combination</span>
        <span class=k>pass</span>

    <span class=nb>print</span><span class=p>(</span><span class=s2>"</span><span class=se>\n</span><span class=s2>Now reading and printing all the logged data:"</span><span class=p>)</span>
    <span class=nb>print</span><span class=p>(</span><span class=n>tf</span><span class=o>.</span><span class=n>read_all_str</span><span class=p>())</span>  <span class=c1># instead, we load and print the log file</span>
<span class=c1># The temp file is deleted as soon as we leave the `with` block.</span>
</pre></div></div><p>The example log file printed by the above code will then look something like this:<div class="highlight-text notranslate"><div class=highlight><pre><span></span>BEGIN_PROGRESS
fes;timeMS;f;f0;f1
1;1;36;6;15
6;1;37;9;14
7;1;37;5;16
8;1;36;10;13
13;2;36;8;14
14;2;35;3;16
19;2;35;7;14
21;2;35;5;15
22;2;35;9;13
27;3;34;6;14
31;3;34;8;13
33;3;32;10;11
42;4;33;7;13
46;4;34;2;16
50;4;27;11;8
57;5;31;9;11
64;6;32;6;13
67;6;33;3;15
72;6;31;5;13
75;6;33;1;16
77;6;32;8;12
78;7;32;4;14
79;7;24;12;6
82;7;23;11;6
84;7;32;0;16
88;7;30;8;11
91;8;30;4;13
93;8;31;3;14
101;9;30;10;10
112;9;26;10;8
114;10;32;2;15
118;10;24;10;7
126;10;29;7;11
131;11;22;10;6
133;11;28;8;10
139;11;31;1;15
147;12;23;9;7
161;13;28;6;11
181;15;26;8;9
187;15;29;5;12
191;15;30;2;14
244;19;21;11;5
260;20;27;5;11
293;23;25;7;9
END_PROGRESS
BEGIN_STATE
totalFEs: 300
totalTimeMillis: 23
bestF: 21
lastImprovementFE: 293
lastImprovementTimeMillis: 23
bestFs: 11;5
archiveSize: 9
END_STATE
BEGIN_SETUP
p.name: MOLoggingProcessWithoutSearchSpace
p.class: moptipy.api._mo_process_no_ss_log._MOProcessNoSSLog
p.lowerBound: 0
p.upperBound: 48
p.maxFEs: 300
p.goalF: 0
p.randSeed: 200
p.randSeed(hex): 0xc8
p.randGenType: numpy.random._generator.Generator
p.randBitGenType: numpy.random._pcg64.PCG64
p.archiveMaxSize: 32
p.archivePruneLimit: 128
a.name: nsga2_10_0d05_uniform_flip1
a.class: moptipy.algorithms.mo.nsga2.NSGA2
a.op0.name: randomize
a.op0.class: moptipy.operators.bitstrings.op0_random.Op0Random
a.op1.name: flip1
a.op1.class: moptipy.operators.bitstrings.op1_flip1.Op1Flip1
a.op2.name: uniform
a.op2.class: moptipy.operators.bitstrings.op2_uniform.Op2Uniform
a.pop_size: 10
a.cr: 0.05
a.cr(hex): 0x1.999999999999ap-5
y.name: bits16
y.class: moptipy.spaces.bitstrings.BitStrings
y.nvars: 16
y.dtype: ?
f.name: weightedSum
f.class: moptipy.mo.problem.weighted_sum.WeightedSum
f.lowerBound: 0
f.upperBound: 48
f.nvars: 2
f.dtype: b
f.f0.name: zeromax_16
f.f0.class: moptipy.examples.bitstrings.zeromax.ZeroMax
f.f0.lowerBound: 0
f.f0.upperBound: 16
f.f0.n: 16
f.f1.name: leadingones_16
f.f1.class: moptipy.examples.bitstrings.leadingones.LeadingOnes
f.f1.lowerBound: 0
f.f1.upperBound: 16
f.f1.n: 16
f.weights: 1;2
f.weightsDtype: b
ap.name: keepFarthest
ap.class: moptipy.mo.archive.keep_farthest.KeepFarthest
END_SETUP
BEGIN_SYS_INFO
session.start: 2023-02-18 07:28:08.247748+00:00
session.node: home
session.procesId: 0x2d20b
session.cpuAffinity: 0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15
session.ipAddress: 192.168.1.109
version.moptipy: 0.9.53
version.contourpy: 1.0.6
version.cycler: 0.11.0
version.fonttools: 4.38.0
version.joblib: 1.2.0
version.kiwisolver: 1.4.4
version.llvmlite: 0.39.1
version.matplotlib: 3.7.0
version.numba: 0.56.4
version.numpy: 1.23.5
version.packaging: 21.3
version.Pillow: 9.4.0
version.psutil: 5.9.4
version.pyparsing: 3.0.9
version.pythondateutil: 2.8.2
version.scipy: 1.10.0
version.six: 1.16.0
version.threadpoolctl: 3.1.0
hardware.machine: x86_64
hardware.nPhysicalCpus: 8
hardware.nLogicalCpus: 16
hardware.cpuMhz: (2200MHz..3700MHz)*16
hardware.byteOrder: little
hardware.cpu: AMD Ryzen 7 2700X Eight-Core Processor
hardware.memSize: 16717656064
python.version: 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0]
python.implementation: CPython
os.name: Linux
os.release: 5.19.0-32-generic
os.version: 33~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Jan 30 17:03:34 UTC 2
END_SYS_INFO
BEGIN_RESULT_Y
TTTTTTTTTTTFFFFF
END_RESULT_Y
BEGIN_ARCHIVE_0_Y
FFFFFFFFFFFFFFFF
END_ARCHIVE_0_Y
BEGIN_ARCHIVE_1_Y
TFFFFFFFFFFFFFFF
END_ARCHIVE_1_Y
BEGIN_ARCHIVE_2_Y
TTFFFFFFFFFFFFFF
END_ARCHIVE_2_Y
BEGIN_ARCHIVE_3_Y
TTTFFFFFFFFFFFFT
END_ARCHIVE_3_Y
BEGIN_ARCHIVE_4_Y
TTTTTFFFFFFFFFFF
END_ARCHIVE_4_Y
BEGIN_ARCHIVE_5_Y
TTTTTTTFFFFFFFFF
END_ARCHIVE_5_Y
BEGIN_ARCHIVE_6_Y
TTTTTTTTTFFFFFFF
END_ARCHIVE_6_Y
BEGIN_ARCHIVE_7_Y
TTTTTTTTTTFFFFFF
END_ARCHIVE_7_Y
BEGIN_ARCHIVE_8_Y
TTTTTTTTTTTFFFFF
END_ARCHIVE_8_Y
BEGIN_ARCHIVE_QUALITIES
f;f0;f1
32;0;16
31;1;15
30;2;14
30;4;13
27;5;11
25;7;9
23;9;7
22;10;6
21;11;5
END_ARCHIVE_QUALITIES
</pre></div></div></section></section><section id=end-result-csv-files><h3>5.2. End Result CSV Files<a title="Link to this heading"class=headerlink href=#end-result-csv-files>¶</a></h3><p>While a <a class="reference external"href=#log-files>log file</a> contains all the data of a single run, you often want to get just the basic measurements, such as the result objective values, from all runs of one experiment in a single file. The class <a class="reference external"href=./moptipy.evaluation.html#moptipy.evaluation.end_results.EndResult><code class="docutils literal notranslate"><span class=pre>moptipy.evaluation.end_results.EndResult</span></code></a> provides the tools needed to parse all log files, extract these information, and store them into a semicolon-separated-values formatted file. The files generated this way can easily be imported into applications like Microsoft Excel.<p>If you have the <a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> package installed, then you can call the module directly from the command line as:<div class="highlight-shell notranslate"><div class=highlight><pre><span></span>python3<span class=w> </span>-m<span class=w> </span>moptipy.evaluation.end_results<span class=w> </span>source_dir<span class=w> </span>dest_file
</pre></div></div><p>where <code class="docutils literal notranslate"><span class=pre>source_dir</span></code> should be the root directory with the experimental data (see <a class="reference external"href=#file-names-and-folder-structure>Section 5.1.1</a>)) and <code class="docutils literal notranslate"><span class=pre>dest_file</span></code> is the path to the CSV file to write.<section id=the-end-results-file-format><h4>5.2.1. The End Results File Format<a title="Link to this heading"class=headerlink href=#the-end-results-file-format>¶</a></h4><p>An end results file contains a header line and then one line for each log file that was parsed. The eleven columns are separated by <code class="docutils literal notranslate"><span class=pre>;</span></code>. Cells without value are left empty.<p>It presents the following columns:<ol class="arabic simple"><li><p><code class="docutils literal notranslate"><span class=pre>algorithm</span></code>: the <a class="reference external"href=./moptipy.api.html#module-moptipy.api.algorithm>algorithm</a> that was executed<li><p><code class="docutils literal notranslate"><span class=pre>instance</span></code>: the instance it was applied to<li><p><code class="docutils literal notranslate"><span class=pre>objective</span></code>: the name of the <a class="reference external"href=./moptipy.api.html#module-moptipy.api.objective>objective function</a><li><p>optionally <code class="docutils literal notranslate"><span class=pre>encoding</span></code>: the name of the encoding, if any <a class="reference external"href=./moptipy.api.html#module-moptipy.api.encoding>encoding</a> was used. This column is omitted if the search and solution space was the same in all runs and no encoding was used. If at least one run did use an encoding, this column is present. It will contain nothing for the runs that did not use an encoding.<li><p><code class="docutils literal notranslate"><span class=pre>randSeed</span></code> the hexadecimal version of the random seed of the run<li><p><code class="docutils literal notranslate"><span class=pre>bestF</span></code>: the best objective value encountered during the run<li><p><code class="docutils literal notranslate"><span class=pre>lastImprovementFE</span></code>: the FE when the last improvement was registered<li><p><code class="docutils literal notranslate"><span class=pre>lastImprovementTimeMillis</span></code>: the time in milliseconds from the start of the run when the last improvement was registered<li><p><code class="docutils literal notranslate"><span class=pre>totalFEs</span></code>: the total number of FEs performed<li><p><code class="docutils literal notranslate"><span class=pre>totalTimeMillis</span></code>: the total time in milliseconds consumed by the run<li><p>optionally <code class="docutils literal notranslate"><span class=pre>goalF</span></code>: the <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_goal_f>goal objective value</a>, if specified, otherwise omitted. If at least one run specified a goal objective value, this column is present. Otherwise it is omitted. For runs not having a goal objective value, it remains empty.<li><p>optionally <code class="docutils literal notranslate"><span class=pre>maxFEs</span></code>: the computational budget in terms of the <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_max_fes>maximum number of permitted FEs</a>, if specified, otherwise omitted. If at least one run specified a time limit in terms of objective function evaluations, this column is present. Otherwise it is omitted. For runs not having an FE-based time limit, it remains empty.<li><p>optionally <code class="docutils literal notranslate"><span class=pre>maxTimeMillis</span></code>: the computational budget in terms of the <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_max_time_millis>maximum runtime in milliseconds</a>, if specified, otherwise omitted. If at least one run specified a time limit in terms of milliseconds, this column is present. Otherwise it is omitted. For runs not having a ms-based time limit, it remains empty.</ol><p>For each run, i.e., “algorithm x instance x seed combination,” one row with the above values is generated. Notice that from the algorithm and instance name together with the random seed, you can find the corresponding log file. In some situations, you may apply “algorithm x instance x seed combinations” together with different objective functions or different encodings or both. In such situations, you would store the results in different base folders, as these elements do not appear in the algorithm names. They are contained in the end results CSV file, though.</section><section id=an-example-for-end-results-files><h4>5.2.2. An Example for End Results Files<a title="Link to this heading"class=headerlink href=#an-example-for-end-results-files>¶</a></h4><p>Let us execute an abridged example experiment, parse all log files, condense their information into an end results statistics file, and then print that file’s contents. We can do that with the code below, which is also available as file <a class="reference external"href=./examples/end_results_jssp_py.html>examples/end_results_jssp.py</a>.<div class="highlight-python notranslate"><div class=highlight><pre><span></span><span class=sd>"""Generate an end-results CSV file for an experiment with the JSSP."""</span>
<span class=kn>from</span><span class=w> </span><span class=nn>pycommons.io.temp</span><span class=w> </span><span class=kn>import</span> <span class=n>temp_dir</span>  <span class=c1># tool for temp directories</span>

<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.algorithms.so.hill_climber</span><span class=w> </span><span class=kn>import</span> <span class=n>HillClimber</span>  <span class=c1># second algo</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.algorithms.so.rls</span><span class=w> </span><span class=kn>import</span> <span class=n>RLS</span>  <span class=c1># first algo to test</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.evaluation.end_results</span><span class=w> </span><span class=kn>import</span> <span class=n>from_logs</span><span class=p>,</span> <span class=n>to_csv</span>  <span class=c1># end results</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.jssp.experiment</span><span class=w> </span><span class=kn>import</span> <span class=n>run_experiment</span>  <span class=c1># JSSP example</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.permutations.op0_shuffle</span><span class=w> </span><span class=kn>import</span> <span class=n>Op0Shuffle</span>  <span class=c1># 0-ary op</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.permutations.op1_swap2</span><span class=w> </span><span class=kn>import</span> <span class=n>Op1Swap2</span>  <span class=c1># 1-ary op</span>

<span class=c1># We work in a temporary directory, i.e., delete all generated files on exit.</span>
<span class=c1># For a real experiment, you would put an existing directory path into `td` by</span>
<span class=c1># doing `from pycommons.io.path import Path; td = Path("mydir")` and not use</span>
<span class=c1># the `with` block.</span>
<span class=k>with</span> <span class=n>temp_dir</span><span class=p>()</span> <span class=k>as</span> <span class=n>td</span><span class=p>:</span>
    <span class=n>run_experiment</span><span class=p>(</span>  <span class=c1># run the JSSP experiment with the following parameters:</span>
        <span class=n>base_dir</span><span class=o>=</span><span class=n>td</span><span class=p>,</span>  <span class=c1># base directory to write all log files to</span>
        <span class=n>algorithms</span><span class=o>=</span><span class=p>[</span>  <span class=c1># the set of algorithm generators</span>
            <span class=k>lambda</span> <span class=n>_</span><span class=p>,</span> <span class=n>pwr</span><span class=p>:</span> <span class=n>RLS</span><span class=p>(</span><span class=n>Op0Shuffle</span><span class=p>(</span><span class=n>pwr</span><span class=p>),</span> <span class=n>Op1Swap2</span><span class=p>()),</span>  <span class=c1># algo 1</span>
            <span class=k>lambda</span> <span class=n>_</span><span class=p>,</span> <span class=n>pwr</span><span class=p>:</span> <span class=n>HillClimber</span><span class=p>(</span><span class=n>Op0Shuffle</span><span class=p>(</span><span class=n>pwr</span><span class=p>),</span> <span class=n>Op1Swap2</span><span class=p>())],</span>  <span class=c1># 2</span>
        <span class=n>instances</span><span class=o>=</span><span class=p>(</span><span class=s2>"demo"</span><span class=p>,</span> <span class=s2>"abz7"</span><span class=p>,</span> <span class=s2>"la24"</span><span class=p>),</span>  <span class=c1># we use 3 JSSP instances</span>
        <span class=n>max_fes</span><span class=o>=</span><span class=mi>10000</span><span class=p>,</span>  <span class=c1># we grant 10000 FEs per run</span>
        <span class=n>n_runs</span><span class=o>=</span><span class=mi>4</span><span class=p>)</span>  <span class=c1># perform 4 runs per algorithm * instance combination</span>

    <span class=n>data</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>from_logs</span><span class=p>(</span><span class=n>td</span><span class=p>))</span>  <span class=c1># load end results</span>
    <span class=n>er_csv</span> <span class=o>=</span> <span class=n>to_csv</span><span class=p>(</span>  <span class=c1># store end results to csv file (returns path)</span>
        <span class=n>data</span><span class=p>,</span> <span class=n>td</span><span class=o>.</span><span class=n>resolve_inside</span><span class=p>(</span><span class=s2>"end_results.txt"</span><span class=p>))</span>  <span class=c1># path to output file</span>
    <span class=nb>print</span><span class=p>(</span><span class=n>er_csv</span><span class=o>.</span><span class=n>read_all_str</span><span class=p>())</span>  <span class=c1># read generated file as string and print it</span>
<span class=c1># When leaving "while", the temp directory will be deleted</span>
</pre></div></div><p>This will yield something like the following output:<div class="highlight-text notranslate"><div class=highlight><pre><span></span># Experiment End Results
# See the description at the bottom of the file.
algorithm;instance;objective;encoding;randSeed;bestF;lastImprovementFE;lastImprovementTimeMillis;totalFEs;totalTimeMillis;goalF;maxFEs;maxTimeMillis
hc_swap2;abz7;makespan;operation_based_encoding;0x3e96d853a69f369d;826;8335;56;10000;67;656;10000;300000
hc_swap2;abz7;makespan;operation_based_encoding;0x7e986b616543ff9b;850;6788;52;10000;88;656;10000;300000
hc_swap2;abz7;makespan;operation_based_encoding;0xd3de359d5e3982fd;814;4437;50;10000;87;656;10000;300000
hc_swap2;abz7;makespan;operation_based_encoding;0xeb6420da7243abbe;804;3798;42;10000;111;656;10000;300000
hc_swap2;demo;makespan;operation_based_encoding;0xd2866f0630434df;185;128;2;10000;66;180;10000;300000
hc_swap2;demo;makespan;operation_based_encoding;0x5a9363100a272f12;200;33;1;10000;80;180;10000;300000
hc_swap2;demo;makespan;operation_based_encoding;0x9ba8fd0486c59354;180;34;1;34;1;180;10000;300000
hc_swap2;demo;makespan;operation_based_encoding;0xdac201e7da6b455c;205;4;1;10000;94;180;10000;300000
hc_swap2;la24;makespan;operation_based_encoding;0x23098fe72e435030;1065;9868;98;10000;99;935;10000;300000
hc_swap2;la24;makespan;operation_based_encoding;0xac5ca7763bbe7138;1233;2349;22;10000;97;935;10000;300000
hc_swap2;la24;makespan;operation_based_encoding;0xb4eab9a0c2193a9e;1111;2594;25;10000;98;935;10000;300000
hc_swap2;la24;makespan;operation_based_encoding;0xb76a45e4f8b431ae;1118;2130;13;10000;58;935;10000;300000
rls_swap2;abz7;makespan;operation_based_encoding;0x3e96d853a69f369d;761;9663;92;10000;95;656;10000;300000
rls_swap2;abz7;makespan;operation_based_encoding;0x7e986b616543ff9b;767;9935;80;10000;80;656;10000;300000
rls_swap2;abz7;makespan;operation_based_encoding;0xd3de359d5e3982fd;762;9128;77;10000;82;656;10000;300000
rls_swap2;abz7;makespan;operation_based_encoding;0xeb6420da7243abbe;756;8005;52;10000;64;656;10000;300000
rls_swap2;demo;makespan;operation_based_encoding;0xd2866f0630434df;180;63;1;63;1;180;10000;300000
rls_swap2;demo;makespan;operation_based_encoding;0x5a9363100a272f12;180;84;1;84;1;180;10000;300000
rls_swap2;demo;makespan;operation_based_encoding;0x9ba8fd0486c59354;180;33;1;33;1;180;10000;300000
rls_swap2;demo;makespan;operation_based_encoding;0xdac201e7da6b455c;180;83;1;83;1;180;10000;300000
rls_swap2;la24;makespan;operation_based_encoding;0x23098fe72e435030;1026;9114;91;10000;99;935;10000;300000
rls_swap2;la24;makespan;operation_based_encoding;0xac5ca7763bbe7138;1015;9451;94;10000;99;935;10000;300000
rls_swap2;la24;makespan;operation_based_encoding;0xb4eab9a0c2193a9e;1033;7503;74;10000;98;935;10000;300000
rls_swap2;la24;makespan;operation_based_encoding;0xb76a45e4f8b431ae;1031;5218;30;10000;63;935;10000;300000
# Records describing the end results of single runs (single executions) of algorithms applied to optimization problems.
# Each run is characterized by an algorithm setup, a problem instance, and a random seed.
# algorithm: the name of the algorithm setup that was used.
# instance: the name of the problem instance to which the algorithm was applied.
# objective: the name of the objective function (often also called fitness function or cost function) that was used to rate the solution quality.
# encoding: the name of the encoding, often also called genotype-phenotype mapping, used. In some problems, the search space on which the algorithm works is different from the space of possible solutions. For example, when solving a scheduling problem, maybe our optimization algorithm navigates in the space of permutations, but the solutions are Gantt charts. The encoding is the function that translates the points in the search space (e.g., permutations) to the points in the solution space (e.g., Gantt charts). Nothing if no encoding was used.
# randSeed: the value of the seed of the random number generator used in the run. Random seeds arein 0..18446744073709551615 and the random number generators are those from numpy.
# bestF: the best (smallest) objective value ever encountered during the run (regardless whether the algorithm later forgot it again or not).
...
</pre></div></div></section></section><section id=end-result-statistics-csv-files><h3>5.3. End Result Statistics CSV Files<a title="Link to this heading"class=headerlink href=#end-result-statistics-csv-files>¶</a></h3><p>We can also aggregate the end result data over either algorithm x instance combinations, over whole algorithms, over whole instances, or just over everything. The class <a class="reference external"href=./moptipy.evaluation.html#moptipy.evaluation.end_statistics.EndStatistics><code class="docutils literal notranslate"><span class=pre>moptipy.evaluation.end_statistics.EndStatistics</span></code></a> provides the tools needed to aggregate statistics over sequences of <a class="reference external"href=./moptipy.evaluation.html#moptipy.evaluation.end_results.EndResult><code class="docutils literal notranslate"><span class=pre>moptipy.evaluation.end_results.EndResult</span></code></a> and to store them into a semicolon-separated-values formatted file. The files generated this way can easily be imported into applications like Microsoft Excel.<p>If you have the <a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> package installed, then you can call the module directly from the command line as:<div class="highlight-shell notranslate"><div class=highlight><pre><span></span>python3<span class=w> </span>-m<span class=w> </span>moptipy.evaluation.end_statistics<span class=w> </span><span class=nb>source</span><span class=w> </span>dest_file
</pre></div></div><p>where <code class="docutils literal notranslate"><span class=pre>source</span></code> should either be the root directory with the experimental data (see <a class="reference external"href=#file-names-and-folder-structure>Section 5.1.1</a>)) or the path to a <a class="reference external"href=#end-result-csv-files>end results CSV file</a> and <code class="docutils literal notranslate"><span class=pre>dest_file</span></code> is the path to the CSV file to write.<section id=the-end-result-statistics-file-format><h4>5.3.1. The End Result Statistics File Format<a title="Link to this heading"class=headerlink href=#the-end-result-statistics-file-format>¶</a></h4><p>End result statistics files contain information in form of statistics aggregated over several runs. Therefore, they first contain columns identifying the data over which has been aggregated:<ol class="arabic simple"><li><p><code class="docutils literal notranslate"><span class=pre>algorithm</span></code>: the algorithm used (empty if we aggregate over all algorithms)<li><p><code class="docutils literal notranslate"><span class=pre>instance</span></code>: the instance to which it was applied (empty if we aggregate over all instance)</ol><p>Then the column <code class="docutils literal notranslate"><span class=pre>n</span></code> denotes the number of runs that were performed in the above setting. We have then the following data columns:<ol class="arabic simple"><li><p><code class="docutils literal notranslate"><span class=pre>bestF.x</span></code>: statistics about the best objective value encountered during the run<li><p><code class="docutils literal notranslate"><span class=pre>lastImprovementFE.x</span></code>: statistics about the index of the objective function evaluation (FE) when the last improvement was registered<li><p><code class="docutils literal notranslate"><span class=pre>lastImprovementTimeMillis.x</span></code>: statistics about the time in milliseconds from the start of the run when the last improvement was registered<li><p><code class="docutils literal notranslate"><span class=pre>totalFEs.x</span></code>: statistics about the total number of FEs performed by the runs<li><p><code class="docutils literal notranslate"><span class=pre>totalTimeMillis.x</span></code>: statistics about the total time in milliseconds consumed by the runs</ol><p>Here, the <code class="docutils literal notranslate"><span class=pre>.x</span></code> can stand for the following statistics:<ul class=simple><li><p><code class="docutils literal notranslate"><span class=pre>min</span></code>: the minimum<li><p><code class="docutils literal notranslate"><span class=pre>med</span></code>: the median<li><p><code class="docutils literal notranslate"><span class=pre>mean</span></code>: the mean<li><p><code class="docutils literal notranslate"><span class=pre>geom</span></code>: the geometric mean<li><p><code class="docutils literal notranslate"><span class=pre>max</span></code>: the maximum<li><p><code class="docutils literal notranslate"><span class=pre>sd</span></code>: the standard deviation</ul><p>The column <code class="docutils literal notranslate"><span class=pre>goalF</span></code> denotes the goal objective value, if any. If it is not empty and greater than zero, then we also have the columns <code class="docutils literal notranslate"><span class=pre>bestFscaled.x</span></code>, which provide statistics of <code class="docutils literal notranslate"><span class=pre>bestF/goalF</span></code> as discussed above. If <code class="docutils literal notranslate"><span class=pre>goalF</span></code> is defined for at least some settings, we also get the following columns:<ol class="arabic simple"><li><p><code class="docutils literal notranslate"><span class=pre>nSuccesses</span></code>: the number of runs that were successful in reaching the goal<li><p><code class="docutils literal notranslate"><span class=pre>successFEs.x</span></code>: the statistics about the FEs until success, but <em>only</em> computed over the successful runs<li><p><code class="docutils literal notranslate"><span class=pre>successTimeMillis.x</span></code>: the statistics of the runtime until success, but <em>only</em> computed over the successful runs<li><p><code class="docutils literal notranslate"><span class=pre>ertFEs</span></code>: the empirically estimated runtime to success in FEs<li><p><code class="docutils literal notranslate"><span class=pre>ertTimeMillis</span></code>: the empirically estimated runtime to success in milliseconds</ol><p>Finally, the columns <code class="docutils literal notranslate"><span class=pre>maxFEs</span></code> and <code class="docutils literal notranslate"><span class=pre>maxTimeMillis</span></code>, if specified, include the computational budget limits in terms of FEs or milliseconds.</section><section id=example-for-end-result-statistics-files><h4>5.3.2. Example for End Result Statistics Files<a title="Link to this heading"class=headerlink href=#example-for-end-result-statistics-files>¶</a></h4><p>We can basically execute the same abridged experiment as in the <a class="reference external"href=#an-example-for-end-results-files>previous section</a>, but now take the aggregation of information one step further with the code below. This code is also available as file <a class="reference external"href=./examples/end_statistics_jssp_py.html>examples/end_statistics_jssp</a>.<div class="highlight-python notranslate"><div class=highlight><pre><span></span><span class=sd>"""Get an end-result statistics CSV file for an experiment with the JSSP."""</span>
<span class=kn>from</span><span class=w> </span><span class=nn>pycommons.io.temp</span><span class=w> </span><span class=kn>import</span> <span class=n>temp_dir</span>  <span class=c1># tool for temp directories</span>

<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.algorithms.so.hill_climber</span><span class=w> </span><span class=kn>import</span> <span class=n>HillClimber</span>  <span class=c1># second algo</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.algorithms.so.rls</span><span class=w> </span><span class=kn>import</span> <span class=n>RLS</span>  <span class=c1># first algo to test</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.evaluation.end_results</span><span class=w> </span><span class=kn>import</span> <span class=n>from_logs</span>  <span class=c1># the end result record</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.evaluation.end_statistics</span><span class=w> </span><span class=kn>import</span> <span class=n>from_end_results</span><span class=p>,</span> <span class=n>to_csv</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.jssp.experiment</span><span class=w> </span><span class=kn>import</span> <span class=n>run_experiment</span>  <span class=c1># JSSP example</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.permutations.op0_shuffle</span><span class=w> </span><span class=kn>import</span> <span class=n>Op0Shuffle</span>  <span class=c1># 0-ary op</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.permutations.op1_swap2</span><span class=w> </span><span class=kn>import</span> <span class=n>Op1Swap2</span>  <span class=c1># 1-ary op</span>

<span class=c1># We work in a temporary directory, i.e., delete all generated files on exit.</span>
<span class=c1># For a real experiment, you would put an existing directory path into `td` by</span>
<span class=c1># doing `from pycommons.io.path import Path; td = Path("mydir")` and not use</span>
<span class=c1># the `with` block.</span>
<span class=k>with</span> <span class=n>temp_dir</span><span class=p>()</span> <span class=k>as</span> <span class=n>td</span><span class=p>:</span>
    <span class=n>run_experiment</span><span class=p>(</span>  <span class=c1># run the JSSP experiment with the following parameters:</span>
        <span class=n>base_dir</span><span class=o>=</span><span class=n>td</span><span class=p>,</span>  <span class=c1># base directory to write all log files to</span>
        <span class=n>algorithms</span><span class=o>=</span><span class=p>[</span>  <span class=c1># the set of algorithm generators</span>
            <span class=k>lambda</span> <span class=n>_</span><span class=p>,</span> <span class=n>pwr</span><span class=p>:</span> <span class=n>RLS</span><span class=p>(</span><span class=n>Op0Shuffle</span><span class=p>(</span><span class=n>pwr</span><span class=p>),</span> <span class=n>Op1Swap2</span><span class=p>()),</span>  <span class=c1># algo 1</span>
            <span class=k>lambda</span> <span class=n>_</span><span class=p>,</span> <span class=n>pwr</span><span class=p>:</span> <span class=n>HillClimber</span><span class=p>(</span><span class=n>Op0Shuffle</span><span class=p>(</span><span class=n>pwr</span><span class=p>),</span> <span class=n>Op1Swap2</span><span class=p>())],</span>  <span class=c1># 2</span>
        <span class=n>instances</span><span class=o>=</span><span class=p>(</span><span class=s2>"demo"</span><span class=p>,</span> <span class=s2>"abz7"</span><span class=p>,</span> <span class=s2>"la24"</span><span class=p>),</span>  <span class=c1># we use 3 JSSP instances</span>
        <span class=n>max_fes</span><span class=o>=</span><span class=mi>10000</span><span class=p>,</span>  <span class=c1># we grant 10000 FEs per run</span>
        <span class=n>n_runs</span><span class=o>=</span><span class=mi>4</span><span class=p>)</span>  <span class=c1># perform 4 runs per algorithm * instance combination</span>

    <span class=c1># Compute the end statistics from end results loaded from log files.</span>
    <span class=n>end_stats</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>from_end_results</span><span class=p>(</span><span class=n>from_logs</span><span class=p>(</span><span class=n>td</span><span class=p>)))</span>

    <span class=c1># store the statistics to a CSV file</span>
    <span class=n>es_csv</span> <span class=o>=</span> <span class=n>to_csv</span><span class=p>(</span><span class=n>end_stats</span><span class=p>,</span> <span class=n>td</span><span class=o>.</span><span class=n>resolve_inside</span><span class=p>(</span><span class=s2>"end_stats.txt"</span><span class=p>))</span>
    <span class=nb>print</span><span class=p>(</span><span class=n>es_csv</span><span class=o>.</span><span class=n>read_all_str</span><span class=p>())</span>  <span class=c1># read and print the file</span>
<span class=c1># When leaving "while", the temp directory will be deleted</span>
</pre></div></div><p>We will get something like the following output:<div class="highlight-text notranslate"><div class=highlight><pre><span></span># Experiment End Results Statistics
# See the description at the bottom of the file.
algorithm;instance;objective;encoding;n;bestF.min;bestF.mean;bestF.med;bestF.geom;bestF.max;bestF.sd;lastImprovementFE.min;lastImprovementFE.mean;lastImprovementFE.med;lastImprovementFE.geom;lastImprovementFE.max;lastImprovementFE.sd;lastImprovementTimeMillis.min;lastImprovementTimeMillis.mean;lastImprovementTimeMillis.med;lastImprovementTimeMillis.geom;lastImprovementTimeMillis.max;lastImprovementTimeMillis.sd;totalFEs.min;totalFEs.mean;totalFEs.med;totalFEs.geom;totalFEs.max;totalFEs.sd;totalTimeMillis.min;totalTimeMillis.mean;totalTimeMillis.med;totalTimeMillis.geom;totalTimeMillis.max;totalTimeMillis.sd;goalF;bestFscaled.min;bestFscaled.mean;bestFscaled.med;bestFscaled.geom;bestFscaled.max;bestFscaled.sd;successN;successFEs.min;successFEs.mean;successFEs.med;successFEs.geom;successFEs.max;successFEs.sd;successTimeMillis;ertFEs;ertTimeMillis;maxFEs;maxTimeMillis
hc_swap2;abz7;makespan;operation_based_encoding;4;804;823.5;820;823.3222584158909;850;19.82422760159901;3798;5839.5;5612.5;5556.776850879124;8335;2102.5303010103485;26;57;54;51.55696256128031;94;28.2724836781867;10000;10000;10000;10000;10000;0;68;92.5;95;90.55441161416107;112;21.486429825977762;656;1.225609756097561;1.2553353658536586;1.25;1.2550644183169068;1.295731707317073;0.030219859148778932;0;;;;;;;;inf;inf;10000;300000
hc_swap2;demo;makespan;operation_based_encoding;4;180;192.5;192.5;192.22373987227797;205;11.902380714238083;4;49.75;33.5;27.53060177455133;128;53.98996820397903;1;1.25;1;1.189207115002721;2;0.5;34;7508.5;10000;2414.736402766418;10000;4983;1;62.75;76;26.889958060259907;98;45.78482281280556;180;1;1.0694444444444444;1.0694444444444444;1.0679096659571;1.1388888888888888;0.0661243373013227;1;34;34;34;34;34;;1;30034;251;10000;300000
hc_swap2;la24;makespan;operation_based_encoding;4;1065;1131.75;1114.5;1130.1006812239552;1233;71.47668617575012;2130;4235.25;2471.5;3364.07316907124;9868;3759.9463981108383;14;36;25;28.82037873718377;80;29.888682361946525;10000;10000;10000;10000;10000;0;60;73.5;75.5;72.89589968499726;83;10.661457061146317;935;1.13903743315508;1.210427807486631;1.1919786096256684;1.2086638301860484;1.3187165775401068;0.07644565366390384;0;;;;;;;;inf;inf;10000;300000
rls_swap2;abz7;makespan;operation_based_encoding;4;756;761.5;761.5;761.4899866748019;767;4.509249752822894;8005;9182.75;9395.5;9151.751195919433;9935;853.7393727986702;62;94.25;100.5;91.66752533729615;114;24.005207768315607;10000;10000;10000;10000;10000;0;68;102.75;114;100.40278492339303;115;23.18584338197197;656;1.1524390243902438;1.1608231707317074;1.1608231707317074;1.1608079065164663;1.1692073170731707;0.006873856330522731;0;;;;;;;;inf;inf;10000;300000
rls_swap2;demo;makespan;operation_based_encoding;4;180;180;180;180;180;0;33;65.75;73;61.7025293022418;84;23.879907872519105;1;1;1;1;1;0;33;65.75;73;61.7025293022418;84;23.879907872519105;1;1;1;1;1;0;180;1;1;1;1;1;0;4;33;65.75;73;61.7025293022418;84;23.879907872519105;1;65.75;1;10000;300000
rls_swap2;la24;makespan;operation_based_encoding;4;1015;1026.25;1028.5;1026.2261982741852;1033;8.05708797684788;5218;7821.5;8308.5;7620.464638595248;9451;1932.6562894972642;32;62;61.5;57.75986004802567;93;25.468935326524086;10000;10000;10000;10000;10000;0;58;76.25;72.5;74.35251132261814;102;20.039544239661073;935;1.085561497326203;1.0975935828877006;1.1;1.0975681264964547;1.1048128342245989;0.008617206392350722;0;;;;;;;;inf;inf;10000;300000
# This file provides statistics about the end results of multiple runs of optimization algorithms on optimization problems.
...
</pre></div></div></section></section></section><section id=evaluating-experiments><h2>6. Evaluating Experiments<a title="Link to this heading"class=headerlink href=#evaluating-experiments>¶</a></h2><p>The <a class="reference external"href=./>moptipy</a> system offers a set of tools to evaluate the results collected from experiments. On one hand, you can <a class="reference external"href=#exporting-data>export</a> the data to formats that can be processed by other tools. On the other hand, you can plot a variety of different diagrams. These diagrams can then be <a class="reference external"href=./moptipy.utils.html#module-moptipy.utils.plot_utils>stored</a> in different formats, such as <code class="docutils literal notranslate"><span class=pre>svg</span></code> (for the web) or <code class="docutils literal notranslate"><span class=pre>pdf</span></code> (for scientific papers).<section id=exporting-data><h3>6.1. Exporting Data<a title="Link to this heading"class=headerlink href=#exporting-data>¶</a></h3><section id=export-to-csv-formats-for-excel-et-al><h4>6.1.1. Export to CSV Formats for Excel et al.<a title="Link to this heading"class=headerlink href=#export-to-csv-formats-for-excel-et-al>¶</a></h4><p>We already discussed two formats that can be used to export data to Excel or other software tools.<p>The <a class="reference external"href=#end-result-csv-files>End Results CSV format</a> produces semicolon-separated-values files that include the states of each run. For every single run, there will be a row with the algorithm name, instance name, and random seed, as well as the best objective value, the last improvement time and FE, and the total time and consumed FEs. It is possible to select “virtual” limits for the runtime (measured in either FEs or milliseconds) and the objective value and to obtain the end results of the algorithms <em>if</em> these were the termination criteria. This is, of course, only possible if we logged algorithm progress (i.e., did at least <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution.set_log_improvements><code class="docutils literal notranslate"><span class=pre>set_log_improvements(True)</span></code></a>) over runtime and if these virtual limits are less or equal to the actual termination criteria.<p>The <a class="reference external"href=#end-result-statistics-csv-files>End Results Statistics CSV format</a> allows you to export statistics aggregated, e.g., over the instance-algorithm combinations, for instance over all algorithms, or for one algorithm over all instances. The format is otherwise similar to the End Results CSV format.</section><section id=export-to-iohanalyzer><h4>6.1.2 Export to IOHanalyzer<a title="Link to this heading"class=headerlink href=#export-to-iohanalyzer>¶</a></h4><p>We also support converting our experimental results to the <a class="reference external"href=https://iohprofiler.github.io/IOHanalyzer/data>IOHprofiler data format</a>. This can be done by the function <a class="reference external"href=./moptipy.evaluation.html#module-moptipy.evaluation.ioh_analyzer>moptipy_to_ioh_analyzer</a>, which accepts a source directory in the <a class="reference external"href=#file-names-and-folder-structure><code class="docutils literal notranslate"><span class=pre>moptipy</span></code> structure</a> and a path to a destination folder where the <code class="docutils literal notranslate"><span class=pre>IOHprofiler</span></code>-formatted data will be stored. You can then analyze it with the <a class="reference external"href=https://iohprofiler.github.io/IOHanalyzer>IOHanalyzer</a>. If you have the <a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> package installed, then you can call the module directly from the command line as:<div class="highlight-shell notranslate"><div class=highlight><pre><span></span>python3<span class=w> </span>-m<span class=w> </span>moptipy.evaluation.ioh_analyzer<span class=w> </span>source_dir<span class=w> </span>dest_dir
</pre></div></div><p>where <code class="docutils literal notranslate"><span class=pre>source_dir</span></code> should be the root directory with the experimental data (see <a class="reference external"href=#file-names-and-folder-structure>Section 5.1.1</a>)) and <code class="docutils literal notranslate"><span class=pre>dest_dir</span></code> is the directory where the IOHprofiler-formatted data should be written.</section></section><section id=progress-plots><h3>6.2. Progress Plots<a title="Link to this heading"class=headerlink href=#progress-plots>¶</a></h3><p>In the file <a class="reference external"href=./examples/progress_plot_py.html>examples/progress_plot.py</a>, you can find some code running a small experiment and creating “progress plots.” A progress plot is a diagram that shows how an algorithm improves the solution quality over time. The solution quality can be the raw objective value, the objective value scaled by the goal objective value, or the objective value normalized with the goal objective value. The time can be measured in objective function evaluations (FEs) or in milliseconds and may be log-scaled or unscaled. A progress plot can illustrate groups of single runs that were performed in the experiments. It can also illustrate statistics over the runs, say, the arithmetic mean of the best-so-far objective value at a given point in time. Both types of data can also be combined in the same diagram.</p><a href=./_static/progress_single_runs_and_mean_f_over_fes.png> <img alt="Example for a progress plot combining statistics and single runs"src=./_static/progress_single_runs_and_mean_f_over_fes.png style=width:70%;min-width:70%;max-width:70%> </a><p>Progress plots are implemented in the module <a class="reference external"href=./moptipy.evaluation.html#module-moptipy.evaluation.plot_progress>moptipy.evaluation.plot_progress</a>.</section><section id=end-results-plot><h3>6.3. End Results Plot<a title="Link to this heading"class=headerlink href=#end-results-plot>¶</a></h3><p>In the file <a class="reference external"href=./examples/end_results_plot_py.html>examples/end_results_plot.py</a>, you can find some code running a small experiment and creating “end results plots.” An end results plot is basically a <a class="reference external"href=https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.boxplot.html>box plot</a> overlay on top of a <a class="reference external"href=https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.violinplot.html>violin plot</a>.<p>Imagine that you conduct multiple runs of one algorithm on one problem instance, let’s say 50. Then you get 50 <a class="reference external"href=#log-files>log files</a> and each of them contains the best solution discovered by the corresponding run. Now you may want to know how the corresponding 50 objective values are distributed. You want to get a visual impression about this distribution. Our end results diagram provide this impression by combining two visualizations:<p>The <a class="reference external"href=https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.boxplot.html>box plot</a> in the foreground shows the<ul class=simple><li><p>the median<li><p>the 25% and 75% quantile<li><p>the 95% confidence interval around the median (as notch)<li><p>the arithmetic mean (as a triangle symbol)<li><p>whiskers at the 5% and 95% quantiles, and<li><p>the outliers on both ends of the spectrum.</ul><p>The <a class="reference external"href=https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.violinplot.html>violin plot</a> in the background tries to show the approximate distribution of the values. A violin plot is something like a smoothed-out, vertical, and mirror-symmetric histogram. Whereas you can see and compare statistical properties of the end result distribution from the box plots, you cannot really see how they are actually distributed. For example, it is not clear if the distribution is uni-modal or multi-modal. You can see this from the violins plotted in the background.<p>If you compute such plots over multiple algorithm-instance combinations, data will automatically be grouped by problem instance. This means that the violin-boxes of different algorithms on the same problem will be plotted next to each other. This, in turn, allows you to easily compare algorithm performance.<p>In order to make comparing algorithm performance over different instances easier, this plot will use scaled objective values by default. It will use the goal objective values <code class="docutils literal notranslate"><span class=pre>g</span></code> from the log files to scale all objective values <code class="docutils literal notranslate"><span class=pre>f</span></code> to <code class="docutils literal notranslate"><span class=pre>f/g</span></code>. Ofcourse you can also use it to plot raw objective values, or even runtimes if you wish.</p><a href=./_static/end_results_scaled.png> <img alt="Example for an end result plot"src=./_static/end_results_scaled.png style=width:70%;min-width:70%;max-width:70%> </a><p>In the file <a class="reference external"href=./examples/end_results_with_limits_plot_py.html>end_results_with_limits_plot.py</a>, you can find an example of the interplay of this type of plots with the “virtual” runtime limits that can be specified when parsing <a class="reference external"href=./moptipy.evaluation.html#moptipy.evaluation.end_results.EndResult><code class="docutils literal notranslate"><span class=pre>moptipy.evaluation.end_results.EndResult</span></code></a>s. Here, we run an RLS on three OneMax instances for 126 FEs per run. We then plot the result distribution that we get after 16, 32, 64, and 128 FEs in different charts inside one figure. It can be seen nicely how the end result distribution approaches 0, i.e., the optimum, more and more everytime we double runtime. All plots are generated from the same source data, which is possible since we log all the improvements during the runs. We can know what results we would be getting if we only gave 16 FEs since we know the complete progress up to 128 FEs.</p><a href=./_static/selected_end_results.png> <img alt="Example for end results plots at different time limits"src=./_static/selected_end_results.png style=width:70%;min-width:70%;max-width:70%> </a><p>The end result plots are implemented in the module <a class="reference external"href=./moptipy.evaluation.html#module-moptipy.evaluation.plot_end_results>moptipy.evaluation.plot_end_results</a>.</section><section id=ecdf-plots><h3>6.4. ECDF Plots<a title="Link to this heading"class=headerlink href=#ecdf-plots>¶</a></h3><p>In the file <a class="reference external"href=./examples/ecdf_plot_py.html>examples/ecdf_plot.py</a>, you can find some code running a small experiment and creating “ECDF plots.” The Empirical Cumulative Distribution Function (ECDF) is a plot that aggregates data over several runs of an optimization algorithm. It has the consumed runtime (in FEs or milliseconds) on its horizontal axis and the fraction of runs that succeeded in reaching a specified goal on its vertical axis. Therefore, an ECDF curve is a monotonously increasing curve: It remains 0 until the very first (fastest) run of the algorithm reaches the goal, say at time <code class="docutils literal notranslate"><span class=pre>T1</span></code>. Then, it will increase a bit every single time another run reaches the goal. At the point in time <code class="docutils literal notranslate"><span class=pre>T2</span></code> when the slowest, last run reaches the goal, it becomes <code class="docutils literal notranslate"><span class=pre>1</span></code>. Of course, if not all runs reach the goal, it can also remain at a some other level in <code class="docutils literal notranslate"><span class=pre>[0,1]</span></code>.<p>Let’s say we execute 10 runs of our algorithm on a problem instance. The ECDF remains 0 until the first run reaches the goal. At this time, it would rise to value <code class="docutils literal notranslate"><span class=pre>1/10=0.1</span></code>. Once the second run reaches the goal, it will climb to <code class="docutils literal notranslate"><span class=pre>2/10=0.2</span></code>. If <code class="docutils literal notranslate"><span class=pre>7</span></code> out of our <code class="docutils literal notranslate"><span class=pre>10</span></code> runs can solve the problem and <code class="docutils literal notranslate"><span class=pre>3</span></code> fail to do so, the ECDF would climb to <code class="docutils literal notranslate"><span class=pre>7/10=0.7</span></code> and then remain there.</p><a href=./_static/ecdf_over_log_fes.png> <img alt="Example for an ECDF plot combining statistics and single runs"src=./_static/ecdf_over_log_fes.png style=width:70%;min-width:70%;max-width:70%> </a><p>ECDF plots are implemented in the module <a class="reference external"href=./moptipy.evaluation.html#module-moptipy.evaluation.plot_ecdf>moptipy.evaluation.plot_ecdf</a>.</section><section id=expected-running-time-ert-plots><h3>6.5. Expected Running Time (ERT) Plots<a title="Link to this heading"class=headerlink href=#expected-running-time-ert-plots>¶</a></h3><p>In the file <a class="reference external"href=./examples/ert_plot_py.html>examples/ert_plot.py</a>, you can find some code running a small experiment and creating empirically estimated Expected Running Time (ERT) plots. Basically, it illustrates an estimation of the runtime that it would take in expectation to reach certain objective values. The objective values are therefore printed on the horizontal axis and the vertical axis associates an expected running time to them. This expectation is estimated based on the idea of iterated runs: Assume that you conduct an experiment with 100 runs. Now you want to know how long your algorithm needs in expectation to reach a certain goal quality <code class="docutils literal notranslate"><span class=pre>f</span></code>. However, you are unlucky: Only 30 of your runs actually reached <code class="docutils literal notranslate"><span class=pre>f</span></code>, the rest of them converged to a worse solution and stopped improving before being finally terminated. To compute the ERT, we simply assume that if a run did not succeed, we would have directly restarted our algorithm and performed a new, independent run right away. Each time we start a run, the chance to succeed is 30% as 30 of our 100 runs managed to find a solution with a quality no worse than <code class="docutils literal notranslate"><span class=pre>f</span></code>. We would do this until we finally succeed. This means that as long as at least one of our runs succeeded in the experiment, we can compute a finite ERT.<p>For any goal <code class="docutils literal notranslate"><span class=pre>f</span></code>, the <code class="docutils literal notranslate"><span class=pre>ERT</span></code> is computed as<p><code class="docutils literal notranslate"><span class=pre>ERT[f]</span> <span class=pre>=</span> <span class=pre>Time(fbest</span> <span class=pre>>=</span> <span class=pre>f)</span> <span class=pre>/</span> <span class=pre>s</span></code><p>where <code class="docutils literal notranslate"><span class=pre>s</span></code> is the number of successful runs, i.e., of runs that reached the goal <code class="docutils literal notranslate"><span class=pre>f</span></code> and <code class="docutils literal notranslate"><span class=pre>Time(fbest</span> <span class=pre>>=</span> <span class=pre>f)</span></code> is the sum of the runtime of all runs that was spent until the objective value reached <code class="docutils literal notranslate"><span class=pre>f</span></code> (or the run terminated).<p>Equipped with this understanding, we can now compute the ERT for every single objective value that was reached by any of our runs. This way, we will get a diagram similar to the one below:</p><a href=./_static/log_ert_over_f.png> <img alt="Example for an ERT plot of RLS and Random Walk on OneMax with 12 bits."src=./_static/log_ert_over_f.png style=width:70%;min-width:70%;max-width:70%> </a><p>The (empirically estimated) Expected Running Time (ERT) is nicely explained in the report <a class="reference external"href=https://hal.inria.fr/inria-00462481><em>Real-Parameter Black-Box Optimization Benchmarking 2010: Experimental Setup</em></a>. The ERT plots are implemented in the module <a class="reference external"href=./moptipy.evaluation.html#module-moptipy.evaluation.plot_ert>moptipy.evaluation.plot_ert</a>.</section><section id=ert-ecdf-plots><h3>6.6. ERT-ECDF Plots<a title="Link to this heading"class=headerlink href=#ert-ecdf-plots>¶</a></h3><p>In the file <a class="reference external"href=./examples/ertecdf_plot_py.html>examples/ertecdf_plot.py</a>, you can find some code running a small experiment and creating ERT-ECDF plots. These plots combine the concepts of <a class="reference external"href=#expected-running-time-ert-plots>ERTs</a> with <a class="reference external"href=#ecdf-plots>ECDFs</a>: Their vertical axis shows the fraction of problem instances that can be expected to be solved by an algorithm. Their horizontal axis shows the runtime consumed to do so, which is equivalent to the ERT of the algorithm to reach the global optimum. While ECDFs themselves are based on single runs, ERT-ECDF plots are based on problem instances. They also make the same assumptions as ERTs, namely that we can simply restart an algorithm if it was not successful when it had consumed all of its computational budget. Like ECDF-plots, the ERT-ECDF plots are implemented in the module <a class="reference external"href=./moptipy.evaluation.html#module-moptipy.evaluation.plot_ecdf>moptipy.evaluation.plot_ecdf</a>.</p><a href=./_static/ertecdf_over_log_fes.png> <img alt="Example for an ERT-ECDF plot of a RLS on OneMax several OneMax instances."src=./_static/ertecdf_over_log_fes.png style=width:70%;min-width:70%;max-width:70%> </a></section><section id=performance-over-algorithm-parameter-or-instance-feature><h3>6.7. Performance over Algorithm Parameter or Instance Feature<a title="Link to this heading"class=headerlink href=#performance-over-algorithm-parameter-or-instance-feature>¶</a></h3><p>Often we want to investigate how and algorithm parameter or an instance feature impacts the algorithm performance. The function <a class="reference external"href=./moptipy.evaluation.html#module-moptipy.evaluation.plot_end_statistics_over_parameter>plot_end_statistics_over_param</a> can do both:<p>In <a class="reference external"href=./examples/end_statistics_over_feature_plot_py.html>examples/end_statistics_over_feature_plot.py</a>, it is used to visualize the <a class="reference external"href=#expected-running-time-ert-plots><code class="docutils literal notranslate"><span class=pre>ERT</span></code></a> of a simple <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.rls>RLS algorithm</a> over the instance size <code class="docutils literal notranslate"><span class=pre>n</span></code> of the <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.onemax>OneMax problem</a>. Basically, the minimization version of the OneMax problem tries to minimize the number of <code class="docutils literal notranslate"><span class=pre>0</span></code>s in a bit string of length <code class="docutils literal notranslate"><span class=pre>n</span></code>. Of course, the higher <code class="docutils literal notranslate"><span class=pre>n</span></code>, the longer it will take to solve the problem. We apply the RLS several times to the instances of sizes <code class="docutils literal notranslate"><span class=pre>n</span></code> in <code class="docutils literal notranslate"><span class=pre>1..20</span></code>. We then load the end results and convert them to <a class="reference external"href=#the-end-result-statistics-file-format>end result statistics</a>. All we need to tell our system how it can deduce the value of the feature from an <a class="reference external"href=./moptipy.evaluation.html#module-moptipy.evaluation.end_statistics>EndStatistics</a> and which statistic we want to plot (here: <code class="docutils literal notranslate"><span class=pre>ertFEs</span></code>) and we are good:</p><a href=./_static/ert_over_onemax_n.png> <img alt="Example for the ERT of a RLS on OneMax plotted over the instance size n over several OneMax instances."src=./_static/ert_over_onemax_n.png style=width:70%;min-width:70%;max-width:70%> </a><p>In <a class="reference external"href=./examples/end_statistics_over_param_plot_py.html>examples/end_statistics_over_param_plot.py</a>, on the other hand, we apply the same method to analyze the impact of an algorithm parameter on the performance. We again apply an <a class="reference external"href=./moptipy.algorithms.so.html#module-moptipy.algorithms.so.rls>RLS algorithm</a> algorithm, but this time with a configurable operator, <a class="reference external"href=./moptipy.operators.bitstrings.html#module-moptipy.operators.bitstrings.op1_m_over_n_flip>Op1MoverNflip</a>, which flips each bit in a string with a probability distributed according to <code class="docutils literal notranslate"><span class=pre>Bin(m/n)</span></code>, where <code class="docutils literal notranslate"><span class=pre>n</span></code> is the total number of bits and <code class="docutils literal notranslate"><span class=pre>m</span></code> is a parameter. We apply this algorithm for different values of <code class="docutils literal notranslate"><span class=pre>m</span></code> to two instances of the minimization version of the <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.leadingones>LeadingOnes</a> problem. We plot the mean end result after 128 FEs (on the vertical axis) over the values of <code class="docutils literal notranslate"><span class=pre>m</span></code> (horizontal axis).</p><a href=./_static/mean_f_over_param.png> <img alt="Example for the mean end result quality over the algorithm parameter m of the Bin(m/n) operator plugged into the RLS algorithm on several LeadingOnes instances."src=./_static/mean_f_over_param.png style=width:70%;min-width:70%;max-width:70%> </a><p>These plots have been implemented in the module <a class="reference external"href=./moptipy.evaluation.html#module-moptipy.evaluation.plot_end_statistics_over_parameter>moptipy.evaluation.plot_end_statistics_over_parameter</a>.</section><section id=end-results-table><h3>6.8. End Results Table<a title="Link to this heading"class=headerlink href=#end-results-table>¶</a></h3><p>In the file <a class="reference external"href=./examples/end_results_table_py.html>examples/end_results_table.py</a>, you can find some code running a small experiment and creating an “end results table.” Such a table allows you to display statistics summarizing the performance of your algorithms over several problem instances. In their standard configuration, they two parts:<ol class="arabic simple"><li><p>Part 1 displays information about the algorithm-instance combinations. For each instance, it has one row per algorithm. This row displays, by default, the following information about the performance of the algorithm on the instance, aggregated over all runs:</p> <ul class=simple><li><p><code class="docutils literal notranslate"><span class=pre>I</span></code>: the instance name<li><p><code class="docutils literal notranslate"><span class=pre>lb(f)</span></code>: the lower bound of the objective value of the instance<li><p><code class="docutils literal notranslate"><span class=pre>setup</span></code>: the name of the algorithm or algorithm setup<li><p><code class="docutils literal notranslate"><span class=pre>best</span></code>: the best objective value reached by any run on that instance<li><p><code class="docutils literal notranslate"><span class=pre>mean</span></code>: the arithmetic mean of the best objective values reached over all runs<li><p><code class="docutils literal notranslate"><span class=pre>sd</span></code>: the standard deviation of the best objective values reached over all runs<li><p><code class="docutils literal notranslate"><span class=pre>mean1</span></code>: the arithmetic mean of the best objective values reached over all runs, divided by the lower bound (or goal objective value)<li><p><code class="docutils literal notranslate"><span class=pre>mean(fes)</span></code>: the arithmetic mean of the index of the last objective function evaluation (FE) which resulted in an improvement, over all runs<li><p><code class="docutils literal notranslate"><span class=pre>mean(t)</span></code>: the arithmetic mean of the time in milliseconds when the last improving move of a run was applied, over all runs</ul><li><p>The second part of the table presents one row for each algorithm with statistics aggregated over all runs on all instances. By default, it holds the following information:</p> <ul class=simple><li><p><code class="docutils literal notranslate"><span class=pre>setup</span></code>: the name of the algorithm or algorithm setup<li><p><code class="docutils literal notranslate"><span class=pre>best1</span></code>: the minimum of the best objective values reached divided by the lower bound (or goal objective value) over all runs<li><p><code class="docutils literal notranslate"><span class=pre>gmean1</span></code>: the geometric mean of the best objective values reached divided by the lower bound (or goal objective value) over all runs<li><p><code class="docutils literal notranslate"><span class=pre>worst1</span></code>: the maximum of the best objective values reached divided by the lower bound (or goal objective value) over all runs<li><p><code class="docutils literal notranslate"><span class=pre>sd1</span></code>: the standard deviation of the best objective values reached divided by the lower bound (or goal objective value) over all runs<li><p><code class="docutils literal notranslate"><span class=pre>mean(fes)</span></code>: the arithmetic mean of the index of the last objective function evaluation (FE) which resulted in an improvement, over all runs<li><p><code class="docutils literal notranslate"><span class=pre>mean(t)</span></code>: the arithmetic mean of the time in milliseconds when the last improving move of a run was applied, over all runs</ul></ol><p>For each column of each group (instances in part 1, the complete part 2), the best values are marked in <strong>bold face</strong>.<p>Tables can be rendered to different formats, such as <a class="reference external"href=./moptipy.utils.html#moptipy.utils.markdown.Markdown>Markdown</a>, <a class="reference external"href=./moptipy.utils.html#moptipy.utils.latex.LaTeX>LaTeX</a>, and <a class="reference external"href=./moptipy.utils.html#moptipy.utils.html.HTML>HTML</a>. The example <a class="reference external"href=./examples/end_results_table_py.html>examples/end_results_table.py</a>, for instance, produces the following <a class="reference external"href=./moptipy.utils.html#moptipy.utils.markdown.Markdown>Markdown</a> table:<table class="docutils align-default"><thead><tr class=row-odd><th class="head text-left"><p>I<th class="head text-right"><p>lb(f)<th class="head text-left"><p>setup<th class="head text-right"><p>best<th class="head text-right"><p>mean<th class="head text-right"><p>sd<th class="head text-right"><p>mean1<th class="head text-right"><p>mean(fes)<th class="head text-right"><p>mean(t)<tbody><tr class=row-even><td class=text-left><p><code class="docutils literal notranslate"><span class=pre>dmu23</span></code><td class=text-right><p>4’668<td class=text-left><p><code class="docutils literal notranslate"><span class=pre>hc_swap2</span></code><td class=text-right><p>6’260<td class=text-right><p>6’413.6<td class=text-right><p>191.78<td class=text-right><p>1.374<td class=text-right><p>626<td class=text-right><p>10<tr class=row-odd><td class=text-left><p><td class=text-right><p><td class=text-left><p><code class="docutils literal notranslate"><span class=pre>rls_swap2</span></code><td class=text-right><p><strong>5’886</strong><td class=text-right><p><strong>6’177.7</strong><td class=text-right><p>164.08<td class=text-right><p><strong>1.323</strong><td class=text-right><p><strong>704</strong><td class=text-right><p><strong>11</strong><tr class=row-even><td class=text-left><p><td class=text-right><p><td class=text-left><p><code class="docutils literal notranslate"><span class=pre>rs</span></code><td class=text-right><p>7’378<td class=text-right><p>7’576.6<td class=text-right><p><strong>122.78</strong><td class=text-right><p>1.623<td class=text-right><p>357<td class=text-right><p>8<tr class=row-odd><td class=text-left><p><code class="docutils literal notranslate"><span class=pre>ft06</span></code><td class=text-right><p>55<td class=text-left><p><code class="docutils literal notranslate"><span class=pre>hc_swap2</span></code><td class=text-right><p>57<td class=text-right><p>59.3<td class=text-right><p>1.25<td class=text-right><p>1.078<td class=text-right><p>133<td class=text-right><p>2<tr class=row-even><td class=text-left><p><td class=text-right><p><td class=text-left><p><code class="docutils literal notranslate"><span class=pre>rls_swap2</span></code><td class=text-right><p><strong>55</strong><td class=text-right><p><strong>57.0</strong><td class=text-right><p>1.91<td class=text-right><p><strong>1.036</strong><td class=text-right><p>333<td class=text-right><p>4<tr class=row-odd><td class=text-left><p><td class=text-right><p><td class=text-left><p><code class="docutils literal notranslate"><span class=pre>rs</span></code><td class=text-right><p>60<td class=text-right><p>60.4<td class=text-right><p><strong>0.79</strong><td class=text-right><p>1.099<td class=text-right><p><strong>651</strong><td class=text-right><p><strong>5</strong><tr class=row-even><td class=text-left><p><code class="docutils literal notranslate"><span class=pre>la24</span></code><td class=text-right><p>935<td class=text-left><p><code class="docutils literal notranslate"><span class=pre>hc_swap2</span></code><td class=text-right><p>1’122<td class=text-right><p>1’180.7<td class=text-right><p>61.74<td class=text-right><p>1.263<td class=text-right><p><strong>752</strong><td class=text-right><p>9<tr class=row-odd><td class=text-left><p><td class=text-right><p><td class=text-left><p><code class="docutils literal notranslate"><span class=pre>rls_swap2</span></code><td class=text-right><p><strong>1’078</strong><td class=text-right><p><strong>1’143.0</strong><td class=text-right><p>48.23<td class=text-right><p><strong>1.222</strong><td class=text-right><p>752<td class=text-right><p><strong>10</strong><tr class=row-even><td class=text-left><p><td class=text-right><p><td class=text-left><p><code class="docutils literal notranslate"><span class=pre>rs</span></code><td class=text-right><p>1’375<td class=text-right><p>1’404.3<td class=text-right><p><strong>26.66</strong><td class=text-right><p>1.502<td class=text-right><p>248<td class=text-right><p>3<tr class=row-odd><td class=text-left><p><td class=text-right><p><td class=text-left><p>setup<td class=text-right><p>best1<td class=text-right><p>gmean1<td class=text-right><p>worst1<td class=text-right><p>sd1<td class=text-right><p>mean(fes)<td class=text-right><p>mean(t)<tr class=row-even><td class=text-left><p>summary<td class=text-right><p><td class=text-left><p><code class="docutils literal notranslate"><span class=pre>hc_swap2</span></code><td class=text-right><p>1.036<td class=text-right><p>1.231<td class=text-right><p>1.444<td class=text-right><p>0.1<td class=text-right><p>504<td class=text-right><p>7<tr class=row-odd><td class=text-left><p>summary<td class=text-right><p><td class=text-left><p><code class="docutils literal notranslate"><span class=pre>rls_swap2</span></code><td class=text-right><p><strong>1.000</strong><td class=text-right><p><strong>1.187</strong><td class=text-right><p><strong>1.377</strong><td class=text-right><p><strong>0.1</strong><td class=text-right><p><strong>596</strong><td class=text-right><p><strong>8</strong><tr class=row-even><td class=text-left><p>summary<td class=text-right><p><td class=text-left><p><code class="docutils literal notranslate"><span class=pre>rs</span></code><td class=text-right><p>1.091<td class=text-right><p>1.389<td class=text-right><p>1.650<td class=text-right><p>0.2<td class=text-right><p>419<td class=text-right><p>5</table><p>It also produces the same table in <a class="reference external"href=./moptipy.utils.html#moptipy.utils.latex.LaTeX>LaTeX</a>:<div class="highlight-latex notranslate"><div class=highlight><pre><span></span><span class=k>\begin</span><span class=nb>{</span>tabular<span class=nb>}{</span>lrlrrrrrr<span class=nb>}</span><span class=c>%</span>
<span class=k>\hline</span><span class=c>%</span>
I<span class=nb>&</span>lb(f)<span class=nb>&</span>setup<span class=nb>&</span>best<span class=nb>&</span>mean<span class=nb>&</span>sd<span class=nb>&</span>mean1<span class=nb>&</span>mean(fes)<span class=nb>&</span>mean(t)<span class=k>\\</span><span class=c>%</span>
<span class=k>\hline</span><span class=c>%</span>
<span class=nb>{</span><span class=k>\texttt</span><span class=nb>{</span>dmu23<span class=nb>}}&</span>4'668<span class=nb>&{</span><span class=k>\texttt</span><span class=nb>{</span>hc<span class=k>\_swap</span>2<span class=nb>}}&</span>6'260<span class=nb>&</span>6'413.6<span class=nb>&</span>191.78<span class=nb>&</span>1.374<span class=nb>&</span>626<span class=nb>&</span>10<span class=k>\\</span><span class=c>%</span>
<span class=nb>&&{</span><span class=k>\texttt</span><span class=nb>{</span>rls<span class=k>\_swap</span>2<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>5'886<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>6'177.7<span class=nb>}}&</span>164.08<span class=nb>&{</span><span class=k>\textbf</span><span class=nb>{</span>1.323<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>704<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>11<span class=nb>}}</span><span class=k>\\</span><span class=c>%</span>
<span class=nb>&&{</span><span class=k>\texttt</span><span class=nb>{</span>rs<span class=nb>}}&</span>7'378<span class=nb>&</span>7'576.6<span class=nb>&{</span><span class=k>\textbf</span><span class=nb>{</span>122.78<span class=nb>}}&</span>1.623<span class=nb>&</span>357<span class=nb>&</span>8<span class=k>\\</span><span class=c>%</span>
<span class=k>\hline</span><span class=c>%</span>
<span class=nb>{</span><span class=k>\texttt</span><span class=nb>{</span>ft06<span class=nb>}}&</span>55<span class=nb>&{</span><span class=k>\texttt</span><span class=nb>{</span>hc<span class=k>\_swap</span>2<span class=nb>}}&</span>57<span class=nb>&</span>59.3<span class=nb>&</span>1.25<span class=nb>&</span>1.078<span class=nb>&</span>133<span class=nb>&</span>2<span class=k>\\</span><span class=c>%</span>
<span class=nb>&&{</span><span class=k>\texttt</span><span class=nb>{</span>rls<span class=k>\_swap</span>2<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>55<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>57.0<span class=nb>}}&</span>1.91<span class=nb>&{</span><span class=k>\textbf</span><span class=nb>{</span>1.036<span class=nb>}}&</span>333<span class=nb>&</span>4<span class=k>\\</span><span class=c>%</span>
<span class=nb>&&{</span><span class=k>\texttt</span><span class=nb>{</span>rs<span class=nb>}}&</span>60<span class=nb>&</span>60.4<span class=nb>&{</span><span class=k>\textbf</span><span class=nb>{</span>0.79<span class=nb>}}&</span>1.099<span class=nb>&{</span><span class=k>\textbf</span><span class=nb>{</span>651<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>5<span class=nb>}}</span><span class=k>\\</span><span class=c>%</span>
<span class=k>\hline</span><span class=c>%</span>
<span class=nb>{</span><span class=k>\texttt</span><span class=nb>{</span>la24<span class=nb>}}&</span>935<span class=nb>&{</span><span class=k>\texttt</span><span class=nb>{</span>hc<span class=k>\_swap</span>2<span class=nb>}}&</span>1'122<span class=nb>&</span>1'180.7<span class=nb>&</span>61.74<span class=nb>&</span>1.263<span class=nb>&{</span><span class=k>\textbf</span><span class=nb>{</span>752<span class=nb>}}&</span>9<span class=k>\\</span><span class=c>%</span>
<span class=nb>&&{</span><span class=k>\texttt</span><span class=nb>{</span>rls<span class=k>\_swap</span>2<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>1'078<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>1'143.0<span class=nb>}}&</span>48.23<span class=nb>&{</span><span class=k>\textbf</span><span class=nb>{</span>1.222<span class=nb>}}&</span>752<span class=nb>&{</span><span class=k>\textbf</span><span class=nb>{</span>10<span class=nb>}}</span><span class=k>\\</span><span class=c>%</span>
<span class=nb>&&{</span><span class=k>\texttt</span><span class=nb>{</span>rs<span class=nb>}}&</span>1'375<span class=nb>&</span>1'404.3<span class=nb>&{</span><span class=k>\textbf</span><span class=nb>{</span>26.66<span class=nb>}}&</span>1.502<span class=nb>&</span>248<span class=nb>&</span>3<span class=k>\\</span><span class=c>%</span>
<span class=k>\hline</span><span class=c>%</span>
<span class=nb>&&</span>setup<span class=nb>&</span>best1<span class=nb>&</span>gmean1<span class=nb>&</span>worst1<span class=nb>&</span>sd1<span class=nb>&</span>mean(fes)<span class=nb>&</span>mean(t)<span class=k>\\</span><span class=c>%</span>
<span class=k>\hline</span><span class=c>%</span>
summary<span class=nb>&&{</span><span class=k>\texttt</span><span class=nb>{</span>hc<span class=k>\_swap</span>2<span class=nb>}}&</span>1.036<span class=nb>&</span>1.231<span class=nb>&</span>1.444<span class=nb>&</span>0.1<span class=nb>&</span>504<span class=nb>&</span>7<span class=k>\\</span><span class=c>%</span>
summary<span class=nb>&&{</span><span class=k>\texttt</span><span class=nb>{</span>rls<span class=k>\_swap</span>2<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>1.000<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>1.187<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>1.377<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>0.1<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>596<span class=nb>}}&{</span><span class=k>\textbf</span><span class=nb>{</span>8<span class=nb>}}</span><span class=k>\\</span><span class=c>%</span>
summary<span class=nb>&&{</span><span class=k>\texttt</span><span class=nb>{</span>rs<span class=nb>}}&</span>1.091<span class=nb>&</span>1.389<span class=nb>&</span>1.650<span class=nb>&</span>0.2<span class=nb>&</span>419<span class=nb>&</span>5<span class=k>\\</span><span class=c>%</span>
<span class=k>\hline</span><span class=c>%</span>
<span class=k>\end</span><span class=nb>{</span>tabular<span class=nb>}</span><span class=c>%</span>
</pre></div></div><p>The end result tables are implemented in the module <a class="reference external"href=./moptipy.evaluation.html#module-moptipy.evaluation.tabulate_end_results>moptipy.evaluation.tabulate_end_results</a>.</section><section id=testing-end-results-for-statistically-significant-differences-table><h3>6.9. Testing End Results for Statistically Significant Differences (Table)<a title="Link to this heading"class=headerlink href=#testing-end-results-for-statistically-significant-differences-table>¶</a></h3><p>In the file <a class="reference external"href=./examples/end_results_tests_py.html>examples/end_results_tests.py</a>, you can find some code running a small experiment and creating a table of statistical end result tests. In such a table, a set of algorithms is compared pairwise on a set of problem instances using the two-tailed Mann-Whitney U test with the Bonferroni correction.<p>The output in markdown of the table generated in <a class="reference external"href=./examples/end_results_tests_py.html>examples/end_results_tests.py</a> looks as follows:<table class="docutils align-default"><thead><tr class=row-odd><th class="head text-right"><p>Mann-Whitney U $\alpha$=0.02, $\alpha$’=1.111*10^-3^<th class="head text-center"><p><code class="docutils literal notranslate"><span class=pre>rls_flip1</span></code> vs. <code class="docutils literal notranslate"><span class=pre>rls_flipB1</span></code><th class="head text-center"><p><code class="docutils literal notranslate"><span class=pre>rls_flip1</span></code> vs. <code class="docutils literal notranslate"><span class=pre>rls_flipB2</span></code><th class="head text-center"><p><code class="docutils literal notranslate"><span class=pre>rls_flipB1</span></code> vs. <code class="docutils literal notranslate"><span class=pre>rls_flipB2</span></code><tbody><tr class=row-even><td class=text-right><p><code class="docutils literal notranslate"><span class=pre>leadingones_100</span></code><td class=text-center><p>9.286*10^-2^ <code class="docutils literal notranslate"><span class=pre>?</span></code><td class=text-center><p>8.820*10^-5^ <code class="docutils literal notranslate"><span class=pre>></span></code><td class=text-center><p>3.746*10^-3^ <code class="docutils literal notranslate"><span class=pre>?</span></code><tr class=row-odd><td class=text-right><p><code class="docutils literal notranslate"><span class=pre>leadingones_200</span></code><td class=text-center><p>—<td class=text-center><p>1.078*10^-2^ <code class="docutils literal notranslate"><span class=pre>?</span></code><td class=text-center><p>2.713*10^-2^ <code class="docutils literal notranslate"><span class=pre>?</span></code><tr class=row-even><td class=text-right><p><code class="docutils literal notranslate"><span class=pre>onemax_100</span></code><td class=text-center><p>4.343*10^-4^ <code class="docutils literal notranslate"><span class=pre><</span></code><td class=text-center><p>5.307*10^-7^ <code class="docutils literal notranslate"><span class=pre><</span></code><td class=text-center><p>8.539*10^-3^ <code class="docutils literal notranslate"><span class=pre>?</span></code><tr class=row-odd><td class=text-right><p><code class="docutils literal notranslate"><span class=pre>onemax_200</span></code><td class=text-center><p>2.096*10^-5^ <code class="docutils literal notranslate"><span class=pre><</span></code><td class=text-center><p>2.463*10^-7^ <code class="docutils literal notranslate"><span class=pre><</span></code><td class=text-center><p>1.783*10^-3^ <code class="docutils literal notranslate"><span class=pre>?</span></code><tr class=row-even><td class=text-right><p><code class="docutils literal notranslate"><span class=pre>trap_100</span></code><td class=text-center><p>2.035*10^-6^ <code class="docutils literal notranslate"><span class=pre><</span></code><td class=text-center><p>2.813*10^-8^ <code class="docutils literal notranslate"><span class=pre><</span></code><td class=text-center><p>1.250*10^-4^ <code class="docutils literal notranslate"><span class=pre><</span></code><tr class=row-odd><td class=text-right><p><code class="docutils literal notranslate"><span class=pre>trap_200</span></code><td class=text-center><p>2.627*10^-3^ <code class="docutils literal notranslate"><span class=pre>?</span></code><td class=text-center><p>1.649*10^-6^ <code class="docutils literal notranslate"><span class=pre><</span></code><td class=text-center><p>2.453*10^-3^ <code class="docutils literal notranslate"><span class=pre>?</span></code><tr class=row-even><td class=text-right><p><code class="docutils literal notranslate"><span class=pre><</span></code> / <code class="docutils literal notranslate"><span class=pre>?</span></code> / <code class="docutils literal notranslate"><span class=pre>></span></code><td class=text-center><p>3/3/0<td class=text-center><p>4/1/1<td class=text-center><p>1/5/0</table><p>As you can see, we compare three algorithms, <code class="docutils literal notranslate"><span class=pre>rls_flip1</span></code>, <code class="docutils literal notranslate"><span class=pre>rls_flipB1</span></code>, and <code class="docutils literal notranslate"><span class=pre>rls_flipB2</span></code>, on six problem instances, the 100 and 200 bit versions of the <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.leadingones><code class="docutils literal notranslate"><span class=pre>LeadingOnes</span></code></a>, <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.onemax><code class="docutils literal notranslate"><span class=pre>OneMax</span></code></a>, and <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.trap><code class="docutils literal notranslate"><span class=pre>Trap</span></code></a>, problems. For each algorithm pair on each instance, a two-sided Mann-Whitey U test is applied. This test computes the probability <code class="docutils literal notranslate"><span class=pre>p</span></code> that the observed difference in performance (here: end result qualities) of the two compared algorithms would occur <em>if</em> the two algorithms would perform exactly the same. In other words, if <code class="docutils literal notranslate"><span class=pre>p</span></code> is high, the chance that any apparent difference in performance just stems from randomness is high. If one algorithm was better than the other <em>and</em> <code class="docutils literal notranslate"><span class=pre>p</span></code> is sufficiently small, then be confident that it truly is better. We therefore define a significance threshold <code class="docutils literal notranslate"><span class=pre>alpha</span></code>, an upper limit for <code class="docutils literal notranslate"><span class=pre>p</span></code> that we deem acceptable. In other words, <code class="docutils literal notranslate"><span class=pre>alpha</span></code> is the limit for the probability to be wrong when claiming that one algorithm is better than the other that we are going to accept. Since we perform multiple test, <code class="docutils literal notranslate"><span class=pre>alpha'=alpha/n_tests</span></code> is computed, i.e., the Bonferroni correction is applied. We use <code class="docutils literal notranslate"><span class=pre>alpha'</span></code> as actual threshold to ensure that the probability that <em>any</em> of our <code class="docutils literal notranslate"><span class=pre>n_tests</span></code> statements is wrong is <code class="docutils literal notranslate"><span class=pre><=alpha</span></code>.<p>The first column of the table contains the problem instances. Each other column holds the <code class="docutils literal notranslate"><span class=pre>p</span></code> value, together with the signs <code class="docutils literal notranslate"><span class=pre><</span></code>, <code class="docutils literal notranslate"><span class=pre>?</span></code>, and <code class="docutils literal notranslate"><span class=pre><</span></code>.<p>-<code class="docutils literal notranslate"><span class=pre><</span></code> means that the performance metric of the first algorithm had both <em>smaller</em> mean and median values compared to the second algorithm and <code class="docutils literal notranslate"><span class=pre>p&LTalpha'</span></code>.<ul class=simple><li><p><code class="docutils literal notranslate"><span class=pre>></span></code> means that the performance metric of the first algorithm had both <em>larger</em> mean and median values compared to the second algorithm and <code class="docutils literal notranslate"><span class=pre>p&LTalpha'</span></code>.<li><p><code class="docutils literal notranslate"><span class=pre>?</span></code> means that, while one of the two algorithms had a smaller mean and median value, <code class="docutils literal notranslate"><span class=pre>p>=alpha'</span></code>, i.e., the observed difference was not significant.<li><p>A cell with a dash (—) inside denotes that the two compared algorithms either had the same mean and median performance, or one was better in mean and the other was better in median. Even if we would conduct a statistical test, it would be meaningless to claim that either of the two algorithms was better.</ul><p>The bottom row of the table sums up the numbers of <code class="docutils literal notranslate"><span class=pre><</span></code>, <code class="docutils literal notranslate"><span class=pre>?</span></code>, and <code class="docutils literal notranslate"><span class=pre>></span></code> outcomes for each algorithm pair.<p>The end result comparison tables are implemented in the module <a class="reference external"href=./moptipy.evaluation.html#module-moptipy.evaluation.tabulate_result_tests>moptipy.evaluation.tabulate_result_tests</a>.</section></section><section id=examples><h2>7. Examples<a title="Link to this heading"class=headerlink href=#examples>¶</a></h2><p>Here we list the set of examples that are provided in the <a class="reference external"href=https://github.com/thomasWeise/moptipy>moptipy</a> repository in the folder “<a class="reference external"href=https://github.com/thomasWeise/moptipy/tree/main/examples>examples</a>”.<ul class=simple><li><p><a class="reference external"href=./examples/continuous_optimization_py.html>continuous_optimization.py</a> applies a set of numerical/continuous optimization algorithms to a simple problem and prints their results.<li><p><a class="reference external"href=./examples/continuous_optimization_with_logging_py.html>continuous_optimization_with_logging.py</a> is exactly the same example, but this time log files are created and their contents are printed for each run.<li><p><a class="reference external"href=./examples/ecdf_plot_py.html>ecdf_plot.py</a> runs a small experiment on the <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.onemax><code class="docutils literal notranslate"><span class=pre>OneMax</span></code></a> problem and plots the <a class="reference external"href=#ecdf-plots>ECDF</a>.<li><p><a class="reference external"href=./examples/end_results_jssp_py.html>end_results_jssp.py</a> runs a small experiment with on the Job Shop Scheduling Problem (JSSP) and generates an <a class="reference external"href=#end-result-csv-files>end results CSV file</a>.<li><p><a class="reference external"href=./examples/end_results_plot_py.html>end_results_plot.py</a> applies two algorithms to the JSSP and creates <a class="reference external"href=#end-results-plot>plots of end results</a>.<li><p><a class="reference external"href=./examples/end_results_table_py.html>end_results_table.py</a> runs another small experiment on the JSSP and generates a <a class="reference external"href=#end-results-table>table of end results</a>.<li><p><a class="reference external"href=./examples/end_results_tests_py.html>end_results_tests.py</a> runs a small experiment on bit string search spaces and generates a <a class="reference external"href=#testing-end-results-for-statistically-significant-differences-table>table with statistical comprisons of end results</a>.<li><p><a class="reference external"href=./examples/end_results_with_limits_plot_py.html>end_results_with_limits_plot.py</a> runs a small experiment with one algorithm on three <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.onemax><code class="docutils literal notranslate"><span class=pre>OneMax</span></code></a> instances and collects the whole algorithm progress in the log files. It then plots <a class="reference external"href=#end-results-plot>plots of end results</a> for different runtime limits.<li><p><a class="reference external"href=./examples/end_statistics_jssp_py.html>end_statistics_jssp.py</a> runs a small experiment on the JSSP and generates an <a class="reference external"href=#end-result-statistics-csv-files>end statistics CSV file</a>.<li><p><a class="reference external"href=./examples/end_statistics_over_feature_plot_py.html>end_statistics_over_feature_plot.py</a> solves several <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.onemax><code class="docutils literal notranslate"><span class=pre>OneMax</span></code></a> instances and plots the ERT over the problem scale, i.e., generates a <a class="reference external"href=#performance-over-algorithm-parameter-or-instance-feature>performance-over-feature plot</a>.<li><p><a class="reference external"href=./examples/end_statistics_over_param_plot_py.html>end_statistics_over_param_plot.py</a> applies different settings of an algorithm to LeadingOnes instances and plots their <a class="reference external"href=#performance-over-algorithm-parameter-or-instance-feature>performance over their parameter setting</a>.<li><p><a class="reference external"href=./examples/ert_plot_py.html>ert_plot.py</a> applies an algorithm to the <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.onemax><code class="docutils literal notranslate"><span class=pre>OneMax</span></code></a> and plots the <a class="reference external"href=#expected-running-time-ert-plots>ERT</a> over the solution qualities.<li><p><a class="reference external"href=./examples/ertecdf_plot_py.html>ertecdf_plot.py</a> applies one algorithm to several <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.onemax><code class="docutils literal notranslate"><span class=pre>OneMax</span></code></a> instances and creates an <a class="reference external"href=#ert-ecdf-plots>ERT-ECDF plot</a>.<li><p><a class="reference external"href=./examples/experiment_2_algorithms_4_problems_py.html>experiment_2_algorithms_4_problems.py</a> shows how to use the <a class="reference external"href=#how-to-run-a-series-of-experiments>structured experiment API</a> and applies two algorithms to four problem instances (<a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.onemax><code class="docutils literal notranslate"><span class=pre>OneMax</span></code></a> and LeadingOnes).<li><p><a class="reference external"href=./examples/experiment_own_algorithm_and_problem_py.html>experiment_own_algorithm_and_problem.py</a> shows how to <a class="reference external"href=#applying-an-own-algorithm-to-an-own-problem>implement</a> some of the core components of our API, namely how a <a class="reference external"href=#define-a-new-algorithm>self-implemented algorithm</a> can be applied to a <a class="reference external"href=#define-a-new-problem-type>self-implemented problem</a>.<li><p><a class="reference external"href=./examples/log_file_jssp_py.html>log_file_jssp.py</a> showcases the <a class="reference external"href=#log-files>log file structure</a> for single-objective optimization.<li><p><a class="reference external"href=./examples/mo_example_py.html>mo_example.py</a> is a simple example for multi-objective optimization: we apply multi-objective RLS to a multi-objective version of the JSSP.<li><p><a class="reference external"href=./examples/mo_example_nsga2_py.html>mo_example_nsga2.py</a> the same simple example for multi-objective optimization, but this time using the popular NSGA-II algorithm, which works out better than our multi-objective RLS.<li><p><a class="reference external"href=./examples/mo_example_nsga2_bits_py.html>mo_example_nsga2_bits.py</a> another example of NSGA-II solving a multi-objective optimization problem, this time over the space of the bit strings.<li><p>The package <a class="reference external"href=./moptipy.examples.jssp_py.html><code class="docutils literal notranslate"><span class=pre>moptipy.examples.jssp</span></code></a> contains a complete experiment on the Job Shop Scheduling Problem (JSSP) together with its evaluation routines, making up an epxerimental part of the book <a class="reference external"href=https://thomasweise.github.io/oa>“Optimization Algorithms”</a>.<li><p><a class="reference external"href=./examples/progress_plot_py.html>progress_plot.py</a> shows how <a class="reference external"href=#progress-plots>progress plots</a> can be generated from a small experiment with the <a class="reference external"href=./moptipy.examples.bitstrings.html#module-moptipy.examples.bitstrings.onemax><code class="docutils literal notranslate"><span class=pre>OneMax</span></code></a> problem and the 1-dimensional Ising model.<li><p><a class="reference external"href=./examples/single_run_rls_onemax_py.html>single_run_rls_onemax.py</a> shows how we can perform a <a class="reference external"href=#how-to-apply-1-optimization-algorithm-once-to-1-problem-instance>single run of a single algorithm on a single problem instance</a>.</ul></section><section id=more-features><h2>8. More Features<a title="Link to this heading"class=headerlink href=#more-features>¶</a></h2><section id=unit-tests-and-static-analysis><h3>8.1. Unit Tests and Static Analysis<a title="Link to this heading"class=headerlink href=#unit-tests-and-static-analysis>¶</a></h3><p>When developing and applying randomized algorithms, proper testing and checking of the source code is of utmost importance. If we apply a randomized metaheuristic to an optimization problem, then we usually do not which solution quality we can achieve. Therefore, we can usually not know whether we have implemented the algorithm correctly. In other words, detecting bugs is very hard. Unfortunately, this holds also for the components of the algorithms, such as the search operators, especially if they are randomized as well. A bug may lead to worse results and we might not even notice that the worse result quality is caused by the bug. We may think that the algorithm is just not working well on the problem.<p>Therefore, we need to test all components of the algorithm as far as we can. We can try check, for example, if a randomized nullary search operator indeed creates different solutions when invoked several times. We can try to check whether an algorithm fails with an exception. We can try to check whether the search operators create valid solutions and whether the algorithm passes valid solutions to the objective function. We can try to whether an objective function produces finite objective values and if bounds are specified for the objective values, we can check whether they indeed fall within these bounds. Now we cannot prove that there are no such bugs, due to the randomization. But by testing a few hundred times, we can at least detect very obvious and pathological bugs.<p>To ease such testing for you, we provide a set of tools for testing implemented algorithms, spaces, and operators in the package <a class="reference external"href=./moptipy.tests.html>moptipy.tests</a>. Here, you can find functions where you pass in instances of your implemented components and they are checked for compliance with the <a class="reference external"href=./moptipy.api.html>moptipy API</a>. In other words, if you go and implement your own algorithms, operators, and optimization problems, you can use our pre-defined unit tests to give them a thorough check before using them in production. Again, such tests cannot prove the absence of bugs. But they can at least give you a fair shot to detect pathological errors before wasting serious experimentation time.<p>We also try to extensively test our own code, see the <a class="reference external"href=./tc/index.html>coverage report</a>.<p>Examples for the variety of testing tools provided are:<ul class=simple><li><p><a class="reference external"href=./moptipy.tests.html#moptipy.tests.component.validate_component><code class="docutils literal notranslate"><span class=pre>validate_component</span></code></a> checks whether an object is a valid <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> <a class="reference external"href=./moptipy.api.html#module-moptipy.api.component>component</a> (which is the base class of all <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> objects). It tests whether the conversion to string yields a valid name without invalid characters and whether <a class="reference external"href=./moptipy.api.html#moptipy.api.component.Component.log_parameters_to>logging</a> of the component parameters works.<li><p><a class="reference external"href=./moptipy.tests.html#moptipy.tests.algorithm.validate_algorithm><code class="docutils literal notranslate"><span class=pre>validate_algorithm</span></code></a> first checks if an <a class="reference external"href=./moptipy.api.html#moptipy.api.algorithm.Algorithm>algorithm</a> is valid <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> component and then applies it to a (user-provided) example problem. It checks whether this works without exception, whether the computational budget is used correctly, and whether any inconsistencies in the final solution can be detected.<li><p><a class="reference external"href=./moptipy.tests.html#moptipy.tests.mo_algorithm.validate_mo_algorithm><code class="docutils literal notranslate"><span class=pre>validate_mo_algorithm</span></code></a> is the <a class="reference external"href=./moptipy.api.html#moptipy.api.mo_algorithm.MOAlgorithm>multi-objective</a> version of <code class="docutils literal notranslate"><span class=pre>validate_algorithm</span></code>.<li><p><a class="reference external"href=./moptipy.tests.html#moptipy.tests.objective.validate_objective><code class="docutils literal notranslate"><span class=pre>validate_objective</span></code></a> checks whether an <a class="reference external"href=./moptipy.api.html#moptipy.api.objective.Objective>objective function</a> is implemented consistently, i.e., if its upper and lower bound are valid, if the result of evaluating some random solutions falls within these bounds, if it really only returns integers if it <a class="reference external"href=./moptipy.api.html#moptipy.api.objective.Objective.is_always_integer>claims to do so</a>, if it returns the same objective value for the same solution, and so on.<li><p><a class="reference external"href=./moptipy.tests.html#moptipy.tests.encoding.validate_encoding><code class="docutils literal notranslate"><span class=pre>validate_encoding</span></code></a> checks whether an <a class="reference external"href=./moptipy.api.html#module-moptipy.api.encoding>encoding</a> is implemented consistently.<li><p><a class="reference external"href=./moptipy.tests.html#moptipy.tests.op0.validate_op0><code class="docutils literal notranslate"><span class=pre>validate_op0</span></code></a>, <a class="reference external"href=./moptipy.tests.html#moptipy.tests.op1.validate_op1><code class="docutils literal notranslate"><span class=pre>validate_op1</span></code></a>, and <a class="reference external"href=./moptipy.tests.html#moptipy.tests.op2.validate_op2><code class="docutils literal notranslate"><span class=pre>validate_op2</span></code></a> check whether <a class="reference external"href=./moptipy.api.html#moptipy.api.operators.Op0>nullary</a>, <a class="reference external"href=./moptipy.api.html#moptipy.api.operators.Op1>unary</a>, and <a class="reference external"href=./moptipy.api.html#moptipy.api.operators.Op2>binary</a> operators are implemented consistently, respectively.<li><p><a class="reference external"href=./moptipy.tests.html#moptipy.tests.space.validate_space><code class="docutils literal notranslate"><span class=pre>validate_space</span></code></a> checks whether an object is a consistent implementation of a <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> <a class="reference external"href=./moptipy.api.html#moptipy.api.space.Space><code class="docutils literal notranslate"><span class=pre>Space</span></code></a>.</ul><p>There are also a set of pre-defined objectives, encodings, and spaces that can be used as shortcuts so that you do not need to specify them manually for the different <code class="docutils literal notranslate"><span class=pre>validate_*</span></code> routines. You can test elements on<ul class=simple><li><p><a class="reference external"href=./moptipy.tests.html#module-moptipy.tests.on_bitstrings>bit string</a>-based problems,<li><p><a class="reference external"href=./moptipy.tests.html#module-moptipy.tests.on_permutations>permutation</a>-based problems, or on<li><p>the <a class="reference external"href=./moptipy.tests.html#module-moptipy.tests.on_jssp>JSSP</a></ul><p>Another way to try to improve and maintain code quality is to use static code analysis and type hints where possible and reasonable. A static analysis tool can inform you about, e.g., unused variables, which often result from a coding error. It can tell you if the types of expressions do not match, which usually indicates a coding error, too. It can tell you if you perform some security-wise unsafe operations (which is less often a problem in optimization, but it does not hurt to check). Code analysis tools can also help you to enforce best practices, which are good for performance, readability, and maintainability. They can push you to properly format and document your code, which, too, improve readability, maintainability, and usability. They even can detect a set of well-known and frequently-occurring bugs. We use the <a class="reference external"href=https://thomasweise.github.io/pycommons/#unified-build-process-pycommons-dev-building>pycommons unified build process</a> which also run a variety of such tools on our code base.<p>On git pushes, GitHub also automatically runs <a class="reference external"href=https://codeql.github.com>CodeQL</a> to check for common vulnerabilities and coding errors. We also turned on GitHub’s <a class="reference external"href=https://docs.github.com/en/code-security/security-advisories/repository-security-advisories/configuring-private-vulnerability-reporting-for-a-repository>private vulnerability reporting</a> and the Dependabot <a class="reference external"href=https://docs.github.com/en/code-security/dependabot/dependabot-alerts/configuring-dependabot-alerts>vulnerability</a> and <a class="reference external"href=https://docs.github.com/en/code-security/dependabot/dependabot-security-updates/configuring-dependabot-security-updates>security</a> alerts.<p>Using all of these tools increases the build time. However, combined with thorough unit testing and documentation, it should help to prevent bugs, to improve readability, maintainability, and usability of the code. It does not matter whether we are doing research or try to solve practical problems in the industry — we should always strive to make good software with high code quality.<p>Often, researchers in particular think that hacking something together that works is enough, that documentation is unimportant, that code style best practices can be ignored, and so on. And then they wonder why they cannot understand their own code a few years down the line (at least, this happened to me in the past…). Or why no one can use their code to build atop of their research (which is the normal case for me).<p>Improving code quality can <em>never</em> come later. We <em>always</em> must maintain high coding and documentation standards from the very beginning. While <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> may still be far from achieving these goals, at least we try to get there.<p>Anyway, you can find our <a class="reference external"href=./make_sh.html>full <code class="docutils literal notranslate"><span class=pre>make.sh</span></code> build script</a> running all the tests, doing all the static analyses, creating the documentation, and creating and packaging the distribution files <a class="reference external"href=./make_sh.html>here</a>. As said, it basically uses the <a class="reference external"href=https://thomasweise.github.io/pycommons/#unified-build-process-pycommons-dev-building>pycommons unified build process</a>. The build only works under Linux.</section><section id=reproducibility><h3>8.2. Reproducibility<a title="Link to this heading"class=headerlink href=#reproducibility>¶</a></h3><p>Experiments with <a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> are reproducible and repeatable (according to the <a class="reference external"href=https://www.acm.org/publications/policies/artifact-review-and-badging-current>ACM definition</a>) if the results are recorded in <a class="reference external"href=#log-files>log files</a>. As stated in the <a class="reference external"href=#log-files>log files section</a>, our log files should store all the information relevant to a single run of an optimization algorithm. First, the log files can store the complete <a class="reference external"href=#the-section-setup>algorithm setups and objective function information</a> as well as the involved fully-qualified class names. They also store the <a class="reference external"href=#the-section-sys_info>system configuration</a>, which includes the versions of the libraries used. This should allow to re-create algorithm setups and system configuration.<p>Each run of the optimization algorithms on every problem instance is provided with a seeded <a class="reference external"href=https://numpy.org/doc/stable/reference/random/generator.html>random number generator</a> via <a class="reference external"href=./moptipy.api.html#moptipy.api.process.Process.get_random><code class="docutils literal notranslate"><span class=pre>process.get_random()</span></code></a>. This must be the <em>only</em> source of randomness used in the algorithms. In other words, every algorithm must be deterministic and make the same decisions on the same problem instance with the same sequence of random numbers provided by this generator. The random seed using the generator as well as the <a class="reference external"href=https://numpy.org><code class="docutils literal notranslate"><span class=pre>numpy</span></code></a> classes of the generator and the <code class="docutils literal notranslate"><span class=pre>numpy</span></code> version are all stored in the <a class="reference external"href=#log-files>log files</a>. The random seed for a new run can be set via the <a class="reference external"href=./moptipy.api.html#moptipy.api.execution.Execution><code class="docutils literal notranslate"><span class=pre>Execution</span></code></a> builder object. Therefore, if a given algorithm configuration can be re-created on a known instance, it can be started with the same random seed as a known run. Since the version information and classes of all involved libraries in the random number generation are stored as well, the same random number sequences can be reproduced.<p>The solutions found by the algorithms are also stored in the log files. Therefore, it is also possible to re-evaluate and verify them as well.<p>Additionally, if the <a class="reference external"href=./moptipy.api.html#module-moptipy.api.experiment>experiment API</a> is used, then the random seeds are <a class="reference external"href=./moptipy.utils.html#moptipy.utils.nputils.rand_seeds_from_str>determined based on the instance names</a>. This means that all algorithms will use the same seeds for each instance, while different problem instances will lead to different seeds. This, in turn, means that the algorithms start with the same first random solutions (if they use the same <a class="reference external"href=./moptipy.api.html#moptipy.api.operators.Op0>nullary operator</a>). It also means that if you run the same experiment program twice, the same random seeds will be used automatically. In other words, if you have the complete code of a <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> compliant experiment, it should (re)produce the exactly same runs with the exactly same results.</section><section id=parallel-and-distributed-experiments><h3>8.3. Parallel and Distributed Experiments<a title="Link to this heading"class=headerlink href=#parallel-and-distributed-experiments>¶</a></h3><p>Experiments can be parallelized based on <em>runs</em>, where one run is the application of one algorithm to one problem instance. While each run is still executed sequentially, multiple runs can be executed in parallel. For executing experiments, the method <a class="reference external"href=./moptipy.api.html#moptipy.api.experiment.run_experiment><code class="docutils literal notranslate"><span class=pre>run_experiment</span></code></a> from module <a class="reference external"href=./moptipy.api.html#module-moptipy.api.experiment><code class="docutils literal notranslate"><span class=pre>moptipy.api.experiment</span></code></a> is used, as explained in <a class="reference external"href=#how-to-run-a-series-of-experiments>Section 3.2</a>.<p>It creates the log file and folder structure discussed in <a class="reference external"href=#file-names-and-folder-structure>Section 5.1.1.</a> in a replicable way. This means that if you run the method twice, it would create exactly the same experiment with exactly the same file and folder names. Since the file and folder structure is repeatable, <code class="docutils literal notranslate"><span class=pre>run_experiment</span></code> will simply skip all runs that are associated with log files which already exist. Before doing a run, the system will create the corresponding (empty) log file. This means that you could launch the experiment program twice in parallel. Each process would then do about half of the runs, because it will skip the runs for which the log files have been created by the other process. (It also means that if your experiment crashes, you can simply delete all zero-sized files and start again to continue it.)<p>You can achieve distributed experiment executing by simply sharing the folder for the log files between the machines. If you use a shared root folder for experiments and launch the same experiment on multiple machines, they will automatically distribute the work load amongst each other using this very (and therefore very robust) simple system.</section></section><section id=useful-links-and-references><h2>9. Useful Links and References<a title="Link to this heading"class=headerlink href=#useful-links-and-references>¶</a></h2><section id=links-regarding-the-moptipy-project><h3>9.1. Links regarding the <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> project<a title="Link to this heading"class=headerlink href=#links-regarding-the-moptipy-project>¶</a></h3><ul class=simple><li><p>A small presentation about <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> is provided at <a class="reference external"href=http://thomasweise.github.io/talks/moptipy.pdf>http://thomasweise.github.io/talks/moptipy.pdf</a>.<li><p>Our project can be found on GitHub at <a class="reference external"href=https://github.com/thomasWeise/moptipy>https://github.com/thomasWeise/moptipy</a><li><p>The documentation of our project is available at <./>.<li><p>A companion project with several classical Operations Research example problem domains can be found on GitHub at <a class="reference external"href=https://github.com/thomasWeise/moptipyapps>https://github.com/thomasWeise/moptipyapps</a> and its documentation is given at <./apps>.<li><p>Our <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> library can be found on PyPi at <a class="reference external"href=https://pypi.org/project/moptipy>https://pypi.org/project/moptipy</a><li><p>Our <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> library can be found on Libraries.io at <a class="reference external"href=https://libraries.io/pypi/moptipy>https://libraries.io/pypi/moptipy</a>, however, this page usually does not show the most recent version.<li><p>Our <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> library can be found on snyk.io at <a class="reference external"href=https://snyk.io/advisor/python/moptipy>https://snyk.io/advisor/python/moptipy</a>, however, this page usually does not show the most recent version.<li><p>An old example data set of experimental results obtained with <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> can be found at <a class="reference external"href=https://thomasweise.github.io/oa_data>https://thomasweise.github.io/oa_data</a>.</ul></section><section id=links-to-other-works-of-our-team><h3>9.2. Links to other works of our team<a title="Link to this heading"class=headerlink href=#links-to-other-works-of-our-team>¶</a></h3><ol class="arabic simple"><li><p>Our old book optimization algorithms: Thomas Weise. <a class="reference external"href=https://www.researchgate.net/publication/200622167><em>Global Optimization Algorithms - Theory and Application</em></a>.</ol></section><section id=other-python-libraries-of-optimization-algorithms><h3>9.3. Other Python Libraries of Optimization Algorithms<a title="Link to this heading"class=headerlink href=#other-python-libraries-of-optimization-algorithms>¶</a></h3><p>Here we provide a very incomplete list of other Python software packages that can be used for solving optimization problems (in alphabetical order). A much better list maintained by <a class="reference external"href=https://ktafakkori.github.io>Keivan Tafakkori</a> can be found <a class="reference external"href=https://ktafakkori.github.io/blog/optimization-packages-in-python-list>here</a>.<ul class=simple><li><p><a class="reference external"href=https://github.com/CyberAgent/cmaes><code class="docutils literal notranslate"><span class=pre>cmaes</span></code></a> provides implementations of Covariance Matrix Adaptation Evolution Strategies for solving continuous optimization problems. It is maintained by Masashi Shibata and Masahiro Nomura and available at <a class="reference external"href=https://pypi.org/project/cmaes/>https://pypi.org/project/cmaes/</a> and <a class="reference external"href=https://github.com/CyberAgent/cmaes>https://github.com/CyberAgent/cmaes</a>. We wrap several of the algorithms into our <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> API in module <a class="reference external"href=./moptipy.algorithms.so.vector.html#module-moptipy.algorithms.so.vector.cmaes_lib><code class="docutils literal notranslate"><span class=pre>moptipy.algorithms.so.vector.cmaes_lib</span></code></a>.<li><p><a class="reference external"href=https://github.com/DEAP/deap><code class="docutils literal notranslate"><span class=pre>deap</span></code></a> is a novel evolutionary computation framework for rapid prototyping and testing of ideas by Félix-Antoine Fortin, François-Michel De Rainville, Marc-André Gardner, Marc Parizeau, and Christian Gagné. It offers a rich set of evolutionary computation-based metaheuristics and a straightforward API. You can find it on GitHub at <a class="reference external"href=https://github.com/DEAP/deap>https://github.com/DEAP/deap</a>.<li><p><a class="reference external"href=https://pypi.org/project/inspyred><code class="docutils literal notranslate"><span class=pre>inspyred</span></code></a> and <a class="reference external"href=https://pypi.org/project/ecspy><code class="docutils literal notranslate"><span class=pre>ecspy</span></code></a> are open source packages for nature-inspired optimization by Aaron Garrett.<li><p><a class="reference external"href=https://facebookresearch.github.io/nevergrad><code class="docutils literal notranslate"><span class=pre>nevergrad</span></code></a> by Facebook Research offers gradient free optimization and implements a variety of numerical optimization methods and many benchmark problems.<li><p><a class="reference external"href=https://github.com/schlatterbeck/pgapy><code class="docutils literal notranslate"><span class=pre>pgapy</span></code></a> by Ralf Schlatterbeck provides a Python wrapper the <a class="reference external"href=https://github.com/schlatterbeck/pgapack>PGAPack</a> Parallel Genetic Algorithm Library. It can be found on GitHub at <a class="reference external"href=https://github.com/schlatterbeck/pgapy>https://github.com/schlatterbeck/pgapy</a>.<li><p><a class="reference external"href=https://scipy.org><code class="docutils literal notranslate"><span class=pre>scipy</span></code></a> offers a set of well-established mathematical optimization techniques for continuous optimization via the function <a class="reference external"href=https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html><code class="docutils literal notranslate"><span class=pre>scipy.optimize.minimize</span></code></a>. We wrap some of them into our <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> API in module <a class="reference external"href=./moptipy.algorithms.so.vector.html#module-moptipy.algorithms.so.vector.scipy><code class="docutils literal notranslate"><span class=pre>algorithms.so.vector.scipy</span></code></a>.</ul></section><section id=links-to-related-works-and-tools-by-other-researchers><h3>9.4. Links to related works and tools by other researchers<a title="Link to this heading"class=headerlink href=#links-to-related-works-and-tools-by-other-researchers>¶</a></h3><ol class="arabic simple"><li><p>The <a class="reference external"href=https://iohprofiler.github.io>IOHprofiler</a> is a nice piece of open source software for analyzing the performance of optimization algorithms. It is possible to <a class="reference external"href=#export-to-iohanalyzer>convert</a> our <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> <a class="reference external"href=#file-names-and-folder-structure>log data</a> to the format understood by the IOHanalyzer, which allows you to use this software to analyze your optimization results as well. You can then upload the data to the online IOHanalyzer service and evaluate it.<li><p>A nice discussion of experimentation with (numerical) optimization methods is: Nikolaus Hansen, Anne Auger, Steffen Finck, Raymond Ros. <a class="reference external"href=https://hal.inria.fr/inria-00462481><em>Real-Parameter Black-Box Optimization Benchmarking 2010: Experimental Setup</em></a>. Research Report RR-7215, INRIA. 2010. inria-00462481</ol></section></section><section id=publications-on-moptipy-and-works-using-moptipy><h2>10. Publications on <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> and Works using <code class="docutils literal notranslate"><span class=pre>moptipy</span></code><a title="Link to this heading"class=headerlink href=#publications-on-moptipy-and-works-using-moptipy>¶</a></h2><ul class=simple><li><p>Thomas Weise (汤卫思) and Zhize Wu (吴志泽). <em>Replicable Self-Documenting Experiments with Arbitrary Search Spaces and Algorithms.</em> In: Conference on Genetic and Evolutionary Computation (GECCO’2023), Companion Volume. July 15–19, 2023, Lisbon, Portugal. Ed. by Sara Silva and Luís Paquete. New York, NY, USA: Association for Computing Machinery (ACM), 2023, pp. 1891–1899. ISBN: 979-8-4007-0120-7. doi:<a class="reference external"href=https://doi.org/10.1145/3583133.3596306>10.1145/3583133.3596306</a>.<li><p>Tianyu Liang (梁天宇), Zhize Wu (吴志泽), Jörg Lässig, Daan van den Berg, and Thomas Weise (汤卫思). <em>Solving the Traveling Salesperson Problem using Frequency Fitness Assignment.</em> IEEE Symposium Series on Computational Intelligence (SSCI’2022). Dec. 4–7, 2022, Singapore. Piscataway, NJ, USA: Institute of Electrical and Electronics Engineers (IEEE), 2022. ISBN: 978-1-6654-8769-6. doi:<a class="reference external"href=https://doi.org/10.1109/SSCI51031.2022.10022296>10.1109/SSCI51031.2022.10022296</a>.<li><p>Newsletter of the ACM Special Interest Group on Genetic and Evolutionary Computation. Volume 16, Issue 4, December 2023, Software Category. moptipy: the Metaheuristic Optimization in Python Library. <a class="reference external"href=https://sigevo.hosting.acm.org/public_html/sigevolution/2023/12/04/volume-16-issue-4>https://sigevo.hosting.acm.org/public_html/sigevolution/2023/12/04/volume-16-issue-4</a>.<li><p>Tianyu Liang (梁天宇), Zhize Wu (吴志泽), Jörg Lässig, Daan van den Berg, Sarah Louise Thomson, and Thomas Weise (汤卫思). <em>Addressing the Traveling Salesperson Problem with Frequency Fitness Assignment and Hybrid Algorithms.</em> Soft Computing 28(17-18):9495–9508, July 2024. London, England, UK: Springer Nature Limited. ISSN: 1432-7643. doi:<a class="reference external"href=https://doi.org/10.1007/S00500-024-09718-8>10.1007/S00500-024-09718-8</a>.<li><p>Rui Zhao (赵睿), Tianyu Liang (梁天宇), Zhize Wu (吴志泽), Daan van den Berg, Matthias Thürer, and Thomas Weise (汤卫思). <em>Randomized Local Search on the 2D Rectangular Bin Packing Problem with Item Rotation.</em> In: Genetic and Evolutionary Computation Conference (GECCO’2024). July 14–18, 2024, Melbourne, VIC, Australia. Ed. by Xiaodong Li and Julia Handl. New York, NY, USA: Association for Computing Machinery (ACM), 2024, pp. 235–238. ISBN:979-8-4007-0494-9. doi:<a class="reference external"href=https://doi.org/10.1145/3638530.3654139>10.1145/3638530.3654139</a>.<li><p>Sarah Louise Thomson, Gabriela Ochoa, Daan van den Berg, Tianyu Liang (梁天宇), and Thomas Weise (汤卫思). <em>Entropy, Search Trajectories, and Explainability for Frequency Fitness Assignment.</em> In: Parallel Problem Solving from Nature (PPSN XVIII). Vol. 1. Sept. 14–18, 2024, Hagenberg, Mühlkreis, Austria. Ed. by Michael Affenzeller, Stephan M. Winkler, Anna V. Kononova, Heike Trautmann, Tea Tušar, Penousal Machado, and Thomas Bäck. Vol. 15148 of Lecture Notes in Computer Science (LNCS). Cham, Switzerland: Springer. ISSN: 0302-9743. ISBN: 978-3-031-70054-5. doi:<a class="reference external"href=https://doi.org/10.1007/978-3-031-70055-2_23>10.1007/978-3-031-70055-2_23</a>.<li><p>Jiayang Chen (陈嘉阳), Zhize Wu (吴志泽), Sarah Louise Thomson, and Thomas Weise (汤卫思). <em>Frequency Fitness Assignment: Optimization Without Bias for Good Solution Outperforms Randomized Local Search on the Quadratic Assignment Problem.</em> 16th International Joint Conference on Computational Intelligence (IJCCI’24). Nov. 20–22, 2024, Porto, Portugal. Ed. by Francesco Marcelloni, Kurosh Madani, Niki van Stein, and Joaquim Filipe. Porto, Portugal: SciTePress: Science and Technology Publications, Lda, 2024, pp. 27–37. ISSN: 2184-3236. ISBN: 978-989-758-721-4. doi:<a class="reference external"href=https://doi.org/10.5220/0012888600003837>10.5220/0012888600003837</a>.<li><p>Tianyu Liang (梁天宇), Zhize Wu (吴志泽), Matthias Thürer, Markus Wagner, and Thomas Weise (汤卫思). <em>Generating Small Instances with Interesting Features for the Traveling Salesperson Problem.</em> In: 16th International Joint Conference on Computational Intelligence (IJCCI’24). Nov. 20–22, 2024, Porto, Portugal. Ed. by Francesco Marcelloni, Kurosh Madani, Niki van Stein, and Joaquim Filipe. Porto, Portugal: SciTePress: Science and Technology Publications, Lda, 2024, pp. 173–180. ISSN: 2184-3236. ISBN: 978-989-758-721-4. doi:<a class="reference external"href=https://doi.org/10.5220/0012888800003837>10.5220/0012888800003837</a>.<li><p>CAO Xiang (曹翔), Zhize Wu (吴志泽), Daan van den Berg, and Thomas Weise (汤卫思). <em>Randomized Local Search vs. NSGA-II vs. Frequency Fitness Assignment on The Traveling Tournament Problem.</em> In: 16th International Joint Conference on Computational Intelligence (IJCCI’24). Nov. 20–22, 2024, Porto, Portugal. Ed. by Francesco Marcelloni, Kurosh Madani, Niki van Stein, and Joaquim Filipe. Porto, Portugal: SciTePress: Science and Technology Publications, Lda, 2024, pp. 38–49. ISSN: 2184-3236. ISBN: 978-989-758-721-4. doi:<a class="reference external"href=https://doi.org/10.5220/0012891500003837>10.5220/0012891500003837</a>.<li><p>Rui Zhao (赵睿), Zhize Wu (吴志泽), Daan van den Berg, Matthias Thürer, Tianyu Liang (梁天宇), Ming Tan (檀明), and Thomas Weise (汤卫思). <em>Randomized Local Search for Two-Dimensional Bin Packing and a Negative Result for Frequency Fitness Assignment.</em> In: 16th International Joint Conference on Computational Intelligence (IJCCI’24). Nov. 20–22, 2024, Porto, Portugal. Ed. by Francesco Marcelloni, Kurosh Madani, Niki van Stein, and Joaquim Filipe. Porto, Portugal: SciTePress: Science and Technology Publications, Lda, 2024, pp. 15–26. ISSN: 2184-3236. ISBN: 978-989-758-721-4. doi:<a class="reference external"href=https://doi.org/10.5220/0012888500003837>10.5220/0012888500003837</a>.</ul></section><section id=license><h2>11. License<a title="Link to this heading"class=headerlink href=#license>¶</a></h2><p><a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> is a library for implementing, using, and experimenting with metaheuristic optimization algorithms. Our project is developed for scientific, educational, and industrial applications.<p>Copyright (C) 2021-2026 <a class="reference external"href=https://thomasweise.github.io>Thomas Weise</a> (汤卫思教授)<p>Dr. <a class="reference external"href=https://thomasweise.github.io>Thomas Weise</a> (see <a class="reference external"href=#contact>Contact</a>) holds the copyright of this package <em>except</em> for the JSSP instance data in file <a class="reference external"href=https://github.com/thomasWeise/moptipy/blob/main/moptipy/examples/jssp/instances.txt><code class="docutils literal notranslate"><span class=pre>moptipy/examples/jssp/instances.txt</span></code></a>.<p><code class="docutils literal notranslate"><span class=pre>moptipy</span></code> is provided to the public as open source software under the <a class="reference external"href=./LICENSE.html>GNU GENERAL PUBLIC LICENSE, Version 3, 29 June 2007</a>. Terms for other licenses, e.g., for specific industrial applications, can be negotiated with Dr. Thomas Weise (who can be reached via the <a class="reference external"href=#contact>contact information</a> below).<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <a class="reference external"href=https://www.gnu.org/licenses/>https://www.gnu.org/licenses/</a>.<p>Please visit the <a class="reference external"href=./CONTRIBUTING_md.html>contributions guidelines</a> for <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> if you would like to contribute to our package. If you have any concerns regarding security, please visit our <a class="reference external"href=./SECURITY_md.html>security policy</a>.</section><section id=contact><h2>12. Contact<a title="Link to this heading"class=headerlink href=#contact>¶</a></h2><p>If you have any questions or suggestions, please contact Prof. Dr. <a class="reference external"href=https://thomasweise.github.io>Thomas Weise</a> (汤卫思教授) of the School of Artificial Intelligence and Big Data (<a class="reference external"href=http://www.hfuu.edu.cn/aibd>人工智能与大数据学院</a>) at <a class="reference external"href=http://www.hfuu.edu.cn/english>Hefei University</a> (<a class="reference external"href=http://www.hfuu.edu.cn>合肥大学</a>) in Hefei, Anhui, China (中国安徽省合肥市) via email to <a class="reference external"href=mailto:tweise%40hfuu.edu.cn>tweise<span>@</span>hfuu<span>.</span>edu<span>.</span>cn</a> with CC to <a class="reference external"href=mailto:tweise%40ustc.edu.cn>tweise<span>@</span>ustc<span>.</span>edu<span>.</span>cn</a>.</section><section id=modules-and-code><h2>13. Modules and Code<a title="Link to this heading"class=headerlink href=#modules-and-code>¶</a></h2><div class="toctree-wrapper compound"><ul><li class=toctree-l1><a class="reference internal"href=modules.html>moptipy</a><ul><li class=toctree-l2><a class="reference internal"href=moptipy.html>moptipy package</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.html#subpackages>Subpackages</a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.html>moptipy.algorithms package</a><li class=toctree-l4><a class="reference internal"href=moptipy.api.html>moptipy.api package</a><li class=toctree-l4><a class="reference internal"href=moptipy.evaluation.html>moptipy.evaluation package</a><li class=toctree-l4><a class="reference internal"href=moptipy.examples.html>moptipy.examples package</a><li class=toctree-l4><a class="reference internal"href=moptipy.mo.html>moptipy.mo package</a><li class=toctree-l4><a class="reference internal"href=moptipy.mock.html>moptipy.mock package</a><li class=toctree-l4><a class="reference internal"href=moptipy.operators.html>moptipy.operators package</a><li class=toctree-l4><a class="reference internal"href=moptipy.spaces.html>moptipy.spaces package</a><li class=toctree-l4><a class="reference internal"href=moptipy.tests.html>moptipy.tests package</a><li class=toctree-l4><a class="reference internal"href=moptipy.utils.html>moptipy.utils package</a></ul><li class=toctree-l3><a class="reference internal"href=moptipy.html#submodules>Submodules</a><li class=toctree-l3><a class="reference internal"href=moptipy.html#module-moptipy.version>moptipy.version module</a></ul></ul></ul></div></section></section><div class=clearer></div></div></div></div><div aria-label=Main class=sphinxsidebar role=navigation><div class=sphinxsidebarwrapper><div><h3><a href=#>Table of Contents</a></h3><ul><li><a class="reference internal"href=#>moptipy: Metaheuristic Optimization in Python</a><ul><li><a class="reference internal"href=#introduction>1. Introduction</a><li><a class="reference internal"href=#installation>2. Installation</a><li><a class="reference internal"href=#how-tos>3. How-Tos</a><ul><li><a class="reference internal"href=#how-to-apply-1-optimization-algorithm-once-to-1-problem-instance>3.1. How to Apply 1 Optimization Algorithm Once to 1 Problem Instance</a><li><a class="reference internal"href=#how-to-run-a-series-of-experiments>3.2. How to Run a Series of Experiments</a><li><a class="reference internal"href=#how-to-solve-an-optimization-problem>3.3. How to Solve an Optimization Problem</a><ul><li><a class="reference internal"href=#define-a-new-problem-type>3.3.1. Define a New Problem Type</a><li><a class="reference internal"href=#define-a-new-algorithm>3.3.2. Define a New Algorithm</a><li><a class="reference internal"href=#applying-an-own-algorithm-to-an-own-problem>3.3.3. Applying an Own Algorithm to an Own Problem</a></ul></ul><li><a class="reference internal"href=#implemented-algorithms-search-spaces-and-problems>4. Implemented Algorithms, Search Spaces, and Problems</a><ul><li><a class="reference internal"href=#implemented-algorithms>4.1. Implemented Algorithms</a><ul><li><a class="reference internal"href=#single-objective-optimization>4.1.1. Single-Objective Optimization</a><ul><li><a class="reference internal"href=#single-objective-optimization-with-arbitrary-search-spaces>4.1.1.1. Single-Objective Optimization with Arbitrary Search Spaces</a><li><a class="reference internal"href=#single-objective-optimization-with-continuous-search-space>4.1.1.2. Single-Objective Optimization with Continuous Search Space</a></ul><li><a class="reference internal"href=#multi-objective-optimization>4.1.2. Multi-Objective Optimization</a></ul><li><a class="reference internal"href=#implemented-search-spaces-and-operators>4.2. Implemented Search Spaces and Operators</a><li><a class="reference internal"href=#implemented-problems>4.3. Implemented Problems</a></ul><li><a class="reference internal"href=#data-formats>5. Data Formats</a><ul><li><a class="reference internal"href=#log-files>5.1. Log Files</a><ul><li><a class="reference internal"href=#file-names-and-folder-structure>5.1.1. File Names and Folder Structure</a><li><a class="reference internal"href=#log-file-sections>5.1.2. Log File Sections</a><ul><li><a class="reference internal"href=#the-section-progress>5.1.2.1 The Section <code class="docutils literal notranslate"><span class=pre>PROGRESS</span></code></a><li><a class="reference internal"href=#the-section-state>5.1.2.2 The Section <code class="docutils literal notranslate"><span class=pre>STATE</span></code></a><li><a class="reference internal"href=#the-section-setup>5.1.2.3 The Section <code class="docutils literal notranslate"><span class=pre>SETUP</span></code></a><li><a class="reference internal"href=#the-section-sys-info>5.1.2.4 The Section <code class="docutils literal notranslate"><span class=pre>SYS_INFO</span></code></a><li><a class="reference internal"href=#the-result-sections>5.1.2.5 The <code class="docutils literal notranslate"><span class=pre>RESULT</span></code> Sections</a><li><a class="reference internal"href=#the-error-sections>5.1.2.6 The <code class="docutils literal notranslate"><span class=pre>ERROR</span></code> Sections</a><li><a class="reference internal"href=#the-archive-qualities-section>5.1.2.7 The <code class="docutils literal notranslate"><span class=pre>ARCHIVE_QUALITIES</span></code> Section</a><li><a class="reference internal"href=#the-archive-j-x-and-archive-j-y-sections>5.1.2.8 The <code class="docutils literal notranslate"><span class=pre>ARCHIVE_j_X</span></code> and <code class="docutils literal notranslate"><span class=pre>ARCHIVE_j_Y</span></code> Sections</a></ul><li><a class="reference internal"href=#example-for-single-objective-optimization>5.1.3. Example for Single-Objective Optimization</a><li><a class="reference internal"href=#example-log-file-for-multi-objective-optimization>5.1.4. Example Log File for Multi-Objective Optimization</a></ul><li><a class="reference internal"href=#end-result-csv-files>5.2. End Result CSV Files</a><ul><li><a class="reference internal"href=#the-end-results-file-format>5.2.1. The End Results File Format</a><li><a class="reference internal"href=#an-example-for-end-results-files>5.2.2. An Example for End Results Files</a></ul><li><a class="reference internal"href=#end-result-statistics-csv-files>5.3. End Result Statistics CSV Files</a><ul><li><a class="reference internal"href=#the-end-result-statistics-file-format>5.3.1. The End Result Statistics File Format</a><li><a class="reference internal"href=#example-for-end-result-statistics-files>5.3.2. Example for End Result Statistics Files</a></ul></ul><li><a class="reference internal"href=#evaluating-experiments>6. Evaluating Experiments</a><ul><li><a class="reference internal"href=#exporting-data>6.1. Exporting Data</a><ul><li><a class="reference internal"href=#export-to-csv-formats-for-excel-et-al>6.1.1. Export to CSV Formats for Excel et al.</a><li><a class="reference internal"href=#export-to-iohanalyzer>6.1.2 Export to IOHanalyzer</a></ul><li><a class="reference internal"href=#progress-plots>6.2. Progress Plots</a><li><a class="reference internal"href=#end-results-plot>6.3. End Results Plot</a><li><a class="reference internal"href=#ecdf-plots>6.4. ECDF Plots</a><li><a class="reference internal"href=#expected-running-time-ert-plots>6.5. Expected Running Time (ERT) Plots</a><li><a class="reference internal"href=#ert-ecdf-plots>6.6. ERT-ECDF Plots</a><li><a class="reference internal"href=#performance-over-algorithm-parameter-or-instance-feature>6.7. Performance over Algorithm Parameter or Instance Feature</a><li><a class="reference internal"href=#end-results-table>6.8. End Results Table</a><li><a class="reference internal"href=#testing-end-results-for-statistically-significant-differences-table>6.9. Testing End Results for Statistically Significant Differences (Table)</a></ul><li><a class="reference internal"href=#examples>7. Examples</a><li><a class="reference internal"href=#more-features>8. More Features</a><ul><li><a class="reference internal"href=#unit-tests-and-static-analysis>8.1. Unit Tests and Static Analysis</a><li><a class="reference internal"href=#reproducibility>8.2. Reproducibility</a><li><a class="reference internal"href=#parallel-and-distributed-experiments>8.3. Parallel and Distributed Experiments</a></ul><li><a class="reference internal"href=#useful-links-and-references>9. Useful Links and References</a><ul><li><a class="reference internal"href=#links-regarding-the-moptipy-project>9.1. Links regarding the <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> project</a><li><a class="reference internal"href=#links-to-other-works-of-our-team>9.2. Links to other works of our team</a><li><a class="reference internal"href=#other-python-libraries-of-optimization-algorithms>9.3. Other Python Libraries of Optimization Algorithms</a><li><a class="reference internal"href=#links-to-related-works-and-tools-by-other-researchers>9.4. Links to related works and tools by other researchers</a></ul><li><a class="reference internal"href=#publications-on-moptipy-and-works-using-moptipy>10. Publications on <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> and Works using <code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a><li><a class="reference internal"href=#license>11. License</a><li><a class="reference internal"href=#contact>12. Contact</a><li><a class="reference internal"href=#modules-and-code>13. Modules and Code</a></ul></ul></div><div><h4>Next topic</h4><p class=topless><a title="next chapter"href=modules.html>moptipy</a></div><div aria-label="source link"role=note><h3>This Page</h3><ul class=this-page-menu><li><a href=_sources/index.rst.txt rel=nofollow>Show Source</a></ul></div><search id=searchbox role=search style=display:none> <h3 id=searchlabel>Quick search</h3> <div class=searchformwrapper><form action=search.html class=search><input aria-labelledby=searchlabel autocapitalize=off autocomplete=off autocorrect=off name=q spellcheck=false><input type=submit value=Go></form></div> </search><script>document.getElementById(`searchbox`).style.display=`block`;</script></div></div><div class=clearer></div></div><div aria-label=Related class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="General Index"href=genindex.html>index</a><li class=right><a title="Python Module Index"href=py-modindex.html>modules</a> |<li class=right><a href=modules.html title=moptipy>next</a> |<li class="nav-item nav-item-0"><a href=#>moptipy 0.9.172 documentation</a> »<li class="nav-item nav-item-this"><a href>moptipy: Metaheuristic Optimization in Python</a></ul></div><div class=footer role=contentinfo>© Copyright 2022-2026, Thomas Weise.</div>
