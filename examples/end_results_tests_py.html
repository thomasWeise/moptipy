<!doctype html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd"><title></title><meta content="text/html; charset=utf-8"http-equiv=content-type><style>pre{line-height:125%}td.linenos .normal,span.linenos{color:inherit;background-color:#0000;padding-left:5px;padding-right:5px}td.linenos .special,span.linenos.special{color:#000;background-color:#ffffc0;padding-left:5px;padding-right:5px}body .hll{background-color:#ffc}body{background:#f8f8f8}body .c{color:#3d7b7b;font-style:italic}body .err{border:1px solid red}body .k{color:green;font-weight:700}body .o{color:#666}body .ch,body .cm{color:#3d7b7b;font-style:italic}body .cp{color:#9c6500}body .cpf,body .c1,body .cs{color:#3d7b7b;font-style:italic}body .gd{color:#a00000}body .ge{font-style:italic}body .ges{font-style:italic;font-weight:700}body .gr{color:#e40000}body .gh{color:navy;font-weight:700}body .gi{color:#008400}body .go{color:#717171}body .gp{color:navy;font-weight:700}body .gs{font-weight:700}body .gu{color:purple;font-weight:700}body .gt{color:#04d}body .kc,body .kd,body .kn{color:green;font-weight:700}body .kp{color:green}body .kr{color:green;font-weight:700}body .kt{color:#b00040}body .m{color:#666}body .s{color:#ba2121}body .na{color:#687822}body .nb{color:green}body .nc{color:#00f;font-weight:700}body .no{color:#800}body .nd{color:#a2f}body .ni{color:#717171;font-weight:700}body .ne{color:#cb3f38;font-weight:700}body .nf{color:#00f}body .nl{color:#767600}body .nn{color:#00f;font-weight:700}body .nt{color:green;font-weight:700}body .nv{color:#19177c}body .ow{color:#a2f;font-weight:700}body .w{color:#bbb}body .mb,body .mf,body .mh,body .mi,body .mo{color:#666}body .sa,body .sb,body .sc,body .dl{color:#ba2121}body .sd{color:#ba2121;font-style:italic}body .s2{color:#ba2121}body .se{color:#aa5d1f;font-weight:700}body .sh{color:#ba2121}body .si{color:#a45a77;font-weight:700}body .sx{color:green}body .sr{color:#a45a77}body .s1{color:#ba2121}body .ss{color:#19177c}body .bp{color:green}body .fm{color:#00f}body .vc,body .vg,body .vi,body .vm{color:#19177c}body .il{color:#666}</style><body><h2></h2><div class=highlight><pre><span></span><span class=sd>"""</span>
<span class=sd>Apply 3 algorithms on 6 problems for 21 runs and compare results with tests.</span>

<span class=sd>We apply three algorithms to six problem instances and conduct 31 runs per</span>
<span class=sd>instance-algorithm combination. We then apply the two-tailed Mann-Whitney U</span>
<span class=sd>test pairwise to the results and print its outcomes in a table.</span>

<span class=sd>Such a statistical test can tell us how likely the observed difference between</span>
<span class=sd>two sets of results would have occurred if the results would stem from the</span>
<span class=sd>same algorithm. If this `p`-value is small, then the two sets are likely to</span>
<span class=sd>stem from differently-performing algorithms. In order to decide whether or not</span>
<span class=sd>a `p`-value is small enough, it is compared to a significance threshold</span>
<span class=sd>`alpha`, which is set to `alpha=0.02` by default. In other words, `alpha` is</span>
<span class=sd>the maximum probability of "being wrong" that we will accept. However, since</span>
<span class=sd>we are performing more than one test, we need to adjust `alpha`. We therefore</span>
<span class=sd>use the Bonferroni correction, which sets `alpha'=alpha/n_texts`, where</span>
<span class=sd>`n_tests` is the number of conducted tests.</span>

<span class=sd>The first column of the table denotes the problem instances. Each of the other</span>
<span class=sd>three columns represents a pair of algorithms. In each cell, the pair is</span>
<span class=sd>compared based on the results on the instance of the row. The cell ten holds</span>
<span class=sd>the `p`-value of the two-tailed Mann-Whitney U test. If the first algorithm</span>
<span class=sd>is significantly better (at `p&LTalpha'`) than the second algorithm, then the</span>
<span class=sd>cell is marked with `<`. If the first algorithm is significantly worse (at</span>
<span class=sd>`p&LTalpha'`) than the second algorithm, then the cell is marked with `>`. If</span>
<span class=sd>the observed differences are not significant (`p>=alpha'`), then the cell</span>
<span class=sd>is marked with `?`.</span>

<span class=sd>Finally, the bottom row sums up the numbers of `<`, `?`, and `>` outcomes for</span>
<span class=sd>each algorithm pair.</span>

<span class=sd>However, there could also be a situation where a statistical comparison makes</span>
<span class=sd>no sense as no difference could reliably be detected anyway. For example, if</span>
<span class=sd>one algorithm has a smaller median result but a larger mean result, or if the</span>
<span class=sd>medians are the same, or if the means are the same. Regardless of what outcome</span>
<span class=sd>a test would have, we could not really claim that any of the algorithms was</span>
<span class=sd>better or worse. In such cases, no test is performed and `-` is printed</span>
<span class=sd>instead (signified by `&ampmdash;` in the markdown format).</span>
<span class=sd>"""</span>
<span class=kn>from</span><span class=w> </span><span class=nn>pycommons.io.temp</span><span class=w> </span><span class=kn>import</span> <span class=n>temp_dir</span>

<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.algorithms.so.rls</span><span class=w> </span><span class=kn>import</span> <span class=n>RLS</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.api.execution</span><span class=w> </span><span class=kn>import</span> <span class=n>Execution</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.api.experiment</span><span class=w> </span><span class=kn>import</span> <span class=n>run_experiment</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.evaluation.end_results</span><span class=w> </span><span class=kn>import</span> <span class=n>from_logs</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.evaluation.tabulate_result_tests</span><span class=w> </span><span class=kn>import</span> <span class=n>tabulate_result_tests</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.bitstrings.leadingones</span><span class=w> </span><span class=kn>import</span> <span class=n>LeadingOnes</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.bitstrings.onemax</span><span class=w> </span><span class=kn>import</span> <span class=n>OneMax</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.bitstrings.trap</span><span class=w> </span><span class=kn>import</span> <span class=n>Trap</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.bitstrings.op0_random</span><span class=w> </span><span class=kn>import</span> <span class=n>Op0Random</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.bitstrings.op1_flip1</span><span class=w> </span><span class=kn>import</span> <span class=n>Op1Flip1</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.bitstrings.op1_m_over_n_flip</span><span class=w> </span><span class=kn>import</span> <span class=n>Op1MoverNflip</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.spaces.bitstrings</span><span class=w> </span><span class=kn>import</span> <span class=n>BitStrings</span>

<span class=c1># The six problems we want to try to solve:</span>
<span class=n>problems</span> <span class=o>=</span> <span class=p>[</span><span class=k>lambda</span><span class=p>:</span> <span class=n>OneMax</span><span class=p>(</span><span class=mi>100</span><span class=p>),</span>  <span class=c1># 100-dimensional OneMax</span>
            <span class=k>lambda</span><span class=p>:</span> <span class=n>OneMax</span><span class=p>(</span><span class=mi>200</span><span class=p>),</span>  <span class=c1># 200-dimensional OneMax</span>
            <span class=k>lambda</span><span class=p>:</span> <span class=n>Trap</span><span class=p>(</span><span class=mi>100</span><span class=p>),</span>  <span class=c1># 100-dimensional Trap</span>
            <span class=k>lambda</span><span class=p>:</span> <span class=n>Trap</span><span class=p>(</span><span class=mi>200</span><span class=p>),</span>  <span class=c1># 200-dimensional Trap</span>
            <span class=k>lambda</span><span class=p>:</span> <span class=n>LeadingOnes</span><span class=p>(</span><span class=mi>100</span><span class=p>),</span>  <span class=c1># 100-dimensional LeadingOnes</span>
            <span class=k>lambda</span><span class=p>:</span> <span class=n>LeadingOnes</span><span class=p>(</span><span class=mi>200</span><span class=p>)]</span>  <span class=c1># 200-dimensional LeadingOnes</span>


<span class=k>def</span><span class=w> </span><span class=nf>rls</span><span class=p>(</span><span class=n>problem</span><span class=p>,</span> <span class=n>op1</span><span class=p>)</span> <span class=o>-></span> <span class=n>Execution</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Create an RLS Execution.</span>

<span class=sd>    :param problem: the problem (OneMax, Trap, or LeadingOnes)</span>
<span class=sd>    :param op1: the unary operator to use</span>
<span class=sd>    :returns: the execution</span>
<span class=sd>    """</span>
    <span class=k>return</span> <span class=n>Execution</span><span class=p>()</span><span class=o>.</span><span class=n>set_solution_space</span><span class=p>(</span><span class=n>BitStrings</span><span class=p>(</span><span class=n>problem</span><span class=o>.</span><span class=n>n</span><span class=p>))</span> \
        <span class=o>.</span><span class=n>set_objective</span><span class=p>(</span><span class=n>problem</span><span class=p>)</span><span class=o>.</span><span class=n>set_algorithm</span><span class=p>(</span>
        <span class=n>RLS</span><span class=p>(</span><span class=n>Op0Random</span><span class=p>(),</span> <span class=n>op1</span><span class=p>))</span><span class=o>.</span><span class=n>set_max_fes</span><span class=p>(</span><span class=mi>300</span><span class=p>)</span>


<span class=c1># We execute the whole experiment in a temp directory.</span>
<span class=c1># For a real experiment, you would put an existing directory path into `td` by</span>
<span class=c1># doing `from pycommons.io.path import Path; td = Path("mydir")` and not use</span>
<span class=c1># the `with` block.</span>
<span class=k>with</span> <span class=n>temp_dir</span><span class=p>()</span> <span class=k>as</span> <span class=n>td</span><span class=p>:</span>  <span class=c1># create temporary directory `td`</span>
    <span class=n>run_experiment</span><span class=p>(</span>
        <span class=n>base_dir</span><span class=o>=</span><span class=n>td</span><span class=p>,</span>  <span class=c1># set the base directory for log files</span>
        <span class=n>instances</span><span class=o>=</span><span class=n>problems</span><span class=p>,</span>  <span class=c1># define the problem instances</span>
        <span class=n>setups</span><span class=o>=</span><span class=p>[</span><span class=k>lambda</span> <span class=n>p</span><span class=p>:</span> <span class=n>rls</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>Op1Flip1</span><span class=p>()),</span>  <span class=c1># RLS + flip 1 bit</span>
                <span class=k>lambda</span> <span class=n>p</span><span class=p>:</span> <span class=n>rls</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>Op1MoverNflip</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>n</span><span class=p>,</span> <span class=mi>1</span><span class=p>)),</span>  <span class=c1># flip bits at p=1/n</span>
                <span class=k>lambda</span> <span class=n>p</span><span class=p>:</span> <span class=n>rls</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>Op1MoverNflip</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>n</span><span class=p>,</span> <span class=mi>2</span><span class=p>)),</span>  <span class=c1># flip bits at p=2/n</span>
                <span class=p>],</span> <span class=n>n_runs</span><span class=o>=</span><span class=mi>21</span><span class=p>)</span>  <span class=c1># conduct 21 independent runs per setup</span>

    <span class=n>end_results</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>from_logs</span><span class=p>(</span><span class=n>td</span><span class=p>))</span>  <span class=c1># we will load the data into this list</span>

    <span class=c1># create a markdown table with statistical test results</span>
    <span class=n>file</span> <span class=o>=</span> <span class=n>tabulate_result_tests</span><span class=p>(</span><span class=n>end_results</span><span class=p>,</span> <span class=n>dir_name</span><span class=o>=</span><span class=n>td</span><span class=p>)</span>
    <span class=nb>print</span><span class=p>(</span><span class=s2>"</span><span class=se>\n</span><span class=s2>"</span><span class=p>)</span>
    <span class=nb>print</span><span class=p>(</span><span class=n>file</span><span class=o>.</span><span class=n>read_all_str</span><span class=p>())</span>  <span class=c1># and print it</span>

<span class=c1># The temp directory is deleted as soon as we leave the `with` block.</span>
</pre></div>
