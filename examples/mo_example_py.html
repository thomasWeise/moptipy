<!doctype html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd"><title></title><meta content="text/html; charset=utf-8"http-equiv=content-type><style>pre{line-height:125%}td.linenos .normal,span.linenos{color:inherit;background-color:#0000;padding-left:5px;padding-right:5px}td.linenos .special,span.linenos.special{color:#000;background-color:#ffffc0;padding-left:5px;padding-right:5px}body .hll{background-color:#ffc}body{background:#f8f8f8}body .c{color:#3d7b7b;font-style:italic}body .err{border:1px solid red}body .k{color:green;font-weight:700}body .o{color:#666}body .ch,body .cm{color:#3d7b7b;font-style:italic}body .cp{color:#9c6500}body .cpf,body .c1,body .cs{color:#3d7b7b;font-style:italic}body .gd{color:#a00000}body .ge{font-style:italic}body .ges{font-style:italic;font-weight:700}body .gr{color:#e40000}body .gh{color:navy;font-weight:700}body .gi{color:#008400}body .go{color:#717171}body .gp{color:navy;font-weight:700}body .gs{font-weight:700}body .gu{color:purple;font-weight:700}body .gt{color:#04d}body .kc,body .kd,body .kn{color:green;font-weight:700}body .kp{color:green}body .kr{color:green;font-weight:700}body .kt{color:#b00040}body .m{color:#666}body .s{color:#ba2121}body .na{color:#687822}body .nb{color:green}body .nc{color:#00f;font-weight:700}body .no{color:#800}body .nd{color:#a2f}body .ni{color:#717171;font-weight:700}body .ne{color:#cb3f38;font-weight:700}body .nf{color:#00f}body .nl{color:#767600}body .nn{color:#00f;font-weight:700}body .nt{color:green;font-weight:700}body .nv{color:#19177c}body .ow{color:#a2f;font-weight:700}body .w{color:#bbb}body .mb,body .mf,body .mh,body .mi,body .mo{color:#666}body .sa,body .sb,body .sc,body .dl{color:#ba2121}body .sd{color:#ba2121;font-style:italic}body .s2{color:#ba2121}body .se{color:#aa5d1f;font-weight:700}body .sh{color:#ba2121}body .si{color:#a45a77;font-weight:700}body .sx{color:green}body .sr{color:#a45a77}body .s1{color:#ba2121}body .ss{color:#19177c}body .bp{color:green}body .fm{color:#00f}body .vc,body .vg,body .vi,body .vm{color:#19177c}body .il{color:#666}</style><body><h2></h2><div class=highlight><pre><span></span><span class=sd>"""</span>
<span class=sd>A simple example for multi-objective optimization.</span>

<span class=sd>We implement a simple multi-objective version of the Job Shop Scheduling</span>
<span class=sd>Problem (JSSP). In a JSSP, we have `n` jobs and `m` machines. Each job</span>
<span class=sd>needs to be processed by each of the machines in a specific order and needs</span>
<span class=sd>a specific time on each of them. Solutions are schedules that assign these</span>
<span class=sd>operations to the machines. The time that a schedule needs until all the</span>
<span class=sd>operations are completed is called the "makespan." Usually, the goal is to</span>
<span class=sd>find the schedule with the shortest possible makespan. However, here we also</span>
<span class=sd>consider a second goal: the total "worktime." When a machine receives its</span>
<span class=sd>first operation to process, it is turned on. It remains on until it finishes</span>
<span class=sd>its last job, after which it is turned off. The time between switching it on</span>
<span class=sd>and off be the worktime of the machine and the total "worktime" be the sum of</span>
<span class=sd>all of these worktimes.</span>

<span class=sd>In our multi-objective version of the JSSP, we want to find schedules that</span>
<span class=sd>have both a short makespan and a short worktime. In this situation, there may</span>
<span class=sd>be more than one solution: One schedule may have a shorter makespan but a</span>
<span class=sd>longer worktime and another one may have a longer worktime and a shorter</span>
<span class=sd>makespan. We call such solutions mutually non-dominated. (One solution</span>
<span class=sd>dominates another one if it is better in at least one objective and not worse</span>
<span class=sd>in all the others.)</span>

<span class=sd>In this example, we apply a multi-objective version of the randomized local</span>
<span class=sd>search algorithm, `morls`.</span>
<span class=sd>"""</span>

<span class=kn>from</span><span class=w> </span><span class=nn>pycommons.io.temp</span><span class=w> </span><span class=kn>import</span> <span class=n>temp_file</span>

<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.algorithms.mo.morls</span><span class=w> </span><span class=kn>import</span> <span class=n>MORLS</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.api.mo_archive</span><span class=w> </span><span class=kn>import</span> <span class=n>MORecord</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.api.mo_execution</span><span class=w> </span><span class=kn>import</span> <span class=n>MOExecution</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.jssp.gantt_space</span><span class=w> </span><span class=kn>import</span> <span class=n>GanttSpace</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.jssp.instance</span><span class=w> </span><span class=kn>import</span> <span class=n>Instance</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.jssp.makespan</span><span class=w> </span><span class=kn>import</span> <span class=n>Makespan</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.jssp.ob_encoding</span><span class=w> </span><span class=kn>import</span> <span class=n>OperationBasedEncoding</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.examples.jssp.worktime</span><span class=w> </span><span class=kn>import</span> <span class=n>Worktime</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.mo.problem.weighted_sum</span><span class=w> </span><span class=kn>import</span> <span class=n>Prioritize</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.permutations.op0_shuffle</span><span class=w> </span><span class=kn>import</span> <span class=n>Op0Shuffle</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.operators.permutations.op1_swapn</span><span class=w> </span><span class=kn>import</span> <span class=n>Op1SwapN</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.spaces.permutations</span><span class=w> </span><span class=kn>import</span> <span class=n>Permutations</span>
<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.utils.nputils</span><span class=w> </span><span class=kn>import</span> <span class=n>array_to_str</span>

<span class=n>instance</span> <span class=o>=</span> <span class=n>Instance</span><span class=o>.</span><span class=n>from_resource</span><span class=p>(</span><span class=s2>"swv02"</span><span class=p>)</span>     <span class=c1># We load the instance "swv02".</span>
<span class=n>solution_space</span> <span class=o>=</span> <span class=n>GanttSpace</span><span class=p>(</span><span class=n>instance</span><span class=p>)</span>          <span class=c1># Solutions are Gantt charts.</span>
<span class=n>search_space</span> <span class=o>=</span> <span class=n>Permutations</span><span class=o>.</span><span class=n>with_repetitions</span><span class=p>(</span>  <span class=c1># We will encode solutions as</span>
    <span class=n>instance</span><span class=o>.</span><span class=n>jobs</span><span class=p>,</span> <span class=n>instance</span><span class=o>.</span><span class=n>machines</span><span class=p>)</span>          <span class=c1># permutations w. repetitions.</span>
<span class=n>encoding</span> <span class=o>=</span> <span class=n>OperationBasedEncoding</span><span class=p>(</span><span class=n>instance</span><span class=p>)</span>    <span class=c1># Decode permutations to Gantt.</span>

<span class=c1># Each multi-objective optimization problem is defined by several objective</span>
<span class=c1># functions *and* a way to scalarize the vector of objective values.</span>
<span class=c1># The scalarization is only used by the system to decide for one single best</span>
<span class=c1># solution in the end *and* if we actually apply a single-objective algorithm</span>
<span class=c1># to the problem instead of a multi-objective one. (Here we will apply a</span>
<span class=c1># multi-objective algorithm.)</span>
<span class=n>f1</span> <span class=o>=</span> <span class=n>Makespan</span><span class=p>(</span><span class=n>instance</span><span class=p>)</span>  <span class=c1># The first objective be the makespan.</span>
<span class=n>f2</span> <span class=o>=</span> <span class=n>Worktime</span><span class=p>(</span><span class=n>instance</span><span class=p>)</span>  <span class=c1># The second objective be the total work time.</span>
<span class=c1># Here, we decide for a priorization scalarization: The single best end result</span>
<span class=c1># will be the one with the shortest makespan.</span>
<span class=n>problem</span> <span class=o>=</span> <span class=n>Prioritize</span><span class=p>([</span><span class=n>f1</span><span class=p>,</span> <span class=n>f2</span><span class=p>])</span>

<span class=c1># MO-RLS is a fully-fledged multi-objective optimization method (though not a</span>
<span class=c1># very good one). It works directly on the multiple objectives. It does not</span>
<span class=c1># require the scalarization above at all. The scalarization is _only_ used</span>
<span class=c1># internally in the `Process` objects to ensure compatibility with single-</span>
<span class=c1># objective optimization and for being able to remember a single "best"</span>
<span class=c1># solution.</span>
<span class=n>algorithm</span> <span class=o>=</span> <span class=n>MORLS</span><span class=p>(</span>              <span class=c1># Create multi-objective RLS that</span>
    <span class=n>Op0Shuffle</span><span class=p>(</span><span class=n>search_space</span><span class=p>),</span>   <span class=c1># starts with a random permutation and</span>
    <span class=n>Op1SwapN</span><span class=p>())</span>                 <span class=c1># swaps a random number of elements per step.</span>

<span class=c1># We work with a temporary log file which is automatically deleted after this</span>
<span class=c1># experiment.</span>
<span class=c1># For a real experiment, you would put the path to a file into `tf` by doing</span>
<span class=c1># `from pycommons.io.path import Path; tf = Path("myfile.txt")` and not use</span>
<span class=c1># the `with` block.</span>
<span class=k>with</span> <span class=n>temp_file</span><span class=p>()</span> <span class=k>as</span> <span class=n>tf</span><span class=p>:</span>  <span class=c1># create temporary file `tf`</span>
    <span class=n>ex</span> <span class=o>=</span> <span class=n>MOExecution</span><span class=p>()</span>  <span class=c1># begin configuring execution</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_solution_space</span><span class=p>(</span><span class=n>solution_space</span><span class=p>)</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_search_space</span><span class=p>(</span><span class=n>search_space</span><span class=p>)</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_encoding</span><span class=p>(</span><span class=n>encoding</span><span class=p>)</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_objective</span><span class=p>(</span><span class=n>problem</span><span class=p>)</span>      <span class=c1># set the multi-objective problem</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_algorithm</span><span class=p>(</span><span class=n>algorithm</span><span class=p>)</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_rand_seed</span><span class=p>(</span><span class=mi>199</span><span class=p>)</span>          <span class=c1># set random seed to 199</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_log_improvements</span><span class=p>(</span><span class=kc>True</span><span class=p>)</span>  <span class=c1># log all improving moves</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_log_file</span><span class=p>(</span><span class=n>tf</span><span class=p>)</span>            <span class=c1># set log file = temp file `tf`</span>
    <span class=n>ex</span><span class=o>.</span><span class=n>set_max_fes</span><span class=p>(</span><span class=mi>2800</span><span class=p>)</span>           <span class=c1># allow at most 2800 function evaluations</span>
    <span class=k>with</span> <span class=n>ex</span><span class=o>.</span><span class=n>execute</span><span class=p>()</span> <span class=k>as</span> <span class=n>process</span><span class=p>:</span>  <span class=c1># now run the algorithm*problem combination</span>
        <span class=n>arch</span><span class=p>:</span> <span class=nb>list</span><span class=p>[</span><span class=n>MORecord</span><span class=p>]</span> <span class=o>=</span> <span class=n>process</span><span class=o>.</span><span class=n>get_archive</span><span class=p>()</span>
        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>"We found the </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>arch</span><span class=p>)</span><span class=si>}</span><span class=s2> non-dominated trade-off solutions:"</span><span class=p>)</span>
        <span class=nb>print</span><span class=p>(</span><span class=s2>"makespan;worktime"</span><span class=p>)</span>
        <span class=n>arch</span><span class=o>.</span><span class=n>sort</span><span class=p>()</span>
        <span class=k>for</span> <span class=n>ae</span> <span class=ow>in</span> <span class=n>arch</span><span class=p>:</span>
            <span class=nb>print</span><span class=p>(</span><span class=n>array_to_str</span><span class=p>(</span><span class=n>ae</span><span class=o>.</span><span class=n>fs</span><span class=p>))</span>

    <span class=nb>print</span><span class=p>(</span><span class=s2>"</span><span class=se>\n</span><span class=s2>Now reading and printing all the logged data:"</span><span class=p>)</span>
    <span class=nb>print</span><span class=p>(</span><span class=n>tf</span><span class=o>.</span><span class=n>read_all_str</span><span class=p>())</span>  <span class=c1># instead, we load and print the log file</span>
<span class=c1># The temp file is deleted as soon as we leave the `with` block.</span>
</pre></div>
