<!doctype html><html data-content_root=../../../ lang=en><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0"name=viewport><title>moptipy.evaluation.selector — moptipy 0.9.150 documentation</title><link href="../../../_static/pygments.css?v=b86133f3"rel=stylesheet><link href="../../../_static/bizstyle.css?v=5283bb3d"rel=stylesheet><script src="../../../_static/documentation_options.js?v=f799f60e"></script><script src="../../../_static/doctools.js?v=9bcbadda"></script><script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script><script src=../../../_static/bizstyle.js></script><link href=https://thomasweise.github.io/moptipy/_modules/moptipy/evaluation/selector.html rel=canonical><link href=../../../genindex.html rel=index title=Index><link href=../../../search.html rel=search title=Search><meta content="width=device-width,initial-scale=1.0"name=viewport><body><div aria-label=Related class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="General Index"accesskey=I href=../../../genindex.html>index</a><li class=right><a title="Python Module Index"href=../../../py-modindex.html>modules</a> |<li class="nav-item nav-item-0"><a href=../../../index.html>moptipy 0.9.150 documentation</a> »<li class="nav-item nav-item-1"><a accesskey=U href=../../index.html>Module code</a> »<li class="nav-item nav-item-this"><a href>moptipy.evaluation.selector</a></ul></div><div class=document><div class=documentwrapper><div class=bodywrapper><div class=body role=main><h1>Source code for moptipy.evaluation.selector</h1><div class=highlight><pre>
<span></span><span class=sd>"""</span>
<span class=sd>A tool for selecting a consistent subset of data from partial experiments.</span>

<span class=sd>When we have partial experimental data, maybe collected from experiments that</span>
<span class=sd>are still ongoing, we want to still evaluate them in some consistent way. The</span>
<span class=sd>right method for doing this could be to select a subset of that data that is</span>
<span class=sd>consistent, i.e., a subset where the algorithms have the same number of runs</span>
<span class=sd>on the instances using the same seeds. The function :func:`select_consistent`</span>
<span class=sd>offered by this module provides the functionality to make such a selection.</span>
<span class=sd>It may be a bit slow, but hopefully it will pick the largest possible</span>
<span class=sd>consistent sub-selection or, at least, get close to it.</span>

<span class=sd>The current method to select the data is rather heuristic. It always begins</span>
<span class=sd>with the full set of data and aims to delete the element that will cause the</span>
<span class=sd>least other deletions down the road, until we arrive in a consistent state.</span>
<span class=sd>I strongly suspect that doing this perfectly would be NP-hard, so we cannot</span>
<span class=sd>implement this. Instead, we use different heuristics and then pick the best</span>
<span class=sd>result.</span>
<span class=sd>"""</span>

<span class=kn>from</span><span class=w> </span><span class=nn>collections</span><span class=w> </span><span class=kn>import</span> <span class=n>Counter</span>
<span class=kn>from</span><span class=w> </span><span class=nn>operator</span><span class=w> </span><span class=kn>import</span> <span class=n>itemgetter</span>
<span class=kn>from</span><span class=w> </span><span class=nn>typing</span><span class=w> </span><span class=kn>import</span> <span class=n>Any</span><span class=p>,</span> <span class=n>Callable</span><span class=p>,</span> <span class=n>Final</span><span class=p>,</span> <span class=n>Iterable</span><span class=p>,</span> <span class=n>TypeVar</span>

<span class=kn>from</span><span class=w> </span><span class=nn>pycommons.io.console</span><span class=w> </span><span class=kn>import</span> <span class=n>logger</span>
<span class=kn>from</span><span class=w> </span><span class=nn>pycommons.types</span><span class=w> </span><span class=kn>import</span> <span class=n>type_error</span>

<span class=kn>from</span><span class=w> </span><span class=nn>moptipy.evaluation.base</span><span class=w> </span><span class=kn>import</span> <span class=n>PerRunData</span>

<span class=c1>#: the type variable for the selector routine</span>
<span class=n>T</span> <span class=o>=</span> <span class=n>TypeVar</span><span class=p>(</span><span class=s2>"T"</span><span class=p>,</span> <span class=n>bound</span><span class=o>=</span><span class=n>PerRunData</span><span class=p>)</span>

<span class=c1>#: the algorithm key</span>
<span class=n>KEY_ALGORITHM</span><span class=p>:</span> <span class=n>Final</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
<span class=c1>#: the instance key</span>
<span class=n>KEY_INSTANCE</span><span class=p>:</span> <span class=n>Final</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>KEY_ALGORITHM</span> <span class=o>+</span> <span class=mi>1</span>
<span class=c1>#: the encoding key</span>
<span class=n>KEY_ENCODING</span><span class=p>:</span> <span class=n>Final</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>KEY_INSTANCE</span> <span class=o>+</span> <span class=mi>1</span>
<span class=c1>#: the objective key</span>
<span class=n>KEY_OBJECTIVE</span><span class=p>:</span> <span class=n>Final</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>KEY_ENCODING</span> <span class=o>+</span> <span class=mi>1</span>
<span class=c1>#: the seed key</span>
<span class=n>KEY_SEED</span><span class=p>:</span> <span class=n>Final</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>KEY_OBJECTIVE</span> <span class=o>+</span> <span class=mi>1</span>
<span class=c1>#: the number of keys</span>
<span class=n>TOTAL_KEYS</span><span class=p>:</span> <span class=n>Final</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>KEY_SEED</span> <span class=o>+</span> <span class=mi>1</span>


<span class=k>def</span><span class=w> </span><span class=nf>__data_tup</span><span class=p>(</span><span class=n>d</span><span class=p>:</span> <span class=n>PerRunData</span><span class=p>)</span> <span class=o>-></span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>str</span><span class=p>,</span> <span class=nb>str</span><span class=p>,</span> <span class=nb>str</span><span class=p>,</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Get a raw data tuple for the given record.</span>

<span class=sd>    :param d: the data record</span>
<span class=sd>    :returns: the data tuple</span>
<span class=sd>    """</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>d</span><span class=p>,</span> <span class=n>PerRunData</span><span class=p>):</span>
        <span class=k>raise</span> <span class=n>type_error</span><span class=p>(</span><span class=n>d</span><span class=p>,</span> <span class=s2>"dataElement"</span><span class=p>,</span> <span class=n>PerRunData</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>d</span><span class=o>.</span><span class=n>algorithm</span><span class=p>,</span> <span class=n>d</span><span class=o>.</span><span class=n>instance</span><span class=p>,</span> <span class=n>d</span><span class=o>.</span><span class=n>encoding</span><span class=p>,</span> <span class=n>d</span><span class=o>.</span><span class=n>objective</span><span class=p>,</span> <span class=p>(</span>
        <span class=n>d</span><span class=o>.</span><span class=n>instance</span><span class=p>,</span> <span class=n>d</span><span class=o>.</span><span class=n>rand_seed</span><span class=p>)</span>


<span class=k>def</span><span class=w> </span><span class=nf>__score_inc</span><span class=p>(</span><span class=n>scores</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=n>Counter</span><span class=p>,</span> <span class=o>...</span><span class=p>],</span> <span class=n>key</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=n>Any</span><span class=p>,</span> <span class=o>...</span><span class=p>])</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Increment the score of a given tuple.</span>

<span class=sd>    :param scores: the scores</span>
<span class=sd>    :param key: the key</span>
<span class=sd>    """</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>key</span><span class=p>):</span>
        <span class=n>scores</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>


<span class=k>def</span><span class=w> </span><span class=nf>__score_dec</span><span class=p>(</span><span class=n>scores</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=n>Counter</span><span class=p>,</span> <span class=o>...</span><span class=p>],</span> <span class=n>key</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=n>Any</span><span class=p>,</span> <span class=o>...</span><span class=p>])</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Decrement the score of a given tuple.</span>

<span class=sd>    :param scores: the scores</span>
<span class=sd>    :param key: the key</span>
<span class=sd>    """</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>key</span><span class=p>):</span>
        <span class=n>scores</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>-=</span> <span class=mi>1</span>
        <span class=n>z</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=n>scores</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span>
        <span class=k>if</span> <span class=n>z</span> <span class=o><=</span> <span class=mi>0</span><span class=p>:</span>
            <span class=k>del</span> <span class=n>scores</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span>
            <span class=k>if</span> <span class=n>z</span> <span class=o><</span> <span class=mi>0</span><span class=p>:</span>
                <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>"Got negative score?"</span><span class=p>)</span>


<span class=k>def</span><span class=w> </span><span class=nf>__ret</span><span class=p>(</span><span class=n>source</span><span class=p>:</span> <span class=nb>list</span><span class=p>,</span> <span class=n>expected</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=nb>bool</span><span class=p>)</span> <span class=o>-></span> <span class=nb>list</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Prepare a source list for return.</span>

<span class=sd>    :param source: the list</span>
<span class=sd>    :param expected: the number of expected records</span>
<span class=sd>    :param log: shall we log information</span>
<span class=sd>    :returns: the result</span>
<span class=sd>    """</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>er</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>source</span><span class=p>):</span>
        <span class=n>source</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>er</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
    <span class=k>if</span> <span class=nb>list</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>source</span><span class=p>)</span> <span class=o>!=</span> <span class=n>expected</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>"Inconsistent list length!"</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>log</span><span class=p>:</span>
        <span class=n>logger</span><span class=p>(</span><span class=sa>f</span><span class=s2>"Now returning </span><span class=si>{</span><span class=n>expected</span><span class=si>}</span><span class=s2> records of data."</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>source</span>  <span class=c1># type: ignore</span>


<span class=k>def</span><span class=w> </span><span class=nf>__scorer_tired</span><span class=p>(</span><span class=n>d</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>,</span> <span class=n>scores</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=n>Counter</span><span class=p>,</span> <span class=o>...</span><span class=p>],</span> <span class=n>_</span><span class=p>)</span> <span class=o>-></span> <span class=nb>list</span><span class=p>[</span><span class=nb>int</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Score based on the tired score.</span>

<span class=sd>    :param d: the tuple to score</span>
<span class=sd>    :param scores: the scores</span>
<span class=sd>    :returns: the score</span>
<span class=sd>    """</span>
    <span class=k>return</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>scores</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>t</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>t</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>d</span><span class=p>))</span>


<span class=k>def</span><span class=w> </span><span class=nf>__scorer_normalized_tired</span><span class=p>(</span><span class=n>d</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>,</span> <span class=n>scores</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=n>Counter</span><span class=p>,</span> <span class=o>...</span><span class=p>],</span>
                              <span class=n>total</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=o>...</span><span class=p>])</span> <span class=o>-></span> <span class=nb>list</span><span class=p>[</span><span class=nb>float</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Score based on the tired score.</span>

<span class=sd>    :param d: the tuple to score</span>
<span class=sd>    :param scores: the scores</span>
<span class=sd>    :param total: the total of the scores</span>
<span class=sd>    :returns: the score</span>
<span class=sd>    """</span>
    <span class=k>return</span> <span class=nb>sorted</span><span class=p>(</span>
        <span class=n>scores</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>t</span><span class=p>]</span> <span class=o>/</span> <span class=n>total</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>t</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>d</span><span class=p>)</span> <span class=k>if</span> <span class=n>total</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>></span> <span class=mi>0</span><span class=p>)</span>


<span class=k>def</span><span class=w> </span><span class=nf>__scorer_sum</span><span class=p>(</span><span class=n>d</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>,</span> <span class=n>scores</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=n>Counter</span><span class=p>,</span> <span class=o>...</span><span class=p>],</span> <span class=n>_</span><span class=p>)</span> <span class=o>-></span> <span class=nb>int</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Score based on the sum score.</span>

<span class=sd>    :param d: the tuple to score</span>
<span class=sd>    :param scores: the scores</span>
<span class=sd>    :returns: the score</span>
<span class=sd>    """</span>
    <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>scores</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>t</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>t</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>d</span><span class=p>))</span>


<span class=k>def</span><span class=w> </span><span class=nf>__scorer_normalized_sum</span><span class=p>(</span><span class=n>d</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>,</span> <span class=n>scores</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=n>Counter</span><span class=p>,</span> <span class=o>...</span><span class=p>],</span>
                            <span class=n>total</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=o>...</span><span class=p>])</span> <span class=o>-></span> <span class=nb>float</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Score based on the sum score.</span>

<span class=sd>    :param d: the tuple to score</span>
<span class=sd>    :param scores: the scores</span>
<span class=sd>    :param total: the total of the scores</span>
<span class=sd>    :returns: the score</span>
<span class=sd>    """</span>
    <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span>
        <span class=n>scores</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>t</span><span class=p>]</span> <span class=o>/</span> <span class=n>total</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>t</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>d</span><span class=p>)</span> <span class=k>if</span> <span class=n>total</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>></span> <span class=mi>0</span><span class=p>)</span>


<span class=k>def</span><span class=w> </span><span class=nf>__scorer_product</span><span class=p>(</span><span class=n>d</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>,</span> <span class=n>scores</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=n>Counter</span><span class=p>,</span> <span class=o>...</span><span class=p>],</span> <span class=n>_</span><span class=p>)</span> <span class=o>-></span> <span class=nb>int</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Score based on the product score.</span>

<span class=sd>    :param d: the tuple to score</span>
<span class=sd>    :param scores: the scores</span>
<span class=sd>    :returns: the score</span>
<span class=sd>    """</span>
    <span class=n>result</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>1</span>
    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>t</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>d</span><span class=p>):</span>
        <span class=n>result</span> <span class=o>*=</span> <span class=n>scores</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>t</span><span class=p>]</span>
    <span class=k>return</span> <span class=n>result</span>


<span class=k>def</span><span class=w> </span><span class=nf>__scorer_normalized_min</span><span class=p>(</span><span class=n>d</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>,</span> <span class=n>scores</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=n>Counter</span><span class=p>,</span> <span class=o>...</span><span class=p>],</span>
                            <span class=n>total</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=o>...</span><span class=p>])</span> <span class=o>-></span> <span class=nb>float</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Score based on the normalized minimum score.</span>

<span class=sd>    :param d: the tuple to score</span>
<span class=sd>    :param scores: the scores</span>
<span class=sd>    :param total: the total of the scores</span>
<span class=sd>    :returns: the score</span>
<span class=sd>    """</span>
    <span class=k>return</span> <span class=nb>min</span><span class=p>(</span>
        <span class=n>scores</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>t</span><span class=p>]</span> <span class=o>/</span> <span class=n>total</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>t</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>d</span><span class=p>)</span> <span class=k>if</span> <span class=n>total</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>></span> <span class=mi>0</span><span class=p>)</span>


<span class=k>def</span><span class=w> </span><span class=nf>__not</span><span class=p>(</span><span class=n>_</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=n>Counter</span><span class=p>,</span> <span class=o>...</span><span class=p>])</span> <span class=o>-></span> <span class=nb>int</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Do nothing, return a placeholder.</span>

<span class=sd>    :returns -1: always</span>
<span class=sd>    """</span>
    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>


<span class=k>def</span><span class=w> </span><span class=nf>__total</span><span class=p>(</span><span class=n>scores</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=n>Counter</span><span class=p>,</span> <span class=o>...</span><span class=p>])</span> <span class=o>-></span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=o>...</span><span class=p>]</span> <span class=o>|</span> <span class=kc>None</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Get the total scores.</span>

<span class=sd>    :param scores: the scores</span>
<span class=sd>    :returns: the total scores</span>
<span class=sd>    """</span>
    <span class=n>result</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=o>...</span><span class=p>]</span> <span class=o>=</span> <span class=nb>tuple</span><span class=p>(</span>
        <span class=n>t</span><span class=o>.</span><span class=n>total</span><span class=p>()</span> <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>t</span><span class=p>)</span> <span class=o>></span> <span class=mi>1</span> <span class=k>else</span> <span class=o>-</span><span class=mi>1</span> <span class=k>for</span> <span class=n>t</span> <span class=ow>in</span> <span class=n>scores</span><span class=p>)</span>
    <span class=k>return</span> <span class=kc>None</span> <span class=k>if</span> <span class=p>(</span><span class=nb>tuple</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>result</span><span class=p>)</span> <span class=o><</span> <span class=mi>1</span><span class=p>)</span> <span class=ow>or</span> <span class=p>(</span>
        <span class=nb>max</span><span class=p>(</span><span class=n>result</span><span class=p>)</span> <span class=o><=</span> <span class=mi>0</span><span class=p>)</span> <span class=k>else</span> <span class=n>result</span>


<span class=c1>#: the scorers</span>
<span class=n>__SCORERS</span><span class=p>:</span> <span class=n>Final</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Callable</span><span class=p>[[</span>
    <span class=nb>tuple</span><span class=p>,</span> <span class=nb>tuple</span><span class=p>[</span><span class=n>Counter</span><span class=p>,</span> <span class=o>...</span><span class=p>],</span> <span class=n>Any</span><span class=p>],</span> <span class=n>Any</span><span class=p>],</span> <span class=n>Callable</span><span class=p>[[</span>
        <span class=nb>tuple</span><span class=p>[</span><span class=n>Counter</span><span class=p>,</span> <span class=o>...</span><span class=p>]],</span> <span class=n>Any</span><span class=p>]],</span> <span class=o>...</span><span class=p>]]</span> <span class=o>=</span> <span class=p>(</span>
    <span class=p>(</span><span class=s2>"tired"</span><span class=p>,</span> <span class=n>__scorer_tired</span><span class=p>,</span> <span class=n>__not</span><span class=p>),</span>
    <span class=p>(</span><span class=s2>"normalized_tired"</span><span class=p>,</span> <span class=n>__scorer_normalized_tired</span><span class=p>,</span> <span class=n>__total</span><span class=p>),</span>
    <span class=p>(</span><span class=s2>"sum"</span><span class=p>,</span> <span class=n>__scorer_sum</span><span class=p>,</span> <span class=n>__not</span><span class=p>),</span>
    <span class=p>(</span><span class=s2>"normalized_sum"</span><span class=p>,</span> <span class=n>__scorer_normalized_sum</span><span class=p>,</span> <span class=n>__total</span><span class=p>),</span>
    <span class=p>(</span><span class=s2>"product"</span><span class=p>,</span> <span class=n>__scorer_product</span><span class=p>,</span> <span class=n>__total</span><span class=p>),</span>
    <span class=p>(</span><span class=s2>"normalized_min"</span><span class=p>,</span> <span class=n>__scorer_normalized_min</span><span class=p>,</span> <span class=n>__total</span><span class=p>),</span>
<span class=p>)</span>


<div class=viewcode-block id=select_consistent>
<a class=viewcode-back href=../../../moptipy.evaluation.html#moptipy.evaluation.selector.select_consistent>[docs]</a>
<span class=k>def</span><span class=w> </span><span class=nf>select_consistent</span><span class=p>(</span><span class=n>data</span><span class=p>:</span> <span class=n>Iterable</span><span class=p>[</span><span class=n>T</span><span class=p>],</span> <span class=n>log</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span><span class=p>,</span>
                      <span class=n>thorough</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span><span class=p>)</span> <span class=o>-></span> <span class=nb>list</span><span class=p>[</span><span class=n>T</span><span class=p>]:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Select data such that the numbers of runs are consistent.</span>

<span class=sd>    The input is a set of data items which represent some records over the</span>
<span class=sd>    runs of algorithms on instances. It may be that not all algorithms have</span>
<span class=sd>    been applied to all instances. Maybe the number of runs is inconsistent</span>
<span class=sd>    over the algorithm-instance combinations, too. Maybe some algorithms</span>
<span class=sd>    have more runs on some instances. Maybe the runs are even different,</span>
<span class=sd>    it could be that some algorithms have runs for seed `A`, `B`, and `C` on</span>
<span class=sd>    instance `I`, while others have runs for seed `C` and `D`. This function</span>
<span class=sd>    is designed to retain only the runs with seed `C` in such a case. It may</span>
<span class=sd>    discard algorithms or instances or algorithm-instance-seed combinations</span>
<span class=sd>    in order to obtain a selection of data where all algorithms have been</span>
<span class=sd>    applied to all instances as same as often and using the same seeds.</span>

<span class=sd>    Now there are different ways to select such consistent subsets of a</span>
<span class=sd>    dataset. Of course, we want to select the data such that as much as</span>
<span class=sd>    possible of the data is retained and as little as possible is discarded.</span>
<span class=sd>    This may be a hard optimization problem in itself. Here, we offer a</span>
<span class=sd>    heuristic solution. Basically, we step-by-step try to cut away the</span>
<span class=sd>    setups that are covered by the least amount of runs. We keep repeating</span>
<span class=sd>    this until we arrive in a situation where all setups have the same</span>
<span class=sd>    amount of runs. We then check if there were some strange symmetries that</span>
<span class=sd>    still make the data inconsistent and, if we found some, try to delete</span>
<span class=sd>    one run to break the symmetries and then repeat the cleaning-up process.</span>
<span class=sd>    In the end, we should get a list of overall consistent data elements that</span>
<span class=sd>    can be used during a normal experiment evaluation procedure.</span>

<span class=sd>    This iterative process may be rather slow on larger datasets, but it is</span>
<span class=sd>    maybe the best approximation we can offer to retain as much data as</span>
<span class=sd>    possible.</span>

<span class=sd>    :param data: the source data</span>
<span class=sd>    :param log: shall we log the progress</span>
<span class=sd>    :param thorough: use the slower method which may give us more data</span>
<span class=sd>    :return: a list with the selected data</span>

<span class=sd>    >>> def __p(x) -> str:</span>
<span class=sd>    ...     return (f"{x.algorithm}/{x.instance}/{x.objective}/{x.encoding}/"</span>
<span class=sd>    ...             f"{x.rand_seed}")</span>

<span class=sd>    >>> a1i1o1e1s1 = PerRunData("a1", "i1", "o1", "e1", 1)</span>
<span class=sd>    >>> a1i1o1e1s2 = PerRunData("a1", "i1", "o1", "e1", 2)</span>
<span class=sd>    >>> a1i1o1e1s3 = PerRunData("a1", "i1", "o1", "e1", 3)</span>
<span class=sd>    >>> a1i2o1e1s1 = PerRunData("a1", "i2", "o1", "e1", 1)</span>
<span class=sd>    >>> a1i2o1e1s2 = PerRunData("a1", "i2", "o1", "e1", 2)</span>
<span class=sd>    >>> a1i2o1e1s3 = PerRunData("a1", "i2", "o1", "e1", 3)</span>
<span class=sd>    >>> a2i1o1e1s1 = PerRunData("a2", "i1", "o1", "e1", 1)</span>
<span class=sd>    >>> a2i1o1e1s2 = PerRunData("a2", "i1", "o1", "e1", 2)</span>
<span class=sd>    >>> a2i1o1e1s3 = PerRunData("a2", "i1", "o1", "e1", 3)</span>
<span class=sd>    >>> a2i2o1e1s1 = PerRunData("a1", "i2", "o1", "e1", 1)</span>
<span class=sd>    >>> a2i2o1e1s2 = PerRunData("a2", "i2", "o1", "e1", 2)</span>
<span class=sd>    >>> a2i2o1e1s3 = PerRunData("a2", "i2", "o1", "e1", 3)</span>

<span class=sd>    >>> list(map(__p, select_consistent((</span>
<span class=sd>    ...     a1i1o1e1s1, a1i1o1e1s2, a1i1o1e1s3,</span>
<span class=sd>    ...     a1i2o1e1s1, a1i2o1e1s2, a1i2o1e1s3,</span>
<span class=sd>    ...     a2i1o1e1s1, a2i1o1e1s2,</span>
<span class=sd>    ...     a2i2o1e1s2, a2i2o1e1s3))))</span>
<span class=sd>    ['a1/i1/o1/e1/1', 'a1/i1/o1/e1/2', 'a1/i2/o1/e1/2', 'a1/i2/o1/e1/3',\</span>
<span class=sd> 'a2/i1/o1/e1/1', 'a2/i1/o1/e1/2', 'a2/i2/o1/e1/2', 'a2/i2/o1/e1/3']</span>

<span class=sd>    >>> list(map(__p, select_consistent((</span>
<span class=sd>    ...     a1i1o1e1s2, a1i1o1e1s3,</span>
<span class=sd>    ...     a1i2o1e1s1, a1i2o1e1s2, a1i2o1e1s3,</span>
<span class=sd>    ...     a2i1o1e1s1, a2i1o1e1s2,</span>
<span class=sd>    ...     a2i2o1e1s2, a2i2o1e1s3))))</span>
<span class=sd>    ['a1/i2/o1/e1/2', 'a1/i2/o1/e1/3', 'a2/i2/o1/e1/2', 'a2/i2/o1/e1/3']</span>

<span class=sd>    >>> list(map(__p, select_consistent((</span>
<span class=sd>    ...     a1i1o1e1s2, a1i1o1e1s3,</span>
<span class=sd>    ...     a1i2o1e1s1, a1i2o1e1s2, a1i2o1e1s3,</span>
<span class=sd>    ...     a2i1o1e1s1, a2i1o1e1s2,</span>
<span class=sd>    ...     a2i2o1e1s2))))</span>
<span class=sd>    ['a1/i1/o1/e1/2', 'a1/i2/o1/e1/2', 'a2/i1/o1/e1/2', 'a2/i2/o1/e1/2']</span>

<span class=sd>    >>> list(map(__p, select_consistent((</span>
<span class=sd>    ...     a1i1o1e1s1, a1i1o1e1s2, a1i1o1e1s3,</span>
<span class=sd>    ...     a2i2o1e1s1, a2i2o1e1s2, a2i2o1e1s3))))</span>
<span class=sd>    ['a1/i1/o1/e1/1', 'a1/i1/o1/e1/2', 'a1/i1/o1/e1/3']</span>

<span class=sd>    >>> list(map(__p, select_consistent((</span>
<span class=sd>    ...     a1i1o1e1s1, a1i1o1e1s2, a1i1o1e1s3,</span>
<span class=sd>    ...     a2i1o1e1s1, a2i1o1e1s2, a2i1o1e1s3))))</span>
<span class=sd>    ['a1/i1/o1/e1/1', 'a1/i1/o1/e1/2', 'a1/i1/o1/e1/3', \</span>
<span class=sd>'a2/i1/o1/e1/1', 'a2/i1/o1/e1/2', 'a2/i1/o1/e1/3']</span>

<span class=sd>    >>> list(map(__p, select_consistent((</span>
<span class=sd>    ...     a1i1o1e1s1, a1i1o1e1s2, a1i2o1e1s2, a1i2o1e1s3))))</span>
<span class=sd>    ['a1/i1/o1/e1/1', 'a1/i1/o1/e1/2', 'a1/i2/o1/e1/2', 'a1/i2/o1/e1/3']</span>

<span class=sd>    >>> list(map(__p, select_consistent((</span>
<span class=sd>    ...     a1i1o1e1s1, a1i1o1e1s2, a1i2o1e1s2))))</span>
<span class=sd>    ['a1/i1/o1/e1/1', 'a1/i1/o1/e1/2']</span>

<span class=sd>    >>> list(map(__p, select_consistent((</span>
<span class=sd>    ...     a1i1o1e1s1, a2i1o1e1s2))))</span>
<span class=sd>    ['a1/i1/o1/e1/1']</span>

<span class=sd>    >>> list(map(__p, select_consistent((</span>
<span class=sd>    ...     a1i1o1e1s1, a2i1o1e1s2, a2i1o1e1s3))))</span>
<span class=sd>    ['a2/i1/o1/e1/2', 'a2/i1/o1/e1/3']</span>

<span class=sd>    >>> try:</span>
<span class=sd>    ...     select_consistent((a1i1o1e1s1, a1i1o1e1s2, a1i2o1e1s2, a1i2o1e1s2))</span>
<span class=sd>    ... except ValueError as ve:</span>
<span class=sd>    ...     print(ve)</span>
<span class=sd>    Found 4 records but only 3 different keys!</span>

<span class=sd>    >>> try:</span>
<span class=sd>    ...     select_consistent(1)</span>
<span class=sd>    ... except TypeError as te:</span>
<span class=sd>    ...     print(te)</span>
<span class=sd>    data should be an instance of typing.Iterable but is int, namely 1.</span>

<span class=sd>    >>> try:</span>
<span class=sd>    ...     select_consistent((a2i1o1e1s2, a2i1o1e1s3), 3)</span>
<span class=sd>    ... except TypeError as te:</span>
<span class=sd>    ...     print(te)</span>
<span class=sd>    log should be an instance of bool but is int, namely 3.</span>

<span class=sd>    >>> try:</span>
<span class=sd>    ...     select_consistent({234})</span>
<span class=sd>    ... except TypeError as te:</span>
<span class=sd>    ...     print(te)</span>
<span class=sd>    dataElement should be an instance of moptipy.evaluation.base.PerRunData \</span>
<span class=sd>but is int, namely 234.</span>

<span class=sd>    >>> try:</span>
<span class=sd>    ...     select_consistent((a2i1o1e1s2, a2i1o1e1s3), True, 4)</span>
<span class=sd>    ... except TypeError as te:</span>
<span class=sd>    ...     print(te)</span>
<span class=sd>    thorough should be an instance of bool but is int, namely 4.</span>
<span class=sd>    """</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>Iterable</span><span class=p>):</span>
        <span class=k>raise</span> <span class=n>type_error</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=s2>"data"</span><span class=p>,</span> <span class=n>Iterable</span><span class=p>)</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>log</span><span class=p>,</span> <span class=nb>bool</span><span class=p>):</span>
        <span class=k>raise</span> <span class=n>type_error</span><span class=p>(</span><span class=n>log</span><span class=p>,</span> <span class=s2>"log"</span><span class=p>,</span> <span class=nb>bool</span><span class=p>)</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>thorough</span><span class=p>,</span> <span class=nb>bool</span><span class=p>):</span>
        <span class=k>raise</span> <span class=n>type_error</span><span class=p>(</span><span class=n>thorough</span><span class=p>,</span> <span class=s2>"thorough"</span><span class=p>,</span> <span class=nb>bool</span><span class=p>)</span>

    <span class=c1># We obtain a sorted list of the data in order to make the results</span>
    <span class=c1># consistent regardless of the order in which the data comes in.</span>
    <span class=c1># The data is only sorted by its features and not by any other information</span>
    <span class=c1># attached to it.</span>
    <span class=n>dataset</span><span class=p>:</span> <span class=n>Final</span><span class=p>[</span><span class=nb>list</span><span class=p>[</span><span class=nb>list</span><span class=p>]]</span> <span class=o>=</span> <span class=p>[[</span><span class=n>__data_tup</span><span class=p>(</span><span class=n>t</span><span class=p>),</span> <span class=n>t</span><span class=p>,</span> <span class=mi>0</span><span class=p>]</span> <span class=k>for</span> <span class=n>t</span> <span class=ow>in</span> <span class=n>data</span><span class=p>]</span>
    <span class=n>dataset</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=n>itemgetter</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span>
    <span class=n>dataset_size</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=nb>list</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span>
    <span class=k>if</span> <span class=n>log</span><span class=p>:</span>
        <span class=n>logger</span><span class=p>(</span><span class=sa>f</span><span class=s2>"Found </span><span class=si>{</span><span class=n>dataset_size</span><span class=si>}</span><span class=s2> records of data."</span><span class=p>)</span>

    <span class=n>set_l</span><span class=p>:</span> <span class=n>Final</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=nb>set</span><span class=o>.</span><span class=fm>__len__</span><span class=p>({</span><span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>dataset</span><span class=p>})</span>
    <span class=k>if</span> <span class=n>set_l</span> <span class=o>!=</span> <span class=n>dataset_size</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
            <span class=sa>f</span><span class=s2>"Found </span><span class=si>{</span><span class=n>dataset_size</span><span class=si>}</span><span class=s2> records but only </span><span class=si>{</span><span class=n>set_l</span><span class=si>}</span><span class=s2> different keys!"</span><span class=p>)</span>

    <span class=c1># Compute the scores: count how often each algorithm, instance,</span>
    <span class=c1># objective, encoding, and (instance, seed) combination are</span>
    <span class=c1># encountered.</span>
    <span class=n>key_tuple_len</span><span class=p>:</span> <span class=n>Final</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=nb>tuple</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>dataset</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>])</span>
    <span class=k>if</span> <span class=n>key_tuple_len</span> <span class=o>!=</span> <span class=n>TOTAL_KEYS</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>"Unexpected error!"</span><span class=p>)</span>

    <span class=c1># the map for the score calculations</span>
    <span class=n>scores</span><span class=p>:</span> <span class=n>Final</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=n>Counter</span><span class=p>,</span> <span class=o>...</span><span class=p>]]</span> <span class=o>=</span> <span class=nb>tuple</span><span class=p>(</span>
        <span class=n>Counter</span><span class=p>()</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>key_tuple_len</span><span class=p>))</span>

    <span class=c1># the final result</span>
    <span class=n>best_length</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
    <span class=n>best_data</span><span class=p>:</span> <span class=nb>list</span><span class=p>[</span><span class=nb>list</span><span class=p>]</span> <span class=o>|</span> <span class=kc>None</span> <span class=o>=</span> <span class=kc>None</span>

    <span class=k>for</span> <span class=n>scorer_name</span><span class=p>,</span> <span class=n>scorer</span><span class=p>,</span> <span class=n>scorer_total</span> <span class=ow>in</span> <span class=n>__SCORERS</span> <span class=k>if</span> <span class=n>thorough</span> <span class=k>else</span> <span class=p>(</span>
            <span class=n>__SCORERS</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=p>):</span>
        <span class=n>logger</span><span class=p>(</span><span class=sa>f</span><span class=s2>"Now scoring according to the </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2> method."</span><span class=p>)</span>
        <span class=c1># compute the original item scores</span>
        <span class=k>for</span> <span class=n>sc</span> <span class=ow>in</span> <span class=n>scores</span><span class=p>:</span>
            <span class=n>sc</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>

        <span class=n>source</span><span class=p>:</span> <span class=nb>list</span><span class=p>[</span><span class=nb>list</span><span class=p>]</span> <span class=o>=</span> <span class=n>dataset</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
        <span class=n>count</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=n>dataset_size</span>
        <span class=k>for</span> <span class=n>er</span> <span class=ow>in</span> <span class=n>source</span><span class=p>:</span>
            <span class=n>__score_inc</span><span class=p>(</span><span class=n>scores</span><span class=p>,</span> <span class=n>er</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>

        <span class=n>changed</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>True</span>
        <span class=k>while</span> <span class=n>changed</span><span class=p>:</span>
            <span class=n>changed</span> <span class=o>=</span> <span class=kc>False</span>

            <span class=c1># Find the setups with maximum and minimum scores.</span>
            <span class=n>min_score</span><span class=p>:</span> <span class=n>Any</span> <span class=o>=</span> <span class=kc>None</span>
            <span class=n>max_score</span><span class=p>:</span> <span class=n>Any</span> <span class=o>=</span> <span class=kc>None</span>
            <span class=n>norm</span><span class=p>:</span> <span class=n>Any</span> <span class=o>=</span> <span class=n>scorer_total</span><span class=p>(</span><span class=n>scores</span><span class=p>)</span>

            <span class=k>if</span> <span class=n>norm</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>  <span class=c1># cannot proceed</span>
                <span class=k>if</span> <span class=n>log</span><span class=p>:</span>
                    <span class=n>logger</span><span class=p>(</span><span class=sa>f</span><span class=s2>"Method </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2> is not applicable."</span><span class=p>)</span>
                <span class=n>count</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>  <span class=c1># we can do nothing</span>
                <span class=k>break</span>

            <span class=k>for</span> <span class=n>er</span> <span class=ow>in</span> <span class=n>source</span><span class=p>:</span>
                <span class=n>score</span> <span class=o>=</span> <span class=n>scorer</span><span class=p>(</span><span class=n>er</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>scores</span><span class=p>,</span> <span class=n>norm</span><span class=p>)</span>
                <span class=n>er</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>score</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>min_score</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>)</span> <span class=ow>or</span> <span class=p>(</span><span class=n>min_score</span> <span class=o>></span> <span class=n>score</span><span class=p>):</span>
                    <span class=n>min_score</span> <span class=o>=</span> <span class=n>score</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>max_score</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>)</span> <span class=ow>or</span> <span class=p>(</span><span class=n>max_score</span> <span class=o><</span> <span class=n>score</span><span class=p>):</span>
                    <span class=n>max_score</span> <span class=o>=</span> <span class=n>score</span>
            <span class=k>del</span> <span class=n>norm</span>

            <span class=k>if</span> <span class=n>min_score</span> <span class=o><</span> <span class=n>max_score</span><span class=p>:</span>  <span class=c1># Some setups have lower scores.</span>
                <span class=n>del_count</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># We will delete them.</span>
                <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>count</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
                    <span class=n>er</span> <span class=o>=</span> <span class=n>source</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
                    <span class=k>if</span> <span class=n>er</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o><=</span> <span class=n>min_score</span><span class=p>:</span>
                        <span class=k>del</span> <span class=n>source</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
                        <span class=n>__score_dec</span><span class=p>(</span><span class=n>scores</span><span class=p>,</span> <span class=n>er</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
                        <span class=n>del_count</span> <span class=o>+=</span> <span class=mi>1</span>
                <span class=k>if</span> <span class=n>del_count</span> <span class=o><=</span> <span class=mi>0</span><span class=p>:</span>
                    <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
                        <span class=sa>f</span><span class=s2>"Did not delete anything under </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>?"</span><span class=p>)</span>

                <span class=n>new_count</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=nb>list</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>source</span><span class=p>)</span>
                <span class=k>if</span> <span class=n>new_count</span> <span class=o>!=</span> <span class=p>(</span><span class=n>count</span> <span class=o>-</span> <span class=n>del_count</span><span class=p>):</span>
                    <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>"List inconsistent after deletion "</span>
                                     <span class=sa>f</span><span class=s2>"under </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>?"</span><span class=p>)</span>
                <span class=k>if</span> <span class=n>log</span><span class=p>:</span>
                    <span class=n>logger</span><span class=p>(</span>
                        <span class=sa>f</span><span class=s2>"Deleted </span><span class=si>{</span><span class=n>del_count</span><span class=si>}</span><span class=s2> of the </span><span class=si>{</span><span class=n>count</span><span class=si>}</span><span class=s2> records because "</span>
                        <span class=sa>f</span><span class=s2>"their score was </span><span class=si>{</span><span class=n>min_score</span><span class=si>}</span><span class=s2> while the maximum score"</span>
                        <span class=sa>f</span><span class=s2>" was </span><span class=si>{</span><span class=n>max_score</span><span class=si>}</span><span class=s2>. Retained </span><span class=si>{</span><span class=n>new_count</span><span class=si>}</span><span class=s2> records "</span>
                        <span class=sa>f</span><span class=s2>"under </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
                <span class=n>count</span> <span class=o>=</span> <span class=n>new_count</span>
                <span class=n>changed</span> <span class=o>=</span> <span class=kc>True</span>
                <span class=k>continue</span>

            <span class=k>if</span> <span class=n>log</span><span class=p>:</span>
                <span class=n>logger</span><span class=p>(</span><span class=sa>f</span><span class=s2>"All setups now have the same score </span><span class=si>{</span><span class=n>max_score</span><span class=si>}</span><span class=s2> under"</span>
                       <span class=sa>f</span><span class=s2>" </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
            <span class=k>if</span> <span class=n>count</span> <span class=o><=</span> <span class=n>best_length</span><span class=p>:</span>
                <span class=k>if</span> <span class=n>log</span><span class=p>:</span>
                    <span class=n>logger</span><span class=p>(</span><span class=sa>f</span><span class=s2>"We now only have </span><span class=si>{</span><span class=n>count</span><span class=si>}</span><span class=s2> setups, which means we "</span>
                           <span class=s2>"cannot get better than the current best set with "</span>
                           <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>best_length</span><span class=si>}</span><span class=s2> setups, so we quit after score-"</span>
                           <span class=sa>f</span><span class=s2>"based cleaning under </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
                <span class=n>count</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
                <span class=k>break</span>

            <span class=c1># If we get here, all elements have the same score.</span>
            <span class=c1># This means that we are basically done.</span>
            <span class=c1>#</span>
            <span class=c1># However, this may also happen if a very odd division exists in</span>
            <span class=c1># the data. Maybe we have one algorithm that was applied to one</span>
            <span class=c1># instance ten times and another algorithm applied to another</span>
            <span class=c1># instance ten times. This data would still be inconsistent, as it</span>
            <span class=c1># does not allow for any comparison.</span>

            <span class=c1># Compute the different values for everything except the seeds.</span>
            <span class=n>keys</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=o>...</span><span class=p>]</span> <span class=o>=</span> <span class=nb>tuple</span><span class=p>(</span>
                <span class=n>v</span> <span class=k>for</span> <span class=n>v</span><span class=p>,</span> <span class=n>s</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>scores</span><span class=p>)</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>v</span> <span class=o>!=</span> <span class=n>KEY_SEED</span><span class=p>)</span> <span class=ow>and</span> <span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>></span> <span class=mi>1</span><span class=p>))</span>

            <span class=k>if</span> <span class=nb>tuple</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>keys</span><span class=p>)</span> <span class=o>></span> <span class=mi>1</span><span class=p>:</span>
                <span class=k>if</span> <span class=n>log</span><span class=p>:</span>
                    <span class=n>logger</span><span class=p>(</span><span class=s2>"Now checking for inconsistencies in "</span>
                           <span class=s2>"algorithm/instance/objective/encoding under"</span>
                           <span class=sa>f</span><span class=s2>" </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
                <span class=c1># Only if there are different values in at least one tuple</span>
                <span class=c1># dimension, we need to check for strange situations.</span>

                <span class=c1># For each of (instance, algorithm, encoding, objective), we</span>
                <span class=c1># must have the same number of other records.</span>
                <span class=c1># If not, then we have some strange symmetric situation that</span>
                <span class=c1># needs to be solved.</span>
                <span class=n>per_value</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=n>Any</span><span class=p>,</span> <span class=nb>set</span><span class=p>[</span><span class=n>Any</span><span class=p>]]</span> <span class=o>=</span> <span class=p>{}</span>
                <span class=n>last</span><span class=p>:</span> <span class=nb>set</span><span class=p>[</span><span class=n>Any</span><span class=p>]</span> <span class=o>|</span> <span class=kc>None</span> <span class=o>=</span> <span class=kc>None</span>
                <span class=k>for</span> <span class=n>key</span> <span class=ow>in</span> <span class=n>keys</span><span class=p>:</span>
                    <span class=n>other_keys</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=o>...</span><span class=p>]</span> <span class=o>=</span> <span class=nb>tuple</span><span class=p>(</span>
                        <span class=n>kk</span> <span class=k>for</span> <span class=n>kk</span> <span class=ow>in</span> <span class=n>keys</span> <span class=k>if</span> <span class=n>kk</span> <span class=o>!=</span> <span class=n>key</span><span class=p>)</span>
                    <span class=k>for</span> <span class=n>er</span> <span class=ow>in</span> <span class=n>source</span><span class=p>:</span>
                        <span class=n>kv</span> <span class=o>=</span> <span class=n>er</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>key</span><span class=p>]</span>
                        <span class=n>other</span> <span class=o>=</span> <span class=nb>tuple</span><span class=p>(</span><span class=n>er</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>ok</span><span class=p>]</span> <span class=k>for</span> <span class=n>ok</span> <span class=ow>in</span> <span class=n>other_keys</span><span class=p>)</span>
                        <span class=k>if</span> <span class=n>kv</span> <span class=ow>in</span> <span class=n>per_value</span><span class=p>:</span>
                            <span class=n>per_value</span><span class=p>[</span><span class=n>kv</span><span class=p>]</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>other</span><span class=p>)</span>
                        <span class=k>else</span><span class=p>:</span>
                            <span class=n>per_value</span><span class=p>[</span><span class=n>kv</span><span class=p>]</span> <span class=o>=</span> <span class=n>last</span> <span class=o>=</span> <span class=p>{</span><span class=n>other</span><span class=p>}</span>
                    <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>per_value</span><span class=o>.</span><span class=n>values</span><span class=p>():</span>
                        <span class=k>if</span> <span class=n>v</span> <span class=o>!=</span> <span class=n>last</span><span class=p>:</span>
                            <span class=n>changed</span> <span class=o>=</span> <span class=kc>True</span>
                            <span class=k>break</span>
                    <span class=n>per_value</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>

                    <span class=c1># We just need to delete one random element. This will</span>
                    <span class=c1># break the symmetry</span>
                    <span class=k>if</span> <span class=n>changed</span><span class=p>:</span>
                        <span class=k>if</span> <span class=n>log</span><span class=p>:</span>
                            <span class=n>logger</span><span class=p>(</span>
                                <span class=sa>f</span><span class=s2>"Deleting one of the </span><span class=si>{</span><span class=n>count</span><span class=si>}</span><span class=s2> elements to "</span>
                                <span class=s2>"break the erroneous symmetry under "</span>
                                <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>scorer_name</span><span class=si>}</span><span class=s2>."</span><span class=p>)</span>
                        <span class=n>er</span> <span class=o>=</span> <span class=n>source</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
                        <span class=k>del</span> <span class=n>source</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
                        <span class=n>__score_dec</span><span class=p>(</span><span class=n>scores</span><span class=p>,</span> <span class=n>er</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
                        <span class=n>count</span> <span class=o>-=</span> <span class=mi>1</span>
                        <span class=k>break</span>
                <span class=k>del</span> <span class=n>per_value</span>
                <span class=k>del</span> <span class=n>keys</span>
                <span class=k>if</span> <span class=n>changed</span><span class=p>:</span>
                    <span class=k>continue</span>

                <span class=k>if</span> <span class=n>log</span><span class=p>:</span>
                    <span class=n>logger</span><span class=p>(</span><span class=s2>"No inconsistencies in algorithm/instance/objecti"</span>
                           <span class=sa>f</span><span class=s2>"ve/encoding found under </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
            <span class=k>elif</span> <span class=n>log</span><span class=p>:</span>
                <span class=n>logger</span><span class=p>(</span><span class=s2>"No inconsistencies in algorithm/instance/objective/"</span>
                       <span class=sa>f</span><span class=s2>"encoding possible under </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
            <span class=k>if</span> <span class=n>count</span> <span class=o><=</span> <span class=n>best_length</span><span class=p>:</span>
                <span class=k>if</span> <span class=n>log</span><span class=p>:</span>
                    <span class=n>logger</span><span class=p>(</span><span class=sa>f</span><span class=s2>"We now only have </span><span class=si>{</span><span class=n>count</span><span class=si>}</span><span class=s2> setups, which means we "</span>
                           <span class=s2>"cannot get better than the current best set with "</span>
                           <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>best_length</span><span class=si>}</span><span class=s2> setups, so we quit after algorithm"</span>
                           <span class=s2>"/instance/objective/encoding cleaning under "</span>
                           <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
                <span class=n>count</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
                <span class=k>break</span>

            <span class=c1># If we get here, the only problem left could be if algorithms</span>
            <span class=c1># have different seeds for the same instances. We thus need to</span>
            <span class=c1># check that for each instance, all the seeds are the same.</span>
            <span class=c1># Notice that such inconsistencies can only occur if different</span>
            <span class=c1># seeds occurred exactly as same as often.</span>
            <span class=k>if</span> <span class=n>log</span><span class=p>:</span>
                <span class=n>logger</span><span class=p>(</span><span class=s2>"Now checking for inconsistencies in instance "</span>
                       <span class=sa>f</span><span class=s2>"seeds under </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
            <span class=n>seeds</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>str</span><span class=p>,</span> <span class=nb>str</span><span class=p>],</span> <span class=nb>set</span><span class=p>[</span><span class=nb>int</span><span class=p>]]]</span> <span class=o>=</span> <span class=p>{}</span>
            <span class=k>for</span> <span class=n>er</span> <span class=ow>in</span> <span class=n>source</span><span class=p>:</span>
                <span class=n>inst</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=n>er</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>instance</span>
                <span class=n>cur</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>tuple</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>str</span><span class=p>,</span> <span class=nb>str</span><span class=p>],</span> <span class=nb>set</span><span class=p>[</span><span class=nb>int</span><span class=p>]]</span>
                <span class=k>if</span> <span class=n>inst</span> <span class=ow>in</span> <span class=n>seeds</span><span class=p>:</span>
                    <span class=n>cur</span> <span class=o>=</span> <span class=n>seeds</span><span class=p>[</span><span class=n>inst</span><span class=p>]</span>
                <span class=k>else</span><span class=p>:</span>
                    <span class=n>seeds</span><span class=p>[</span><span class=n>inst</span><span class=p>]</span> <span class=o>=</span> <span class=n>cur</span> <span class=o>=</span> <span class=p>{}</span>
                <span class=n>kx</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>str</span><span class=p>,</span> <span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span>
                    <span class=n>er</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>algorithm</span><span class=p>,</span> <span class=n>er</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>objective</span><span class=p>,</span> <span class=n>er</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>encoding</span><span class=p>)</span>
                <span class=k>if</span> <span class=n>kx</span> <span class=ow>in</span> <span class=n>cur</span><span class=p>:</span>
                    <span class=n>cur</span><span class=p>[</span><span class=n>kx</span><span class=p>]</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>er</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>rand_seed</span><span class=p>)</span>
                <span class=k>else</span><span class=p>:</span>
                    <span class=n>cur</span><span class=p>[</span><span class=n>kx</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=n>er</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>rand_seed</span><span class=p>}</span>

            <span class=n>max_seed_insts</span><span class=p>:</span> <span class=nb>set</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
            <span class=n>max_seeds</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
            <span class=n>min_seed_inst</span><span class=p>:</span> <span class=nb>str</span> <span class=o>|</span> <span class=kc>None</span> <span class=o>=</span> <span class=kc>None</span>
            <span class=n>min_seeds</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
            <span class=n>must_delete_from_insts</span><span class=p>:</span> <span class=nb>set</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
            <span class=k>for</span> <span class=n>instance</span><span class=p>,</span> <span class=n>inst_setups</span> <span class=ow>in</span> <span class=n>seeds</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
                <span class=n>kvx</span><span class=p>:</span> <span class=nb>set</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>|</span> <span class=kc>None</span> <span class=o>=</span> <span class=kc>None</span>
                <span class=k>for</span> <span class=n>setup_seeds</span> <span class=ow>in</span> <span class=n>inst_setups</span><span class=o>.</span><span class=n>values</span><span class=p>():</span>
                    <span class=k>if</span> <span class=n>kvx</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
                        <span class=n>kvx</span> <span class=o>=</span> <span class=n>setup_seeds</span>
                        <span class=n>seed_cnt</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=nb>set</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>setup_seeds</span><span class=p>)</span>
                        <span class=k>if</span> <span class=n>seed_cnt</span> <span class=o>>=</span> <span class=n>max_seeds</span><span class=p>:</span>
                            <span class=k>if</span> <span class=n>seed_cnt</span> <span class=o>></span> <span class=n>max_seeds</span><span class=p>:</span>
                                <span class=n>max_seed_insts</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
                                <span class=n>max_seeds</span> <span class=o>=</span> <span class=n>seed_cnt</span>
                            <span class=n>max_seed_insts</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>instance</span><span class=p>)</span>
                        <span class=k>if</span> <span class=p>(</span><span class=n>seed_cnt</span> <span class=o><</span> <span class=n>min_seeds</span><span class=p>)</span> <span class=ow>or</span> <span class=p>(</span><span class=n>min_seed_inst</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>):</span>
                            <span class=n>min_seeds</span> <span class=o>=</span> <span class=n>seed_cnt</span>
                            <span class=n>min_seed_inst</span> <span class=o>=</span> <span class=n>instance</span>
                    <span class=k>elif</span> <span class=n>kvx</span> <span class=o>!=</span> <span class=n>setup_seeds</span><span class=p>:</span>
                        <span class=c1># We got a symmetric inconsistency</span>
                        <span class=n>must_delete_from_insts</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>instance</span><span class=p>)</span>
                        <span class=k>break</span>
            <span class=k>if</span> <span class=n>min_seeds</span> <span class=o><</span> <span class=n>max_seeds</span><span class=p>:</span>
                <span class=n>must_delete_from_insts</span><span class=o>.</span><span class=n>update</span><span class=p>(</span><span class=n>max_seed_insts</span><span class=p>)</span>
            <span class=k>del</span> <span class=n>max_seed_insts</span>

            <span class=n>del_count</span> <span class=o>=</span> <span class=nb>set</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>must_delete_from_insts</span><span class=p>)</span>
            <span class=k>if</span> <span class=n>del_count</span> <span class=o>></span> <span class=mi>0</span><span class=p>:</span>
                <span class=k>if</span> <span class=n>log</span><span class=p>:</span>
                    <span class=n>logger</span><span class=p>(</span><span class=s2>"Must delete one record from all of "</span>
                           <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>must_delete_from_insts</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
                <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>count</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
                    <span class=n>er</span> <span class=o>=</span> <span class=n>source</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
                    <span class=n>instance</span> <span class=o>=</span> <span class=n>er</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>instance</span>
                    <span class=k>if</span> <span class=n>instance</span> <span class=ow>in</span> <span class=n>must_delete_from_insts</span><span class=p>:</span>
                        <span class=n>must_delete_from_insts</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>instance</span><span class=p>)</span>
                        <span class=k>del</span> <span class=n>source</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
                        <span class=n>__score_dec</span><span class=p>(</span><span class=n>scores</span><span class=p>,</span> <span class=n>er</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
                        <span class=n>changed</span> <span class=o>=</span> <span class=kc>True</span>
                        <span class=k>if</span> <span class=nb>set</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>must_delete_from_insts</span><span class=p>)</span> <span class=o><=</span> <span class=mi>0</span><span class=p>:</span>
                            <span class=k>break</span>
                <span class=n>new_count</span> <span class=o>=</span> <span class=nb>list</span><span class=o>.</span><span class=fm>__len__</span><span class=p>(</span><span class=n>source</span><span class=p>)</span>
                <span class=k>if</span> <span class=n>new_count</span> <span class=o>!=</span> <span class=p>(</span><span class=n>count</span> <span class=o>-</span> <span class=n>del_count</span><span class=p>):</span>
                    <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>"Error when deleting instances "</span>
                                     <span class=sa>f</span><span class=s2>"under </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
                <span class=n>count</span> <span class=o>=</span> <span class=n>new_count</span>
                <span class=k>if</span> <span class=ow>not</span> <span class=n>changed</span><span class=p>:</span>
                    <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span>
                        <span class=sa>f</span><span class=s2>"Seeds inconsistent under </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
            <span class=k>del</span> <span class=n>must_delete_from_insts</span>

            <span class=k>del</span> <span class=n>seeds</span>
            <span class=k>if</span> <span class=n>changed</span><span class=p>:</span>
                <span class=k>if</span> <span class=n>count</span> <span class=o><=</span> <span class=n>best_length</span><span class=p>:</span>
                    <span class=k>if</span> <span class=n>log</span><span class=p>:</span>
                        <span class=n>logger</span><span class=p>(</span><span class=sa>f</span><span class=s2>"We now only have </span><span class=si>{</span><span class=n>count</span><span class=si>}</span><span class=s2> setups, which "</span>
                               <span class=s2>"means we cannot get better than the current "</span>
                               <span class=sa>f</span><span class=s2>"best set with </span><span class=si>{</span><span class=n>best_length</span><span class=si>}</span><span class=s2> setups, so we "</span>
                               <span class=s2>"quit after seed-based cleaning under "</span>
                               <span class=sa>f</span><span class=s2>"</span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
                    <span class=n>count</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
                    <span class=k>break</span>
            <span class=k>elif</span> <span class=n>log</span><span class=p>:</span>
                <span class=n>logger</span><span class=p>(</span><span class=sa>f</span><span class=s2>"No seed inconsistencies under </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>."</span><span class=p>)</span>
            <span class=c1># There should not be any problems left, but we need to check</span>
            <span class=c1># again if something has changed.</span>

        <span class=k>if</span> <span class=n>count</span> <span class=o><=</span> <span class=mi>0</span><span class=p>:</span>
            <span class=k>continue</span>  <span class=c1># We can do nothing here</span>

        <span class=k>if</span> <span class=n>count</span> <span class=o>></span> <span class=n>best_length</span><span class=p>:</span>
            <span class=n>logger</span><span class=p>(</span><span class=sa>f</span><span class=s2>"Method </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2> yields </span><span class=si>{</span><span class=n>count</span><span class=si>}</span><span class=s2> records, "</span>
                   <span class=s2>"which is the new best."</span><span class=p>)</span>
            <span class=n>best_length</span> <span class=o>=</span> <span class=n>count</span>
            <span class=n>best_data</span> <span class=o>=</span> <span class=n>source</span>
            <span class=k>if</span> <span class=n>best_length</span> <span class=o>>=</span> <span class=n>dataset_size</span><span class=p>:</span>
                <span class=n>logger</span><span class=p>(</span><span class=sa>f</span><span class=s2>"Included all data under </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2>, "</span>
                       <span class=s2>"so we can stop."</span><span class=p>)</span>
                <span class=k>break</span>
        <span class=k>elif</span> <span class=n>log</span><span class=p>:</span>
            <span class=n>logger</span><span class=p>(</span><span class=sa>f</span><span class=s2>"Method </span><span class=si>{</span><span class=n>scorer_name</span><span class=si>!r}</span><span class=s2> yields </span><span class=si>{</span><span class=n>count</span><span class=si>}</span><span class=s2> records, "</span>
                   <span class=s2>"which is not better than the current "</span>
                   <span class=sa>f</span><span class=s2>"best </span><span class=si>{</span><span class=n>best_length</span><span class=si>}</span><span class=s2>."</span><span class=p>)</span>

    <span class=c1># We are finally finished. The scores are no longer needed.</span>
    <span class=k>del</span> <span class=n>scores</span>
    <span class=k>if</span> <span class=n>best_length</span> <span class=o><=</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>"No data found at all?"</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>__ret</span><span class=p>(</span><span class=n>best_data</span><span class=p>,</span> <span class=n>best_length</span><span class=p>,</span> <span class=n>log</span><span class=p>)</span></div>

</pre></div><div class=clearer></div></div></div></div><div aria-label=Main class=sphinxsidebar role=navigation><div class=sphinxsidebarwrapper><search id=searchbox role=search style=display:none> <h3 id=searchlabel>Quick search</h3> <div class=searchformwrapper><form action=../../../search.html class=search><input aria-labelledby=searchlabel autocapitalize=off autocomplete=off autocorrect=off name=q spellcheck=false><input type=submit value=Go></form></div> </search><script>document.getElementById(`searchbox`).style.display=`block`;</script></div></div><div class=clearer></div></div><div aria-label=Related class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="General Index"href=../../../genindex.html>index</a><li class=right><a title="Python Module Index"href=../../../py-modindex.html>modules</a> |<li class="nav-item nav-item-0"><a href=../../../index.html>moptipy 0.9.150 documentation</a> »<li class="nav-item nav-item-1"><a href=../../index.html>Module code</a> »<li class="nav-item nav-item-this"><a href>moptipy.evaluation.selector</a></ul></div><div class=footer role=contentinfo>© Copyright 2022-2025, Thomas Weise.</div>
