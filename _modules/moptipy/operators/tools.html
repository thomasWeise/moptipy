<!doctype html><html data-content_root=../../../ lang=en><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0"name=viewport><title>moptipy.operators.tools — moptipy 0.9.150 documentation</title><link href="../../../_static/pygments.css?v=b86133f3"rel=stylesheet><link href="../../../_static/bizstyle.css?v=5283bb3d"rel=stylesheet><script src="../../../_static/documentation_options.js?v=f799f60e"></script><script src="../../../_static/doctools.js?v=9bcbadda"></script><script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script><script src=../../../_static/bizstyle.js></script><link href=https://thomasweise.github.io/moptipy/_modules/moptipy/operators/tools.html rel=canonical><link href=../../../genindex.html rel=index title=Index><link href=../../../search.html rel=search title=Search><meta content="width=device-width,initial-scale=1.0"name=viewport><body><div aria-label=Related class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="General Index"accesskey=I href=../../../genindex.html>index</a><li class=right><a title="Python Module Index"href=../../../py-modindex.html>modules</a> |<li class="nav-item nav-item-0"><a href=../../../index.html>moptipy 0.9.150 documentation</a> »<li class="nav-item nav-item-1"><a accesskey=U href=../../index.html>Module code</a> »<li class="nav-item nav-item-this"><a href>moptipy.operators.tools</a></ul></div><div class=document><div class=documentwrapper><div class=bodywrapper><div class=body role=main><h1>Source code for moptipy.operators.tools</h1><div class=highlight><pre>
<span></span><span class=sd>"""Some tools for optimization."""</span>

<span class=kn>from</span><span class=w> </span><span class=nn>math</span><span class=w> </span><span class=kn>import</span> <span class=n>exp</span><span class=p>,</span> <span class=n>log</span>

<span class=kn>import</span><span class=w> </span><span class=nn>numba</span>  <span class=c1># type: ignore</span>


<div class=viewcode-block id=exponential_step_size>
<a class=viewcode-back href=../../../moptipy.operators.html#moptipy.operators.tools.exponential_step_size>[docs]</a>
<span class=nd>@numba</span><span class=o>.</span><span class=n>njit</span><span class=p>(</span><span class=n>cache</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>inline</span><span class=o>=</span><span class=s2>"always"</span><span class=p>,</span> <span class=n>fastmath</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>boundscheck</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
<span class=k>def</span><span class=w> </span><span class=nf>exponential_step_size</span><span class=p>(</span><span class=n>step_size</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span>
                          <span class=n>min_steps</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>max_steps</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-></span> <span class=nb>int</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Translate a step size in `[0,1]` to an integer in `min_steps..max_steps`.</span>

<span class=sd>    The idea is that we would like to have step-size dependent operators of</span>
<span class=sd>    type :class:`~moptipy.api.operators.Op1WithStepSize`. These operators</span>
<span class=sd>    allow algorithms to tune the amount of change to be applied to a solution</span>
<span class=sd>    between `0` and `1` (inclusively). As described in the documentation of</span>
<span class=sd>    :meth:`~moptipy.api.operators.Op1WithStepSize.op1`, `0` means that the</span>
<span class=sd>    smallest possible change should be applied and `1` means that the largest</span>
<span class=sd>    possible change should be applied.</span>

<span class=sd>    Now for many search spaces, we need to translate this step size from</span>
<span class=sd>    `[0,1]` to an integer. For instance, if we have `n`-dimensional</span>
<span class=sd>    :mod:`~moptipy.spaces.bitstrings` as search space, then we can flip</span>
<span class=sd>    anything between `1` and `n` bits. Straightforwardly, one would linearly</span>
<span class=sd>    scale the step size from `[0,1]` to `1..n`. Unfortunately, if we do that,</span>
<span class=sd>    then different values of `step_size` will have very different meaning</span>
<span class=sd>    depending on `n`. For example, `step_size=0.05` would translate to</span>
<span class=sd>    `round(1 + step_size * (n-1)) = 1` bits to be flipped if `n=10`, to</span>
<span class=sd>    `6` bit flips for `n=100`, and to `501` bit flips for `n=10_000`. While</span>
<span class=sd>    flipping one bit is a very small move and flipping six bits may be a</span>
<span class=sd>    medium-size move in discrete optimization, flipping over 500 bits is</span>
<span class=sd>    actually always quite a lot.</span>

<span class=sd>    What we would like is to have scale-independent small moves but still be</span>
<span class=sd>    able to make large moves. We can get this by exponentially transforming</span>
<span class=sd>    the `step_width`. Most `step_size` values will result in small integer</span>
<span class=sd>    steps and only `step_size` values close to `1` will yield really big</span>
<span class=sd>    results.</span>

<span class=sd>    And for a `step_size=0.05`, we get for different `n`:</span>

<span class=sd>    >>> exponential_step_size(0.05, 1, 10)</span>
<span class=sd>    1</span>
<span class=sd>    >>> exponential_step_size(0.05, 1, 100)</span>
<span class=sd>    1</span>
<span class=sd>    >>> exponential_step_size(0.05, 1, 10_000)</span>
<span class=sd>    2</span>
<span class=sd>    >>> exponential_step_size(0.05, 1, 1_000_000)</span>
<span class=sd>    2</span>
<span class=sd>    >>> exponential_step_size(0.05, 1, 1_000_000_000)</span>
<span class=sd>    3</span>
<span class=sd>    >>> exponential_step_size(0.05, 1, 1_000_000_000_000)</span>
<span class=sd>    4</span>

<span class=sd>    For different values of `step_size` and a fixed `n`, we can still obtain</span>
<span class=sd>    the whole spectrum of possible changes. For `n=10`, for example, we get:</span>

<span class=sd>    >>> exponential_step_size(0.0, 1, 10)</span>
<span class=sd>    1</span>
<span class=sd>    >>> exponential_step_size(0.1, 1, 10)</span>
<span class=sd>    1</span>
<span class=sd>    >>> exponential_step_size(0.2, 1, 10)</span>
<span class=sd>    2</span>
<span class=sd>    >>> exponential_step_size(0.3, 1, 10)</span>
<span class=sd>    2</span>
<span class=sd>    >>> exponential_step_size(0.4, 1, 10)</span>
<span class=sd>    3</span>
<span class=sd>    >>> exponential_step_size(0.5, 1, 10)</span>
<span class=sd>    3</span>
<span class=sd>    >>> exponential_step_size(0.6, 1, 10)</span>
<span class=sd>    4</span>
<span class=sd>    >>> exponential_step_size(0.7, 1, 10)</span>
<span class=sd>    5</span>
<span class=sd>    >>> exponential_step_size(0.8, 1, 10)</span>
<span class=sd>    6</span>
<span class=sd>    >>> exponential_step_size(0.85, 1, 10)</span>
<span class=sd>    7</span>
<span class=sd>    >>> exponential_step_size(0.9, 1, 10)</span>
<span class=sd>    8</span>
<span class=sd>    >>> exponential_step_size(0.95, 1, 10)</span>
<span class=sd>    9</span>
<span class=sd>    >>> exponential_step_size(1.0, 1, 10)</span>
<span class=sd>    10</span>

<span class=sd>    So we can still reach the whole range of possible steps from `1` to `n`.</span>

<span class=sd>    >>> isinstance(exponential_step_size(0.5, 1, 9), int)</span>
<span class=sd>    True</span>
<span class=sd>    >>> exponential_step_size(0.0, 1, 100)</span>
<span class=sd>    1</span>
<span class=sd>    >>> exponential_step_size(1.0, 1, 100)</span>
<span class=sd>    100</span>
<span class=sd>    >>> exponential_step_size(1.0 / 3.0, 1, 10)</span>
<span class=sd>    2</span>
<span class=sd>    >>> exponential_step_size(1.0 / 3.0, 1, 100)</span>
<span class=sd>    5</span>
<span class=sd>    >>> exponential_step_size(1.0 / 3.0, 1, 10_000)</span>
<span class=sd>    22</span>
<span class=sd>    >>> exponential_step_size(0.0, 2, 10)</span>
<span class=sd>    2</span>
<span class=sd>    >>> exponential_step_size(0.0, 9, 10)</span>
<span class=sd>    9</span>
<span class=sd>    >>> exponential_step_size(0.0, 10, 10)</span>
<span class=sd>    10</span>
<span class=sd>    >>> exponential_step_size(1.0, 10, 10)</span>
<span class=sd>    10</span>

<span class=sd>    :param step_size: the step size from `[0,1]` to be transformed to an</span>
<span class=sd>        integer</span>
<span class=sd>    :param min_steps: the minimum (inclusive) value for the returned integer</span>
<span class=sd>    :param max_steps: the maximum (inclusive) value for the returned integer</span>
<span class=sd>    """</span>
    <span class=k>return</span> <span class=nb>round</span><span class=p>(</span><span class=n>min_steps</span> <span class=o>+</span> <span class=n>exp</span><span class=p>(</span><span class=n>step_size</span> <span class=o>*</span> <span class=n>log</span><span class=p>(</span>
        <span class=n>max_steps</span> <span class=o>-</span> <span class=n>min_steps</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)))</span> <span class=o>-</span> <span class=mi>1</span></div>



<div class=viewcode-block id=inv_exponential_step_size>
<a class=viewcode-back href=../../../moptipy.operators.html#moptipy.operators.tools.inv_exponential_step_size>[docs]</a>
<span class=nd>@numba</span><span class=o>.</span><span class=n>njit</span><span class=p>(</span><span class=n>cache</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>inline</span><span class=o>=</span><span class=s2>"always"</span><span class=p>,</span> <span class=n>fastmath</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>boundscheck</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
<span class=k>def</span><span class=w> </span><span class=nf>inv_exponential_step_size</span><span class=p>(</span><span class=n>int_val</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
                              <span class=n>min_steps</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>max_steps</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-></span> <span class=nb>float</span><span class=p>:</span>
<span class=w>    </span><span class=sd>"""</span>
<span class=sd>    Compute the inverse of :func:`exponential_step_size`.</span>

<span class=sd>    This routine exists mainly to make testing easier.</span>

<span class=sd>    :param int_val: the return value of :func:`exponential_step_size`.</span>
<span class=sd>    :param min_steps: the minimum (inclusive) value any `int_val`</span>
<span class=sd>    :param max_steps: the maximum (inclusive) value any `int_val`</span>

<span class=sd>    >>> exponential_step_size(0.47712125471966244, 1, 10)</span>
<span class=sd>    3</span>
<span class=sd>    >>> inv_exponential_step_size(3, 1, 10)</span>
<span class=sd>    0.47712125471966244</span>
<span class=sd>    >>> inv_exponential_step_size(1, 1, 10)</span>
<span class=sd>    0.0</span>
<span class=sd>    >>> inv_exponential_step_size(10, 1, 10)</span>
<span class=sd>    1.0</span>
<span class=sd>    >>> inv_exponential_step_size(33, 6, 673)</span>
<span class=sd>    0.5123088678224029</span>
<span class=sd>    >>> exponential_step_size(0.5123088678224029, 6, 673)</span>
<span class=sd>    33</span>
<span class=sd>    >>> inv_exponential_step_size(3, 3, 3)</span>
<span class=sd>    1.0</span>
<span class=sd>    >>> inv_exponential_step_size(3, 3, 10)</span>
<span class=sd>    0.0</span>
<span class=sd>    >>> inv_exponential_step_size(10, 3, 10)</span>
<span class=sd>    1.0</span>
<span class=sd>    """</span>
    <span class=k>if</span> <span class=n>int_val</span> <span class=o>>=</span> <span class=n>max_steps</span><span class=p>:</span>
        <span class=k>return</span> <span class=mf>1.0</span>
    <span class=k>if</span> <span class=n>int_val</span> <span class=o><=</span> <span class=n>min_steps</span><span class=p>:</span>
        <span class=k>return</span> <span class=mf>0.0</span>
    <span class=k>return</span> <span class=nb>float</span><span class=p>(</span><span class=n>log</span><span class=p>(</span><span class=n>int_val</span> <span class=o>-</span> <span class=n>min_steps</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>log</span><span class=p>(</span>
        <span class=n>max_steps</span> <span class=o>-</span> <span class=n>min_steps</span> <span class=o>+</span> <span class=mi>1</span><span class=p>))</span></div>

</pre></div><div class=clearer></div></div></div></div><div aria-label=Main class=sphinxsidebar role=navigation><div class=sphinxsidebarwrapper><search id=searchbox role=search style=display:none> <h3 id=searchlabel>Quick search</h3> <div class=searchformwrapper><form action=../../../search.html class=search><input aria-labelledby=searchlabel autocapitalize=off autocomplete=off autocorrect=off name=q spellcheck=false><input type=submit value=Go></form></div> </search><script>document.getElementById(`searchbox`).style.display=`block`;</script></div></div><div class=clearer></div></div><div aria-label=Related class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="General Index"href=../../../genindex.html>index</a><li class=right><a title="Python Module Index"href=../../../py-modindex.html>modules</a> |<li class="nav-item nav-item-0"><a href=../../../index.html>moptipy 0.9.150 documentation</a> »<li class="nav-item nav-item-1"><a href=../../index.html>Module code</a> »<li class="nav-item nav-item-this"><a href>moptipy.operators.tools</a></ul></div><div class=footer role=contentinfo>© Copyright 2022-2025, Thomas Weise.</div>
