<!doctype html><html data-content_root=./ lang=en><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0"name=viewport><meta content="width=device-width,initial-scale=1"name=viewport><title>moptipy.algorithms.so package — moptipy 0.9.172 documentation</title><link href="/moptipy/_static/pygments.css?v=b86133f3"rel=stylesheet><link href="/moptipy/_static/bizstyle.css?v=5283bb3d"rel=stylesheet><script src="/moptipy/_static/documentation_options.js?v=ad8658f5"></script><script src="/moptipy/_static/doctools.js?v=9bcbadda"></script><script src="/moptipy/_static/sphinx_highlight.js?v=dc90522c"></script><script src=_static/bizstyle.js></script><link href=https://thomasweise.github.io/moptipy/moptipy.algorithms.so.html rel=canonical><link href=genindex.html rel=index title=Index><link href=search.html rel=search title=Search><link title="moptipy.algorithms.so.ffa package"href=moptipy.algorithms.so.ffa.html rel=next><link title="moptipy.algorithms.modules.selections package"href=moptipy.algorithms.modules.selections.html rel=prev><meta content="width=device-width,initial-scale=1.0"name=viewport><body><div aria-label=Related class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="General Index"accesskey=I href=genindex.html>index</a><li class=right><a title="Python Module Index"href=py-modindex.html>modules</a> |<li class=right><a title="moptipy.algorithms.so.ffa package"accesskey=N href=moptipy.algorithms.so.ffa.html>next</a> |<li class=right><a title="moptipy.algorithms.modules.selections package"accesskey=P href=moptipy.algorithms.modules.selections.html>previous</a> |<li class="nav-item nav-item-0"><a href=index.html>moptipy 0.9.172 documentation</a> »<li class="nav-item nav-item-1"><a href=modules.html>moptipy</a> »<li class="nav-item nav-item-2"><a href=moptipy.html>moptipy package</a> »<li class="nav-item nav-item-3"><a accesskey=U href=moptipy.algorithms.html>moptipy.algorithms package</a> »<li class="nav-item nav-item-this"><a href>moptipy.algorithms.so package</a></ul></div><div class=document><div class=documentwrapper><div class=bodywrapper><div class=body role=main><section id=module-moptipy.algorithms.so><span id=moptipy-algorithms-so-package></span><h1>moptipy.algorithms.so package<a title="Link to this heading"class=headerlink href=#module-moptipy.algorithms.so>¶</a></h1><p>The single-objective optimization algorithms of the <cite>moptipy</cite> package.<section id=subpackages><h2>Subpackages<a title="Link to this heading"class=headerlink href=#subpackages>¶</a></h2><div class="toctree-wrapper compound"><ul><li class=toctree-l1><a class="reference internal"href=moptipy.algorithms.so.ffa.html>moptipy.algorithms.so.ffa package</a><ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.ffa.html#submodules>Submodules</a><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.ffa.html#module-moptipy.algorithms.so.ffa.eafea>moptipy.algorithms.so.ffa.eafea module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.eafea.EAFEA><code class="docutils literal notranslate"><span class=pre>EAFEA</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.eafea.EAFEA.solve><code class="docutils literal notranslate"><span class=pre>EAFEA.solve()</span></code></a></ul></ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.ffa.html#module-moptipy.algorithms.so.ffa.eafea_a>moptipy.algorithms.so.ffa.eafea_a module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.eafea_a.EAFEAA><code class="docutils literal notranslate"><span class=pre>EAFEAA</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.eafea_a.EAFEAA.solve><code class="docutils literal notranslate"><span class=pre>EAFEAA.solve()</span></code></a></ul></ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.ffa.html#module-moptipy.algorithms.so.ffa.eafea_b>moptipy.algorithms.so.ffa.eafea_b module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.eafea_b.EAFEAB><code class="docutils literal notranslate"><span class=pre>EAFEAB</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.eafea_b.EAFEAB.solve><code class="docutils literal notranslate"><span class=pre>EAFEAB.solve()</span></code></a></ul></ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.ffa.html#module-moptipy.algorithms.so.ffa.eafea_n>moptipy.algorithms.so.ffa.eafea_n module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.eafea_n.EAFEAN><code class="docutils literal notranslate"><span class=pre>EAFEAN</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.eafea_n.EAFEAN.solve><code class="docutils literal notranslate"><span class=pre>EAFEAN.solve()</span></code></a></ul></ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.ffa.html#module-moptipy.algorithms.so.ffa.fea1plus1>moptipy.algorithms.so.ffa.fea1plus1 module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.fea1plus1.FEA1plus1><code class="docutils literal notranslate"><span class=pre>FEA1plus1</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.fea1plus1.FEA1plus1.solve><code class="docutils literal notranslate"><span class=pre>FEA1plus1.solve()</span></code></a></ul></ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.ffa.html#module-moptipy.algorithms.so.ffa.ffa_fitness>moptipy.algorithms.so.ffa.ffa_fitness module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_fitness.FFA><code class="docutils literal notranslate"><span class=pre>FFA</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_fitness.FFA.assign_fitness><code class="docutils literal notranslate"><span class=pre>FFA.assign_fitness()</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_fitness.FFA.initialize><code class="docutils literal notranslate"><span class=pre>FFA.initialize()</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_fitness.FFA.log_information_after_run><code class="docutils literal notranslate"><span class=pre>FFA.log_information_after_run()</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_fitness.FFA.log_parameters_to><code class="docutils literal notranslate"><span class=pre>FFA.log_parameters_to()</span></code></a></ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_fitness.SWITCH_TO_OFFSET_LB><code class="docutils literal notranslate"><span class=pre>SWITCH_TO_OFFSET_LB</span></code></a></ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.ffa.html#module-moptipy.algorithms.so.ffa.ffa_h>moptipy.algorithms.so.ffa.ffa_h module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_h.H_LOG_SECTION><code class="docutils literal notranslate"><span class=pre>H_LOG_SECTION</span></code></a><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_h.SWITCH_TO_MAP_RANGE><code class="docutils literal notranslate"><span class=pre>SWITCH_TO_MAP_RANGE</span></code></a><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_h.clear_h><code class="docutils literal notranslate"><span class=pre>clear_h()</span></code></a><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_h.create_h><code class="docutils literal notranslate"><span class=pre>create_h()</span></code></a><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_h.h_to_str><code class="docutils literal notranslate"><span class=pre>h_to_str()</span></code></a><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_h.log_h><code class="docutils literal notranslate"><span class=pre>log_h()</span></code></a></ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.ffa.html#module-moptipy.algorithms.so.ffa.ffa_hill_climber>moptipy.algorithms.so.ffa.ffa_hill_climber module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_hill_climber.FHC><code class="docutils literal notranslate"><span class=pre>FHC</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_hill_climber.FHC.solve><code class="docutils literal notranslate"><span class=pre>FHC.solve()</span></code></a></ul></ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.ffa.html#module-moptipy.algorithms.so.ffa.safea_a>moptipy.algorithms.so.ffa.safea_a module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.safea_a.SAFEAA><code class="docutils literal notranslate"><span class=pre>SAFEAA</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.safea_a.SAFEAA.log_parameters_to><code class="docutils literal notranslate"><span class=pre>SAFEAA.log_parameters_to()</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.safea_a.SAFEAA.schedule><code class="docutils literal notranslate"><span class=pre>SAFEAA.schedule</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.safea_a.SAFEAA.solve><code class="docutils literal notranslate"><span class=pre>SAFEAA.solve()</span></code></a></ul></ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.ffa.html#module-moptipy.algorithms.so.ffa.safea_b>moptipy.algorithms.so.ffa.safea_b module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.safea_b.SAFEAB><code class="docutils literal notranslate"><span class=pre>SAFEAB</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.safea_b.SAFEAB.log_parameters_to><code class="docutils literal notranslate"><span class=pre>SAFEAB.log_parameters_to()</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.safea_b.SAFEAB.schedule><code class="docutils literal notranslate"><span class=pre>SAFEAB.schedule</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.safea_b.SAFEAB.solve><code class="docutils literal notranslate"><span class=pre>SAFEAB.solve()</span></code></a></ul></ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.ffa.html#module-moptipy.algorithms.so.ffa.safea_n>moptipy.algorithms.so.ffa.safea_n module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.safea_n.SAFEAN><code class="docutils literal notranslate"><span class=pre>SAFEAN</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.safea_n.SAFEAN.log_parameters_to><code class="docutils literal notranslate"><span class=pre>SAFEAN.log_parameters_to()</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.safea_n.SAFEAN.schedule><code class="docutils literal notranslate"><span class=pre>SAFEAN.schedule</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.safea_n.SAFEAN.solve><code class="docutils literal notranslate"><span class=pre>SAFEAN.solve()</span></code></a></ul></ul></ul><li class=toctree-l1><a class="reference internal"href=moptipy.algorithms.so.fitnesses.html>moptipy.algorithms.so.fitnesses package</a><ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.fitnesses.html#submodules>Submodules</a><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.fitnesses.html#module-moptipy.algorithms.so.fitnesses.direct>moptipy.algorithms.so.fitnesses.direct module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.fitnesses.html#moptipy.algorithms.so.fitnesses.direct.Direct><code class="docutils literal notranslate"><span class=pre>Direct</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.fitnesses.html#moptipy.algorithms.so.fitnesses.direct.Direct.assign_fitness><code class="docutils literal notranslate"><span class=pre>Direct.assign_fitness()</span></code></a></ul></ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.fitnesses.html#module-moptipy.algorithms.so.fitnesses.rank>moptipy.algorithms.so.fitnesses.rank module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.fitnesses.html#moptipy.algorithms.so.fitnesses.rank.Rank><code class="docutils literal notranslate"><span class=pre>Rank</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.fitnesses.html#moptipy.algorithms.so.fitnesses.rank.Rank.assign_fitness><code class="docutils literal notranslate"><span class=pre>Rank.assign_fitness()</span></code></a></ul></ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.fitnesses.html#module-moptipy.algorithms.so.fitnesses.rank_and_iteration>moptipy.algorithms.so.fitnesses.rank_and_iteration module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.fitnesses.html#moptipy.algorithms.so.fitnesses.rank_and_iteration.RankAndIteration><code class="docutils literal notranslate"><span class=pre>RankAndIteration</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.fitnesses.html#moptipy.algorithms.so.fitnesses.rank_and_iteration.RankAndIteration.assign_fitness><code class="docutils literal notranslate"><span class=pre>RankAndIteration.assign_fitness()</span></code></a></ul></ul></ul><li class=toctree-l1><a class="reference internal"href=moptipy.algorithms.so.vector.html>moptipy.algorithms.so.vector package</a><ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.vector.html#submodules>Submodules</a><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.vector.html#module-moptipy.algorithms.so.vector.cmaes_lib>moptipy.algorithms.so.vector.cmaes_lib module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.cmaes_lib.BiPopCMAES><code class="docutils literal notranslate"><span class=pre>BiPopCMAES</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.cmaes_lib.BiPopCMAES.log_parameters_to><code class="docutils literal notranslate"><span class=pre>BiPopCMAES.log_parameters_to()</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.cmaes_lib.BiPopCMAES.log_restarts><code class="docutils literal notranslate"><span class=pre>BiPopCMAES.log_restarts</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.cmaes_lib.BiPopCMAES.solve><code class="docutils literal notranslate"><span class=pre>BiPopCMAES.solve()</span></code></a></ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.cmaes_lib.CMAES><code class="docutils literal notranslate"><span class=pre>CMAES</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.cmaes_lib.CMAES.log_parameters_to><code class="docutils literal notranslate"><span class=pre>CMAES.log_parameters_to()</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.cmaes_lib.CMAES.solve><code class="docutils literal notranslate"><span class=pre>CMAES.solve()</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.cmaes_lib.CMAES.space><code class="docutils literal notranslate"><span class=pre>CMAES.space</span></code></a></ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.cmaes_lib.SepCMAES><code class="docutils literal notranslate"><span class=pre>SepCMAES</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.cmaes_lib.SepCMAES.solve><code class="docutils literal notranslate"><span class=pre>SepCMAES.solve()</span></code></a></ul></ul><li class=toctree-l2><a class="reference internal"href=moptipy.algorithms.so.vector.html#module-moptipy.algorithms.so.vector.scipy>moptipy.algorithms.so.vector.scipy module</a><ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.BGFS><code class="docutils literal notranslate"><span class=pre>BGFS</span></code></a><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.CG><code class="docutils literal notranslate"><span class=pre>CG</span></code></a><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.DE><code class="docutils literal notranslate"><span class=pre>DE</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.DE.log_parameters_to><code class="docutils literal notranslate"><span class=pre>DE.log_parameters_to()</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.DE.solve><code class="docutils literal notranslate"><span class=pre>DE.solve()</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.DE.space><code class="docutils literal notranslate"><span class=pre>DE.space</span></code></a></ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.NelderMead><code class="docutils literal notranslate"><span class=pre>NelderMead</span></code></a><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.Powell><code class="docutils literal notranslate"><span class=pre>Powell</span></code></a><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.SLSQP><code class="docutils literal notranslate"><span class=pre>SLSQP</span></code></a><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.SciPyAlgorithmWrapper><code class="docutils literal notranslate"><span class=pre>SciPyAlgorithmWrapper</span></code></a><ul><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.SciPyAlgorithmWrapper.log_parameters_to><code class="docutils literal notranslate"><span class=pre>SciPyAlgorithmWrapper.log_parameters_to()</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.SciPyAlgorithmWrapper.solve><code class="docutils literal notranslate"><span class=pre>SciPyAlgorithmWrapper.solve()</span></code></a><li class=toctree-l4><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.SciPyAlgorithmWrapper.space><code class="docutils literal notranslate"><span class=pre>SciPyAlgorithmWrapper.space</span></code></a></ul><li class=toctree-l3><a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.TNC><code class="docutils literal notranslate"><span class=pre>TNC</span></code></a></ul></ul></ul></div></section><section id=submodules><h2>Submodules<a title="Link to this heading"class=headerlink href=#submodules>¶</a></h2></section><section id=module-moptipy.algorithms.so.ea><span id=moptipy-algorithms-so-ea-module></span><h2>moptipy.algorithms.so.ea module<a title="Link to this heading"class=headerlink href=#module-moptipy.algorithms.so.ea>¶</a></h2><p>A simple implementation of a (mu+lambda) Evolutionary Algorithm.<p>This is the basic <cite>mu+lambda</cite>-EA, which works as follows:<ol class=arabic><li><p>Start with a list <cite>lst</cite> of <cite>mu</cite> random records and <cite>lambda</cite> blank records.<li><p>In each iteration:</p> <blockquote><div><dl class=simple><dt>2.1. Use the <cite>mu</cite> first records as input to the search operators to<dd><p>generate <cite>lambda</cite> new points in the search space. For each new point to be created, the binary operator is applied with probability <cite>0<=br<=1</cite> and the unary operator is used otherwise.</p><dt>2.2. Sort the list <cite>lst</cite> according to the objective value of the record.<dd><p>Ties are broken by preferring younger solutions over old ones. Soring uses the <cite>__lt__</cite> dunder method of class <a class="reference internal"href=#moptipy.algorithms.so.record.Record title=moptipy.algorithms.so.record.Record><code class="xref py py-class docutils literal notranslate"><span class=pre>Record</span></code></a>. This moves the best solutions to the front of the list. The tie breaking method both encourages drift and ensures compatibility with <cite>RLS</cite>.</p></dl></div></blockquote></ol><p>If <cite>mu=1</cite>, <cite>lambda=1</cite>, and <cite>br=0</cite>, then this algorithm is exactly equivalent to the <a class="reference internal"href=#moptipy.algorithms.so.rls.RLS title=moptipy.algorithms.so.rls.RLS><code class="xref py py-class docutils literal notranslate"><span class=pre>RLS</span></code></a> if the same unary and nullary operator are used. It is only a bit slower due to the additional overhead of maintaining a list of records. This compatibility is achieved by the tie breaking strategy of <cite>step 2.2</cite> above: RLS will prefer the newer solution over the current one if the new solution is either better or as same as good. Now the latter case cannot be achieved by just sorting the list without considering the iteration at which a solution was created, since sorting in Python is <em>stable</em> (equal elements remain in the order in which they are encountered in the original list) and because our new solutions would be in the <cite>lambda</cite> last entries of the list. This can easily be fixed by the tie breaking, which is implemented in the <cite>__lt__</cite> dunder method of class <a class="reference internal"href=#moptipy.algorithms.so.record.Record title=moptipy.algorithms.so.record.Record><code class="xref py py-class docutils literal notranslate"><span class=pre>Record</span></code></a>.<ol class="arabic simple"><li><p>Thomas Bäck, David B. Fogel, and Zbigniew Michalewicz, eds., <em>Handbook of Evolutionary Computation.</em> 1997. Computational Intelligence Library. New York, NY, USA: Oxford University Press, Inc. ISBN: 0-7503-0392-1<li><p>James C. Spall. <em>Introduction to Stochastic Search and Optimization.</em> Estimation, Simulation, and Control - Wiley-Interscience Series in Discrete Mathematics and Optimization, volume 6. 2003. Chichester, West Sussex, UK: Wiley Interscience. ISBN: 0-471-33052-3. <a class="reference external"href=http://www.jhuapl.edu/ISSO/>http://www.jhuapl.edu/ISSO/</a>.<li><p>Frank Hoffmeister and Thomas Bäck. Genetic Algorithms and Evolution Strategies: Similarities and Differences. In Hans-Paul Schwefel and Reinhard Männer, <em>Proceedings of the International Conference on Parallel Problem Solving from Nature (PPSN I),</em> October 1-3, 1990, Dortmund, Germany, volume 496 of Lecture Notes in Computer Science, pages 455-469, Berlin/Heidelberg, Germany: Springer. ISBN: 978-3-540-54148-6. <a class="reference external"href=https://doi.org/10.1007/BFb0029787>https://doi.org/10.1007/BFb0029787</a>.</ol><dl class="py class"><dt class="sig sig-object py"id=moptipy.algorithms.so.ea.EA><em class=property><span class=k><span class=pre>class</span></span><span class=w> </span></em><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.ea.</span></span><span class="sig-name descname"><span class=pre>EA</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>op0</span></span></em>, <em class=sig-param><span class=n><span class=pre>op1</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>None</span></span></em>, <em class=sig-param><span class=n><span class=pre>op2</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>None</span></span></em>, <em class=sig-param><span class=n><span class=pre>mu</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>1</span></span></em>, <em class=sig-param><span class=n><span class=pre>lambda_</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>1</span></span></em>, <em class=sig-param><span class=n><span class=pre>br</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>None</span></span></em>, <em class=sig-param><span class=n><span class=pre>name</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>'ea'</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/ea.html#EA><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ea.EA>¶</a><dd><p>Bases: <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm2 title=moptipy.api.algorithm.Algorithm2><code class="xref py py-class docutils literal notranslate"><span class=pre>Algorithm2</span></code></a></p> <p>The EA is a population-based algorithm using unary and binary operators.</p> <p>It starts with a list of <a class="reference internal"href=#moptipy.algorithms.so.ea.EA.mu title=moptipy.algorithms.so.ea.EA.mu><code class="xref py py-attr docutils literal notranslate"><span class=pre>mu</span></code></a> randomly initialized solutions. In each step, it retains the <cite>mu</cite> best solutions and generates <a class="reference internal"href=#moptipy.algorithms.so.ea.EA.lambda_ title=moptipy.algorithms.so.ea.EA.lambda_><code class="xref py py-attr docutils literal notranslate"><span class=pre>lambda_</span></code></a> new solutions from them using the unary operator (<a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm1.op1 title=moptipy.api.algorithm.Algorithm1.op1><code class="xref py py-attr docutils literal notranslate"><span class=pre>op1</span></code></a>) with probability 1-<a class="reference internal"href=#moptipy.algorithms.so.ea.EA.br title=moptipy.algorithms.so.ea.EA.br><code class="xref py py-attr docutils literal notranslate"><span class=pre>br</span></code></a> and the binary search operator ((<a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm2.op2 title=moptipy.api.algorithm.Algorithm2.op2><code class="xref py py-attr docutils literal notranslate"><span class=pre>op2</span></code></a>) at rate <a class="reference internal"href=#moptipy.algorithms.so.ea.EA.br title=moptipy.algorithms.so.ea.EA.br><code class="xref py py-attr docutils literal notranslate"><span class=pre>br</span></code></a>. From the joint set of <cite>mu+lambda_</cite> solutions, it again selects the best <cite>mu</cite> ones for the next iteration. And so on.</p> <p>If <cite>mu=1</cite>, <cite>lambda_=1</cite>, and <cite>br=0</cite>, then this algorithm is exactly equivalent to the <a class="reference internal"href=#moptipy.algorithms.so.rls.RLS title=moptipy.algorithms.so.rls.RLS><code class="xref py py-class docutils literal notranslate"><span class=pre>RLS</span></code></a> if the same unary and nullary operator are used.</p> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.ea.EA.br><span class="sig-name descname"><span class=pre>br</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/functions.html#float><code class="xref py py-class docutils literal notranslate"><span class=pre>float</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ea.EA.br>¶</a><dd><p>the rate at which the binary operator is applied</p></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.ea.EA.lambda_><span class="sig-name descname"><span class=pre>lambda_</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/functions.html#int><code class="xref py py-class docutils literal notranslate"><span class=pre>int</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ea.EA.lambda_>¶</a><dd><p>the number of offsprings per generation</p></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.ea.EA.log_parameters_to><span class="sig-name descname"><span class=pre>log_parameters_to</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>logger</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/ea.html#EA.log_parameters_to><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ea.EA.log_parameters_to>¶</a><dd><p>Log the parameters of the algorithm to a logger.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>logger</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.utils.html#moptipy.utils.logger.KeyValueLogSection title=moptipy.utils.logger.KeyValueLogSection><code class="xref py py-class docutils literal notranslate"><span class=pre>KeyValueLogSection</span></code></a></span>) – the logger for the parameters</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.ea.EA.mu><span class="sig-name descname"><span class=pre>mu</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/functions.html#int><code class="xref py py-class docutils literal notranslate"><span class=pre>int</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ea.EA.mu>¶</a><dd><p>the number of records to survive in each generation</p></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.ea.EA.solve><span class="sig-name descname"><span class=pre>solve</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>process</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/ea.html#EA.solve><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ea.EA.solve>¶</a><dd><p>Apply the EA to an optimization problem.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>process</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process title=moptipy.api.process.Process><code class="xref py py-class docutils literal notranslate"><span class=pre>Process</span></code></a></span>) – the black-box process object</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl></dl></section><section id=module-moptipy.algorithms.so.fitness><span id=moptipy-algorithms-so-fitness-module></span><h2>moptipy.algorithms.so.fitness module<a title="Link to this heading"class=headerlink href=#module-moptipy.algorithms.so.fitness>¶</a></h2><p>Fitness Assignment Processes assign scalar fitnesses to solutions.<p>A <a class="reference internal"href=#moptipy.algorithms.so.fitness.Fitness title=moptipy.algorithms.so.fitness.Fitness><code class="xref py py-class docutils literal notranslate"><span class=pre>Fitness</span></code></a> Assignment Process uses the information of a set of instances of <a class="reference internal"href=#moptipy.algorithms.so.fitness.FRecord title=moptipy.algorithms.so.fitness.FRecord><code class="xref py py-class docutils literal notranslate"><span class=pre>FRecord</span></code></a> to compute their scalar <a class="reference internal"href=moptipy.algorithms.modules.html#moptipy.algorithms.modules.selection.FitnessRecord.fitness title=moptipy.algorithms.modules.selection.FitnessRecord.fitness><code class="xref py py-attr docutils literal notranslate"><span class=pre>fitness</span></code></a>. This fitness is then used by <a class="reference internal"href=moptipy.algorithms.modules.html#moptipy.algorithms.modules.selection.Selection title=moptipy.algorithms.modules.selection.Selection><code class="xref py py-class docutils literal notranslate"><span class=pre>Selection</span></code></a> algorithms. <a class="reference internal"href=moptipy.algorithms.modules.html#moptipy.algorithms.modules.selection.Selection title=moptipy.algorithms.modules.selection.Selection><code class="xref py py-class docutils literal notranslate"><span class=pre>Selection</span></code></a> is important in, e.g., Evolutionary Algorithms (<cite>~moptipy.algorithms.so.general_ea.GeneralEA</cite>), where it is used in two places: As <em>survival selection</em>, it chooses which points will be allowed to remain in the population and, hence, survive into the mating pool for the next generation. As <em>mating selection</em> methods, they choose the inputs of the search operations from the mating pool.<p>The following <a class="reference internal"href=#moptipy.algorithms.so.fitness.Fitness title=moptipy.algorithms.so.fitness.Fitness><code class="xref py py-class docutils literal notranslate"><span class=pre>Fitness</span></code></a> Assignment Processes have been implemented so far:<ul class=simple><li><p><a class="reference internal"href=moptipy.algorithms.so.fitnesses.html#moptipy.algorithms.so.fitnesses.direct.Direct title=moptipy.algorithms.so.fitnesses.direct.Direct><code class="xref py py-class docutils literal notranslate"><span class=pre>Direct</span></code></a> directly copies the objective values (<a class="reference internal"href=#moptipy.algorithms.so.record.Record.f title=moptipy.algorithms.so.record.Record.f><code class="xref py py-attr docutils literal notranslate"><span class=pre>f</span></code></a>) of the solution records directly over to the fitness.<li><p><a class="reference internal"href=moptipy.algorithms.so.fitnesses.html#moptipy.algorithms.so.fitnesses.rank.Rank title=moptipy.algorithms.so.fitnesses.rank.Rank><code class="xref py py-class docutils literal notranslate"><span class=pre>Rank</span></code></a> ranks the solutions by their objective values and uses the ranks as fitness.<li><p><a class="reference internal"href=moptipy.algorithms.so.fitnesses.html#moptipy.algorithms.so.fitnesses.rank_and_iteration.RankAndIteration title=moptipy.algorithms.so.fitnesses.rank_and_iteration.RankAndIteration><code class="xref py py-class docutils literal notranslate"><span class=pre>RankAndIteration</span></code></a> also uses the rank of the objective values in the fitness. Additionally, if two solutions have the same objective value but one of them is newer, then the newer one will receive the better fitness. This is done by accessing the iteration counter (<a class="reference internal"href=#moptipy.algorithms.so.record.Record.it title=moptipy.algorithms.so.record.Record.it><code class="xref py py-attr docutils literal notranslate"><span class=pre>it</span></code></a>) of the solution records.<li><p><a class="reference internal"href=moptipy.algorithms.so.ffa.html#moptipy.algorithms.so.ffa.ffa_fitness.FFA title=moptipy.algorithms.so.ffa.ffa_fitness.FFA><code class="xref py py-class docutils literal notranslate"><span class=pre>FFA</span></code></a> performs the Frequency Fitness Assignment which is suitable for problems with few different objective values and large computational budgets.</ul><dl class="py class"><dt class="sig sig-object py"id=moptipy.algorithms.so.fitness.FRecord><em class=property><span class=k><span class=pre>class</span></span><span class=w> </span></em><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.fitness.</span></span><span class="sig-name descname"><span class=pre>FRecord</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>x</span></span></em>, <em class=sig-param><span class=n><span class=pre>f</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/fitness.html#FRecord><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.fitness.FRecord>¶</a><dd><p>Bases: <a class="reference internal"href=#moptipy.algorithms.so.record.Record title=moptipy.algorithms.so.record.Record><code class="xref py py-class docutils literal notranslate"><span class=pre>Record</span></code></a>, <a class="reference internal"href=moptipy.algorithms.modules.html#moptipy.algorithms.modules.selection.FitnessRecord title=moptipy.algorithms.modules.selection.FitnessRecord><code class="xref py py-class docutils literal notranslate"><span class=pre>FitnessRecord</span></code></a></p> <p>A point <cite>x</cite> in the search space with its quality and fitness.</p> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.fitness.FRecord.fitness><span class="sig-name descname"><span class=pre>fitness</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><span class=pre>int</span> <span class=pre>|</span> <span class=pre>float</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.fitness.FRecord.fitness>¶</a><dd><p>the fitness assigned to the solution <cite>x</cite></p></dl></dl><dl class="py class"><dt class="sig sig-object py"id=moptipy.algorithms.so.fitness.Fitness><em class=property><span class=k><span class=pre>class</span></span><span class=w> </span></em><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.fitness.</span></span><span class="sig-name descname"><span class=pre>Fitness</span></span><a class="reference internal"href=_modules/moptipy/algorithms/so/fitness.html#Fitness><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.fitness.Fitness>¶</a><dd><p>Bases: <a class="reference internal"href=moptipy.api.html#moptipy.api.component.Component title=moptipy.api.component.Component><code class="xref py py-class docutils literal notranslate"><span class=pre>Component</span></code></a></p> <p>The base class for fitness assignment processes.</p> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.fitness.Fitness.assign_fitness><span class="sig-name descname"><span class=pre>assign_fitness</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>p</span></span></em>, <em class=sig-param><span class=n><span class=pre>random</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/fitness.html#Fitness.assign_fitness><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.fitness.Fitness.assign_fitness>¶</a><dd><p>Assign a fitness to each element in the list <cite>p</cite>.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><ul class=simple><li><p><strong>p</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/stdtypes.html#list><code class="xref py py-class docutils literal notranslate"><span class=pre>list</span></code></a>[<a class="reference internal"href=#moptipy.algorithms.so.fitness.FRecord title=moptipy.algorithms.so.fitness.FRecord><code class="xref py py-class docutils literal notranslate"><span class=pre>FRecord</span></code></a>]</span>) – the list of <a class="reference internal"href=#moptipy.algorithms.so.fitness.FRecord title=moptipy.algorithms.so.fitness.FRecord><code class="xref py py-class docutils literal notranslate"><span class=pre>FRecord</span></code></a> instances<li><p><strong>random</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in NumPy v2.4)"href=https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator><code class="xref py py-class docutils literal notranslate"><span class=pre>Generator</span></code></a></span>) – the random number generator</ul><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.fitness.Fitness.log_information_after_run><span class="sig-name descname"><span class=pre>log_information_after_run</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>process</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/fitness.html#Fitness.log_information_after_run><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.fitness.Fitness.log_information_after_run>¶</a><dd><p>Log the information of this fitness assignment process to the process.</p> <p>An instance of <a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process title=moptipy.api.process.Process><code class="xref py py-class docutils literal notranslate"><span class=pre>Process</span></code></a> is given to this method after the algorithm has completed its work. The fitness assignment process then may store some data as a separate log section via <a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process.add_log_section title=moptipy.api.process.Process.add_log_section><code class="xref py py-meth docutils literal notranslate"><span class=pre>add_log_section()</span></code></a> if it wants to. Implementing this method is optional. This method is only invoked if <a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process.has_log title=moptipy.api.process.Process.has_log><code class="xref py py-meth docutils literal notranslate"><span class=pre>has_log()</span></code></a> returns <cite>True</cite>.</p> <dl class="field-list simple"><dt class=field-odd>Return type<span class=colon>:</span><dd class=field-odd><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl></dl><dl class="py function"><dt class="sig sig-object py"id=moptipy.algorithms.so.fitness.check_fitness><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.fitness.</span></span><span class="sig-name descname"><span class=pre>check_fitness</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>fitness</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/fitness.html#check_fitness><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.fitness.check_fitness>¶</a><dd><p>Check whether an object is a valid instance of <a class="reference internal"href=#moptipy.algorithms.so.fitness.Fitness title=moptipy.algorithms.so.fitness.Fitness><code class="xref py py-class docutils literal notranslate"><span class=pre>Fitness</span></code></a>.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>fitness</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=#moptipy.algorithms.so.fitness.Fitness title=moptipy.algorithms.so.fitness.Fitness><code class="xref py py-class docutils literal notranslate"><span class=pre>Fitness</span></code></a></span>) – the Fitness object</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference internal"href=#moptipy.algorithms.so.fitness.Fitness title=moptipy.algorithms.so.fitness.Fitness><code class="xref py py-class docutils literal notranslate"><span class=pre>Fitness</span></code></a></span></p><dt class=field-odd>Returns<span class=colon>:</span><dd class=field-odd><p>the object</p><dt class=field-even>Raises<span class=colon>:</span><dd class=field-even><p><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/exceptions.html#TypeError><strong>TypeError</strong></a> – if <cite>fitness</cite> is not an instance of <a class="reference internal"href=#moptipy.algorithms.so.fitness.Fitness title=moptipy.algorithms.so.fitness.Fitness><code class="xref py py-class docutils literal notranslate"><span class=pre>Fitness</span></code></a></p></dl></dl></section><section id=module-moptipy.algorithms.so.general_ea><span id=moptipy-algorithms-so-general-ea-module></span><h2>moptipy.algorithms.so.general_ea module<a title="Link to this heading"class=headerlink href=#module-moptipy.algorithms.so.general_ea>¶</a></h2><p>A fully configurable, general (mu+lambda) Evolutionary Algorithm.<p>This evolutionary algorithm begins by sampling <a class="reference internal"href=#moptipy.algorithms.so.ea.EA.mu title=moptipy.algorithms.so.ea.EA.mu><code class="xref py py-attr docutils literal notranslate"><span class=pre>mu</span></code></a> solutions using the nullary search operation <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm0.op0 title=moptipy.api.algorithm.Algorithm0.op0><code class="xref py py-attr docutils literal notranslate"><span class=pre>op0</span></code></a>. In each iteration, it then uses <a class="reference internal"href=#moptipy.algorithms.so.ea.EA.mu title=moptipy.algorithms.so.ea.EA.mu><code class="xref py py-attr docutils literal notranslate"><span class=pre>mu</span></code></a> existing solutions as input for the search operations, where, for each solution to be sampled, the binary operation <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm2.op2 title=moptipy.api.algorithm.Algorithm2.op2><code class="xref py py-attr docutils literal notranslate"><span class=pre>op2</span></code></a> is used with probability <a class="reference internal"href=#moptipy.algorithms.so.ea.EA.br title=moptipy.algorithms.so.ea.EA.br><code class="xref py py-attr docutils literal notranslate"><span class=pre>br</span></code></a> and (otherwise), the unary operator <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm1 title=moptipy.api.algorithm.Algorithm1><code class="xref py py-attr docutils literal notranslate"><span class=pre>Algorithm1</span></code></a> is used. The inputs of both operators are chosen from the <a class="reference internal"href=#moptipy.algorithms.so.ea.EA.mu title=moptipy.algorithms.so.ea.EA.mu><code class="xref py py-attr docutils literal notranslate"><span class=pre>mu</span></code></a> solutions using <a class="reference internal"href=#moptipy.algorithms.so.general_ea.GeneralEA.mating title=moptipy.algorithms.so.general_ea.GeneralEA.mating><code class="xref py py-attr docutils literal notranslate"><span class=pre>mating</span></code></a> selection. After <a class="reference internal"href=#moptipy.algorithms.so.ea.EA.lambda_ title=moptipy.algorithms.so.ea.EA.lambda_><code class="xref py py-attr docutils literal notranslate"><span class=pre>lambda_</span></code></a> new solutions have been created this way (and have been evaluated as well), a fitness assignment process (<a class="reference internal"href=#moptipy.algorithms.so.fitness.Fitness title=moptipy.algorithms.so.fitness.Fitness><code class="xref py py-class docutils literal notranslate"><span class=pre>Fitness</span></code></a>) assigns fitness values to them based on their objective values (<a class="reference internal"href=#moptipy.algorithms.so.record.Record.f title=moptipy.algorithms.so.record.Record.f><code class="xref py py-attr docutils literal notranslate"><span class=pre>f</span></code></a>), maybe also using the index of the iteration (<a class="reference internal"href=#moptipy.algorithms.so.record.Record.it title=moptipy.algorithms.so.record.Record.it><code class="xref py py-attr docutils literal notranslate"><span class=pre>it</span></code></a>) in which they were created. The survival selection <a class="reference internal"href=#moptipy.algorithms.so.general_ea.GeneralEA.survival title=moptipy.algorithms.so.general_ea.GeneralEA.survival><code class="xref py py-attr docutils literal notranslate"><span class=pre>survival</span></code></a> then chooses, from the joint set of <cite>mu+lambda</cite> solutions, the <cite>mu</cite> solutions for the next iteration. Both mating and survival selection are instances of class <a class="reference internal"href=moptipy.algorithms.modules.html#moptipy.algorithms.modules.selection.Selection title=moptipy.algorithms.modules.selection.Selection><code class="xref py py-class docutils literal notranslate"><span class=pre>Selection</span></code></a>.<p>This algorithm is equivalent to <a class="reference internal"href=#moptipy.algorithms.so.ea.EA title=moptipy.algorithms.so.ea.EA><code class="xref py py-class docutils literal notranslate"><span class=pre>EA</span></code></a>, but allows for using a customized fitness assignment step (<a class="reference internal"href=#moptipy.algorithms.so.fitness.Fitness title=moptipy.algorithms.so.fitness.Fitness><code class="xref py py-class docutils literal notranslate"><span class=pre>Fitness</span></code></a>) as well as customizable survival and <a class="reference internal"href=#moptipy.algorithms.so.general_ea.GeneralEA.mating title=moptipy.algorithms.so.general_ea.GeneralEA.mating><code class="xref py py-attr docutils literal notranslate"><span class=pre>mating</span></code></a> selection (<a class="reference internal"href=moptipy.algorithms.modules.html#moptipy.algorithms.modules.selection.Selection title=moptipy.algorithms.modules.selection.Selection><code class="xref py py-class docutils literal notranslate"><span class=pre>Selection</span></code></a>).<ol class="arabic simple"><li><p>Thomas Bäck, David B. Fogel, and Zbigniew Michalewicz, eds., <em>Handbook of Evolutionary Computation.</em> 1997. Computational Intelligence Library. New York, NY, USA: Oxford University Press, Inc. ISBN: 0-7503-0392-1<li><p>James C. Spall. <em>Introduction to Stochastic Search and Optimization.</em> Estimation, Simulation, and Control - Wiley-Interscience Series in Discrete Mathematics and Optimization, volume 6. 2003. Chichester, West Sussex, UK: Wiley Interscience. ISBN: 0-471-33052-3. <a class="reference external"href=http://www.jhuapl.edu/ISSO/>http://www.jhuapl.edu/ISSO/</a>.<li><p>Frank Hoffmeister and Thomas Bäck. Genetic Algorithms and Evolution Strategies: Similarities and Differences. In Hans-Paul Schwefel and Reinhard Männer, <em>Proceedings of the International Conference on Parallel Problem Solving from Nature (PPSN I),</em> October 1-3, 1990, Dortmund, Germany, volume 496 of Lecture Notes in Computer Science, pages 455-469, Berlin/Heidelberg, Germany: Springer. ISBN: 978-3-540-54148-6. <a class="reference external"href=https://doi.org/10.1007/BFb0029787>https://doi.org/10.1007/BFb0029787</a>.</ol><dl class="py class"><dt class="sig sig-object py"id=moptipy.algorithms.so.general_ea.GeneralEA><em class=property><span class=k><span class=pre>class</span></span><span class=w> </span></em><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.general_ea.</span></span><span class="sig-name descname"><span class=pre>GeneralEA</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>op0</span></span></em>, <em class=sig-param><span class=n><span class=pre>op1</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>None</span></span></em>, <em class=sig-param><span class=n><span class=pre>op2</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>None</span></span></em>, <em class=sig-param><span class=n><span class=pre>mu</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>1</span></span></em>, <em class=sig-param><span class=n><span class=pre>lambda_</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>1</span></span></em>, <em class=sig-param><span class=n><span class=pre>br</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>None</span></span></em>, <em class=sig-param><span class=n><span class=pre>fitness</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>None</span></span></em>, <em class=sig-param><span class=n><span class=pre>survival</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>None</span></span></em>, <em class=sig-param><span class=n><span class=pre>mating</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>None</span></span></em>, <em class=sig-param><span class=n><span class=pre>name</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>'generalEa'</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/general_ea.html#GeneralEA><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.general_ea.GeneralEA>¶</a><dd><p>Bases: <a class="reference internal"href=#moptipy.algorithms.so.ea.EA title=moptipy.algorithms.so.ea.EA><code class="xref py py-class docutils literal notranslate"><span class=pre>EA</span></code></a></p> <p>The fully customizable (mu+lambda) EA.</p> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.general_ea.GeneralEA.fitness><span class="sig-name descname"><span class=pre>fitness</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference internal"href=#moptipy.algorithms.so.fitness.Fitness title=moptipy.algorithms.so.fitness.Fitness><code class="xref py py-class docutils literal notranslate"><span class=pre>Fitness</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.general_ea.GeneralEA.fitness>¶</a><dd><p>the fitness assignment process</p></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.general_ea.GeneralEA.initialize><span class="sig-name descname"><span class=pre>initialize</span></span><span class=sig-paren>(</span><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/general_ea.html#GeneralEA.initialize><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.general_ea.GeneralEA.initialize>¶</a><dd><p>Initialize the algorithm.</p> <dl class="field-list simple"><dt class=field-odd>Return type<span class=colon>:</span><dd class=field-odd><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.general_ea.GeneralEA.log_parameters_to><span class="sig-name descname"><span class=pre>log_parameters_to</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>logger</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/general_ea.html#GeneralEA.log_parameters_to><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.general_ea.GeneralEA.log_parameters_to>¶</a><dd><p>Log the parameters of the algorithm to a logger.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>logger</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.utils.html#moptipy.utils.logger.KeyValueLogSection title=moptipy.utils.logger.KeyValueLogSection><code class="xref py py-class docutils literal notranslate"><span class=pre>KeyValueLogSection</span></code></a></span>) – the logger for the parameters</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.general_ea.GeneralEA.mating><span class="sig-name descname"><span class=pre>mating</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference internal"href=moptipy.algorithms.modules.html#moptipy.algorithms.modules.selection.Selection title=moptipy.algorithms.modules.selection.Selection><code class="xref py py-class docutils literal notranslate"><span class=pre>Selection</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.general_ea.GeneralEA.mating>¶</a><dd><p>the mating selection algorithm</p></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.general_ea.GeneralEA.solve><span class="sig-name descname"><span class=pre>solve</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>process</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/general_ea.html#GeneralEA.solve><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.general_ea.GeneralEA.solve>¶</a><dd><p>Apply the (mu+lambda) EA to an optimization problem.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>process</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process title=moptipy.api.process.Process><code class="xref py py-class docutils literal notranslate"><span class=pre>Process</span></code></a></span>) – the black-box process object</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.general_ea.GeneralEA.survival><span class="sig-name descname"><span class=pre>survival</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference internal"href=moptipy.algorithms.modules.html#moptipy.algorithms.modules.selection.Selection title=moptipy.algorithms.modules.selection.Selection><code class="xref py py-class docutils literal notranslate"><span class=pre>Selection</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.general_ea.GeneralEA.survival>¶</a><dd><p>the survival selection algorithm</p></dl></dl></section><section id=module-moptipy.algorithms.so.general_ma><span id=moptipy-algorithms-so-general-ma-module></span><h2>moptipy.algorithms.so.general_ma module<a title="Link to this heading"class=headerlink href=#module-moptipy.algorithms.so.general_ma>¶</a></h2><p>A fully configurable, general (mu+lambda) Memetic Algorithm.<p>This Memetic Algorithm implementation compares to the one in <a class="reference internal"href=#module-moptipy.algorithms.so.ma title=moptipy.algorithms.so.ma><code class="xref py py-mod docutils literal notranslate"><span class=pre>ma</span></code></a> like the general Evolutionary Algorithm from <a class="reference internal"href=#module-moptipy.algorithms.so.general_ea title=moptipy.algorithms.so.general_ea><code class="xref py py-mod docutils literal notranslate"><span class=pre>general_ea</span></code></a> compares to the simple one in <a class="reference internal"href=#module-moptipy.algorithms.so.ea title=moptipy.algorithms.so.ea><code class="xref py py-mod docutils literal notranslate"><span class=pre>ea</span></code></a>: It adds survival and mating selection as well as a fitness assignment procedure.<p>It begins by sampling <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.mu title=moptipy.algorithms.so.ma.MA.mu><code class="xref py py-attr docutils literal notranslate"><span class=pre>mu</span></code></a> solutions using the nullary search operation <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm0.op0 title=moptipy.api.algorithm.Algorithm0.op0><code class="xref py py-attr docutils literal notranslate"><span class=pre>op0</span></code></a>. Each of these solutions is refined for <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls_fes title=moptipy.algorithms.so.ma.MA.ls_fes><code class="xref py py-attr docutils literal notranslate"><span class=pre>ls_fes</span></code></a> objective function evaluations using the local search <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls title=moptipy.algorithms.so.ma.MA.ls><code class="xref py py-attr docutils literal notranslate"><span class=pre>ls</span></code></a>. In each iteration, this algorithm then uses <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.mu title=moptipy.algorithms.so.ma.MA.mu><code class="xref py py-attr docutils literal notranslate"><span class=pre>mu</span></code></a> existing solutions as input for the binary search operation <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm2.op2 title=moptipy.api.algorithm.Algorithm2.op2><code class="xref py py-attr docutils literal notranslate"><span class=pre>op2</span></code></a>. The inputs of the operator are chosen from the <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.mu title=moptipy.algorithms.so.ma.MA.mu><code class="xref py py-attr docutils literal notranslate"><span class=pre>mu</span></code></a> solutions using <a class="reference internal"href=#moptipy.algorithms.so.general_ma.GeneralMA.mating title=moptipy.algorithms.so.general_ma.GeneralMA.mating><code class="xref py py-attr docutils literal notranslate"><span class=pre>mating</span></code></a> selection. Each of the <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.lambda_ title=moptipy.algorithms.so.ma.MA.lambda_><code class="xref py py-attr docutils literal notranslate"><span class=pre>lambda_</span></code></a> new solutions have been created this way are again refined for <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls_fes title=moptipy.algorithms.so.ma.MA.ls_fes><code class="xref py py-attr docutils literal notranslate"><span class=pre>ls_fes</span></code></a> objective function evaluations using the local search <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls title=moptipy.algorithms.so.ma.MA.ls><code class="xref py py-attr docutils literal notranslate"><span class=pre>ls</span></code></a>. Then, a fitness assignment process (<a class="reference internal"href=#moptipy.algorithms.so.fitness.Fitness title=moptipy.algorithms.so.fitness.Fitness><code class="xref py py-class docutils literal notranslate"><span class=pre>Fitness</span></code></a>) assigns fitness values to them based on their objective values (<a class="reference internal"href=#moptipy.algorithms.so.record.Record.f title=moptipy.algorithms.so.record.Record.f><code class="xref py py-attr docutils literal notranslate"><span class=pre>f</span></code></a>), maybe also using the index of the iteration (<a class="reference internal"href=#moptipy.algorithms.so.record.Record.it title=moptipy.algorithms.so.record.Record.it><code class="xref py py-attr docutils literal notranslate"><span class=pre>it</span></code></a>) in which they were created. The survival selection <a class="reference internal"href=#moptipy.algorithms.so.general_ma.GeneralMA.survival title=moptipy.algorithms.so.general_ma.GeneralMA.survival><code class="xref py py-attr docutils literal notranslate"><span class=pre>survival</span></code></a> then chooses, from the joint set of <cite>mu+lambda</cite> solutions, the <cite>mu</cite> solutions for the next iteration. Both mating and survival selection are instances of class <a class="reference internal"href=moptipy.algorithms.modules.html#moptipy.algorithms.modules.selection.Selection title=moptipy.algorithms.modules.selection.Selection><code class="xref py py-class docutils literal notranslate"><span class=pre>Selection</span></code></a>.<ol class="arabic simple"><li><p>Pablo Moscato. <em>On Evolution, Search, Optimization, Genetic Algorithms and Martial Arts: Towards Memetic Algorithms.</em> Caltech Concurrent Computation Program Report C3P 826. 1989. Pasadena, CA, USA: California Institute of Technology (Caltech), Caltech Concurrent Computation Program (C3P). <a class="reference external"href=https://www.researchgate.net/publication/2354457>https://www.researchgate.net/publication/2354457</a><li><p>Carlos Cotta, Luke Mathieson, and Pablo Moscato. Memetic Algorithms. In Rafael Martí, Panos M. Pardalos, and Mauricio G. C. Resende, editors, <em>Handbook of Heuristics.</em> Part~III: Metaheuristics, pages 607-638. 2018. Cham, Switzerland: Springer. ISBN: 978-3-319-07123-7. doi: <a class="reference external"href=https://doi.org/10.1007/978-3-319-07153-4_29-1>https://doi.org/10.1007/978-3-319-07153-4_29-1</a> <a class="reference external"href=https://www.researchgate.net/publication/315660932>https://www.researchgate.net/publication/315660932</a><li><p>William Eugene Hart, James E. Smith, and Natalio Krasnogor, editors. <em>Recent Advances in Memetic Algorithms.</em> Studies in Fuzziness and Soft Computing (STUDFUZZ), volume 166. 2005. Berlin/Heidelberg, Germany: Springer. ISBN: 978-3-540-22904-9. doi: <a class="reference external"href=https://doi.org/10.1007/3-540-32363-5>https://doi.org/10.1007/3-540-32363-5</a><li><p>Ferrante Neri, Carlos Cotta, and Pablo Moscato. <em>Handbook of Memetic Algorithms.</em> Volume 379 of Studies in Computational Intelligence (SCI). 2012. Berlin/Heidelberg, Germany: Springer. ISBN: 978-3-642-23246-6 doi <a class="reference external"href=https://doi.org/10.1007/978-3-642-23247-3>https://doi.org/10.1007/978-3-642-23247-3</a>.<li><p>L. Darrell Whitley, V. Scott Gordon, and Keith E. Mathias. Lamarckian Evolution, The Baldwin Effect and Function Optimization. In Yuval Davidor, Hans-Paul Schwefel, and Reinhard Männer, editors, <em>Proceedings of the Third Conference on Parallel Problem Solving from Nature; International Conference on Evolutionary Computation (PPSN III),</em> October 9-14, 1994, Jerusalem, Israel, pages 5-15. Volume 866/1994 of Lecture Notes in Computer Science, Berlin, Germany: Springer-Verlag GmbH. ISBN 0387584846. doi: <a class="reference external"href=https://doi.org/10.1007/3-540-58484-6_245>https://doi.org/10.1007/3-540-58484-6_245</a>. <a class="reference external"href=https://www.researchgate.net/publication/2521727>https://www.researchgate.net/publication/2521727</a><li><p>Thomas Bäck, David B. Fogel, and Zbigniew Michalewicz, eds., <em>Handbook of Evolutionary Computation.</em> 1997. Computational Intelligence Library. New York, NY, USA: Oxford University Press, Inc. ISBN: 0-7503-0392-1<li><p>James C. Spall. <em>Introduction to Stochastic Search and Optimization.</em> Estimation, Simulation, and Control - Wiley-Interscience Series in Discrete Mathematics and Optimization, volume 6. 2003. Chichester, West Sussex, UK: Wiley Interscience. ISBN: 0-471-33052-3. <a class="reference external"href=http://www.jhuapl.edu/ISSO/>http://www.jhuapl.edu/ISSO/</a>.<li><p>Frank Hoffmeister and Thomas Bäck. Genetic Algorithms and Evolution Strategies: Similarities and Differences. In Hans-Paul Schwefel and Reinhard Männer, <em>Proceedings of the International Conference on Parallel Problem Solving from Nature (PPSN I),</em> October 1-3, 1990, Dortmund, Germany, volume 496 of Lecture Notes in Computer Science, pages 455-469, Berlin/Heidelberg, Germany: Springer. ISBN: 978-3-540-54148-6. <a class="reference external"href=https://doi.org/10.1007/BFb0029787>https://doi.org/10.1007/BFb0029787</a>.</ol><dl class="py class"><dt class="sig sig-object py"id=moptipy.algorithms.so.general_ma.GeneralMA><em class=property><span class=k><span class=pre>class</span></span><span class=w> </span></em><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.general_ma.</span></span><span class="sig-name descname"><span class=pre>GeneralMA</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>op0</span></span></em>, <em class=sig-param><span class=n><span class=pre>op2</span></span></em>, <em class=sig-param><span class=n><span class=pre>ls</span></span></em>, <em class=sig-param><span class=n><span class=pre>mu</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>2</span></span></em>, <em class=sig-param><span class=n><span class=pre>lambda_</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>1</span></span></em>, <em class=sig-param><span class=n><span class=pre>ls_fes</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>1000</span></span></em>, <em class=sig-param><span class=n><span class=pre>fitness</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>None</span></span></em>, <em class=sig-param><span class=n><span class=pre>survival</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>None</span></span></em>, <em class=sig-param><span class=n><span class=pre>mating</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>None</span></span></em>, <em class=sig-param><span class=n><span class=pre>name</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>'generalMa'</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/general_ma.html#GeneralMA><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.general_ma.GeneralMA>¶</a><dd><p>Bases: <a class="reference internal"href=#moptipy.algorithms.so.ma.MA title=moptipy.algorithms.so.ma.MA><code class="xref py py-class docutils literal notranslate"><span class=pre>MA</span></code></a></p> <p>The fully customizable (mu+lambda) MA.</p> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.general_ma.GeneralMA.fitness><span class="sig-name descname"><span class=pre>fitness</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference internal"href=#moptipy.algorithms.so.fitness.Fitness title=moptipy.algorithms.so.fitness.Fitness><code class="xref py py-class docutils literal notranslate"><span class=pre>Fitness</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.general_ma.GeneralMA.fitness>¶</a><dd><p>the fitness assignment process</p></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.general_ma.GeneralMA.initialize><span class="sig-name descname"><span class=pre>initialize</span></span><span class=sig-paren>(</span><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/general_ma.html#GeneralMA.initialize><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.general_ma.GeneralMA.initialize>¶</a><dd><p>Initialize the algorithm.</p> <dl class="field-list simple"><dt class=field-odd>Return type<span class=colon>:</span><dd class=field-odd><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.general_ma.GeneralMA.log_parameters_to><span class="sig-name descname"><span class=pre>log_parameters_to</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>logger</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/general_ma.html#GeneralMA.log_parameters_to><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.general_ma.GeneralMA.log_parameters_to>¶</a><dd><p>Log the parameters of the algorithm to a logger.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>logger</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.utils.html#moptipy.utils.logger.KeyValueLogSection title=moptipy.utils.logger.KeyValueLogSection><code class="xref py py-class docutils literal notranslate"><span class=pre>KeyValueLogSection</span></code></a></span>) – the logger for the parameters</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.general_ma.GeneralMA.mating><span class="sig-name descname"><span class=pre>mating</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference internal"href=moptipy.algorithms.modules.html#moptipy.algorithms.modules.selection.Selection title=moptipy.algorithms.modules.selection.Selection><code class="xref py py-class docutils literal notranslate"><span class=pre>Selection</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.general_ma.GeneralMA.mating>¶</a><dd><p>the mating selection algorithm</p></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.general_ma.GeneralMA.solve><span class="sig-name descname"><span class=pre>solve</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>process</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/general_ma.html#GeneralMA.solve><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.general_ma.GeneralMA.solve>¶</a><dd><p>Apply the (mu+lambda) MA to an optimization problem.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>process</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process title=moptipy.api.process.Process><code class="xref py py-class docutils literal notranslate"><span class=pre>Process</span></code></a></span>) – the black-box process object</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.general_ma.GeneralMA.survival><span class="sig-name descname"><span class=pre>survival</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference internal"href=moptipy.algorithms.modules.html#moptipy.algorithms.modules.selection.Selection title=moptipy.algorithms.modules.selection.Selection><code class="xref py py-class docutils literal notranslate"><span class=pre>Selection</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.general_ma.GeneralMA.survival>¶</a><dd><p>the survival selection algorithm</p></dl></dl></section><section id=module-moptipy.algorithms.so.greedy_2plus1_ea_mod><span id=moptipy-algorithms-so-greedy-2plus1-ea-mod-module></span><h2>moptipy.algorithms.so.greedy_2plus1_ea_mod module<a title="Link to this heading"class=headerlink href=#module-moptipy.algorithms.so.greedy_2plus1_ea_mod>¶</a></h2><p>The modified Greedy (2+1) EAmod Evolutionary Algorithm.<p>The Greedy (2+1) EAmod maintains a population of two individuals. Both solutions, <cite>x0</cite> and <cite>x1</cite>, are intiially sampled independently and at random. Each iteration consists of two steps, a crossover step and a mutation step. The binary operator (crossover) is only applied if <cite>x0</cite> and <cite>x1</cite> have the same objective value to produce offspring <cite>z1</cite>. If <cite>x0</cite> and <cite>x1</cite> have different objective values, then <cite>z1</cite> is set to be the better of the two parents. Then, the final offspring <cite>z2</cite> is derived by applying the unary mutation operator. If <cite>z2</cite> is at least as good as the better one of <cite>x0</cite> and <cite>x1</cite>, then it will be accepted. If <cite>x1</cite> and <cite>x0</cite> are as same as good, one of them is randomly chosen to be replaced by <cite>z2</cite>. Otherwise, the worse one is replaced.<p>This is the implementation of a general black-box version of the Greedy (2+1) GAmod by Carvalho Pinto and Doerr. The original algorithm is a genetic algorithm, i.e., an EA with a bit string-based search space and a mutation operator flipping a Binomially distributed number of bits and performing uniform crossover. Here we implement is a general EA where you can plug in any crossover or mutation operator. Furthermore, the algorithm by Carvalho Pinto and Doerr is, in turn, a modified version of Sudhold’s Greedy (2+1) GA, with some improvements for efficiency.<ol class="arabic simple"><li><p>Eduardo Carvalho Pinto and Carola Doerr. Towards a More Practice-Aware Runtime Analysis of Evolutionary Algorithms. 2017. arXiv:1812.00493v1 [cs.NE] 3 Dec 2018. [Online]. http://arxiv.org/pdf/1812.00493.pdf.<li><p>Dirk Sudholt. Crossover Speeds up Building-Block Assembly. In Proceedings of the 14th Annual Conference on Genetic and Evolutionary Computation (GECCO’12), July 7-11, 2012, Philadelphia, Pennsylvania, USA, pages 689-702. ACM, 2012. <a class="reference external"href=https://doi.org/10.1145/2330163.2330260>https://doi.org/10.1145/2330163.2330260</a>.</ol><dl class="py class"><dt class="sig sig-object py"id=moptipy.algorithms.so.greedy_2plus1_ea_mod.GreedyTwoPlusOneEAmod><em class=property><span class=k><span class=pre>class</span></span><span class=w> </span></em><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.greedy_2plus1_ea_mod.</span></span><span class="sig-name descname"><span class=pre>GreedyTwoPlusOneEAmod</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>op0</span></span></em>, <em class=sig-param><span class=n><span class=pre>op1</span></span></em>, <em class=sig-param><span class=n><span class=pre>op2</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/greedy_2plus1_ea_mod.html#GreedyTwoPlusOneEAmod><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.greedy_2plus1_ea_mod.GreedyTwoPlusOneEAmod>¶</a><dd><p>Bases: <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm2 title=moptipy.api.algorithm.Algorithm2><code class="xref py py-class docutils literal notranslate"><span class=pre>Algorithm2</span></code></a></p> <p>The modified Greedy (2+1) Evolutionary Algorithm.</p> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.greedy_2plus1_ea_mod.GreedyTwoPlusOneEAmod.solve><span class="sig-name descname"><span class=pre>solve</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>process</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/greedy_2plus1_ea_mod.html#GreedyTwoPlusOneEAmod.solve><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.greedy_2plus1_ea_mod.GreedyTwoPlusOneEAmod.solve>¶</a><dd><p>Apply the EA to an optimization problem.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>process</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process title=moptipy.api.process.Process><code class="xref py py-class docutils literal notranslate"><span class=pre>Process</span></code></a></span>) – the black-box process object</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl></dl></section><section id=module-moptipy.algorithms.so.hill_climber><span id=moptipy-algorithms-so-hill-climber-module></span><h2>moptipy.algorithms.so.hill_climber module<a title="Link to this heading"class=headerlink href=#module-moptipy.algorithms.so.hill_climber>¶</a></h2><p>The implementation of the basic hill climbing algorithm <cite>hc</cite>.<p>The algorithm starts by applying the nullary search operator, an implementation of <a class="reference internal"href=moptipy.api.html#moptipy.api.operators.Op0.op0 title=moptipy.api.operators.Op0.op0><code class="xref py py-meth docutils literal notranslate"><span class=pre>op0()</span></code></a>, to sample one fully random solution. This is the first best-so-far solution. In each step, it applies the unary operator, an implementation of <a class="reference internal"href=moptipy.api.html#moptipy.api.operators.Op1.op1 title=moptipy.api.operators.Op1.op1><code class="xref py py-meth docutils literal notranslate"><span class=pre>op1()</span></code></a>, to the best-so-far solution to obtain a new, similar solution. If this new solution is strictly better than the current best-so-far solution, it replaces this solution. Otherwise, it is discarded.<p>The hill climbing algorithm is a simple local search that only accepts strictly improving moves. It is thus similar to the randomized local search (<cite>rls</cite>) implemented in <a class="reference internal"href=#moptipy.algorithms.so.rls.RLS title=moptipy.algorithms.so.rls.RLS><code class="xref py py-class docutils literal notranslate"><span class=pre>RLS</span></code></a>, which, however, accepts non-deteriorating moves. We also provide <cite>hcr</cite>, a variant of the hill climber that restarts automatically with a certain number of moves were not able to improve the current best-so-far solution in class <a class="reference internal"href=#moptipy.algorithms.so.hill_climber_with_restarts.HillClimberWithRestarts title=moptipy.algorithms.so.hill_climber_with_restarts.HillClimberWithRestarts><code class="xref py py-class docutils literal notranslate"><span class=pre>HillClimberWithRestarts</span></code></a>.<ol class="arabic simple"><li><p>Stuart Jonathan Russell and Peter Norvig. <em>Artificial Intelligence: A Modern Approach (AIMA)</em>. 2nd edition. 2002. Upper Saddle River, NJ, USA: Prentice Hall International Inc. ISBN: 0-13-080302-2<li><p>Steven S. Skiena. <em>The Algorithm Design Manual.</em> 2nd edition. 2008. London, UK: Springer-Verlag. ISBN: 978-1-84800-069-8. <a class="reference external"href=http://doi.org/10.1007/978-1-84800-070-4>http://doi.org/10.1007/978-1-84800-070-4</a>.<li><p>David Stifler Johnson, Christos H. Papadimitriou, and Mihalis Yannakakis. How Easy Is Local Search? Journal of Computer and System Sciences. 37(1):79-100. August 1988. <a class="reference external"href=http://doi.org/10.1016/0022-0000(88)90046-3>http://doi.org/10.1016/0022-0000(88)90046-3</a> <a class="reference external"href=http://www2.karlin.mff.cuni.cz/~krajicek/jpy2.pdf>http://www2.karlin.mff.cuni.cz/~krajicek/jpy2.pdf</a><li><p>James C. Spall. <em>Introduction to Stochastic Search and Optimization.</em> April 2003. Estimation, Simulation, and Control – Wiley-Interscience Series in Discrete Mathematics and Optimization, volume 6. Chichester, West Sussex, UK: Wiley Interscience. ISBN: 0-471-33052-3. <a class="reference external"href=http://www.jhuapl.edu/ISSO/>http://www.jhuapl.edu/ISSO/</a><li><p>Holger H. Hoos and Thomas Stützle. <em>Stochastic Local Search: Foundations and Applications.</em> 2005. ISBN: 1493303732. In The Morgan Kaufmann Series in Artificial Intelligence. Amsterdam, The Netherlands: Elsevier.<li><p>Thomas Weise. <em>Optimization Algorithms.</em> 2021. Hefei, Anhui, China: Institute of Applied Optimization (IAO), School of Artificial Intelligence and Big Data, Hefei University. <a class="reference external"href=http://thomasweise.github.io/oa/>http://thomasweise.github.io/oa/</a><li><p>Thomas Weise. <em>Global Optimization Algorithms - Theory and Application.</em> 2009. <a class="reference external"href=http://www.it-weise.de/projects/book.pdf>http://www.it-weise.de/projects/book.pdf</a></ol><dl class="py class"><dt class="sig sig-object py"id=moptipy.algorithms.so.hill_climber.HillClimber><em class=property><span class=k><span class=pre>class</span></span><span class=w> </span></em><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.hill_climber.</span></span><span class="sig-name descname"><span class=pre>HillClimber</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>op0</span></span></em>, <em class=sig-param><span class=n><span class=pre>op1</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/hill_climber.html#HillClimber><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.hill_climber.HillClimber>¶</a><dd><p>Bases: <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm1 title=moptipy.api.algorithm.Algorithm1><code class="xref py py-class docutils literal notranslate"><span class=pre>Algorithm1</span></code></a></p> <p>The stochastic hill climbing algorithm only accepts improving moves.</p> <p>In each step, a hill climber creates a modified copy <cite>new_x</cite> of the current best solution <cite>best_x</cite>. If <cite>new_x</cite> is better than <cite>best_x</cite>, it becomes the new <cite>best_x</cite>. Otherwise, it is discarded.</p> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.hill_climber.HillClimber.solve><span class="sig-name descname"><span class=pre>solve</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>process</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/hill_climber.html#HillClimber.solve><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.hill_climber.HillClimber.solve>¶</a><dd><p>Apply the hill climber to an optimization problem.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>process</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process title=moptipy.api.process.Process><code class="xref py py-class docutils literal notranslate"><span class=pre>Process</span></code></a></span>) – the black-box process object</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl></dl></section><section id=module-moptipy.algorithms.so.hill_climber_with_restarts><span id=moptipy-algorithms-so-hill-climber-with-restarts-module></span><h2>moptipy.algorithms.so.hill_climber_with_restarts module<a title="Link to this heading"class=headerlink href=#module-moptipy.algorithms.so.hill_climber_with_restarts>¶</a></h2><p>The implementation of the hill climbing algorithm with restarts <cite>hcr</cite>.<p>This algorithm basically works like the normal hill climber <cite>hc</cite> (<a class="reference internal"href=#moptipy.algorithms.so.hill_climber.HillClimber title=moptipy.algorithms.so.hill_climber.HillClimber><code class="xref py py-class docutils literal notranslate"><span class=pre>HillClimber</span></code></a>), but it will restart automatically if no move was successful for <cite>max_moves_without_improvement</cite> iterative steps. It therefore maintains an internal counter <cite>count</cite> which is set to zero at the beginning of each restart and which is also set to zero again any time a move successfully improved the best-so-far solution of the current restart. If a search move, i.e., an application of the unary operator, yielded a new solution which is not better than the best-so-far solution of the current restart, <cite>count</cite> is incremented. If <cite>count >= max_moves_without_improvement</cite>, the algorithm begins a new restart with a new random solution.<ol class="arabic simple"><li><p>Thomas Weise. <em>Optimization Algorithms.</em> 2021. Hefei, Anhui, China: Institute of Applied Optimization (IAO), School of Artificial Intelligence and Big Data, Hefei University. <a class="reference external"href=http://thomasweise.github.io/oa/>http://thomasweise.github.io/oa/</a></ol><dl class="py class"><dt class="sig sig-object py"id=moptipy.algorithms.so.hill_climber_with_restarts.HillClimberWithRestarts><em class=property><span class=k><span class=pre>class</span></span><span class=w> </span></em><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.hill_climber_with_restarts.</span></span><span class="sig-name descname"><span class=pre>HillClimberWithRestarts</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>op0</span></span></em>, <em class=sig-param><span class=n><span class=pre>op1</span></span></em>, <em class=sig-param><span class=n><span class=pre>max_moves_without_improvement</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/hill_climber_with_restarts.html#HillClimberWithRestarts><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.hill_climber_with_restarts.HillClimberWithRestarts>¶</a><dd><p>Bases: <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm1 title=moptipy.api.algorithm.Algorithm1><code class="xref py py-class docutils literal notranslate"><span class=pre>Algorithm1</span></code></a></p> <p>The stochastic hill climbing algorithm only accepts improving moves.</p> <p>In each step, a hill climber creates a modified copy <cite>new_x</cite> of the current best solution <cite>best_x</cite>. If <cite>new_x</cite> is better than <cite>best_x</cite>, it becomes the new <cite>best_x</cite>. Otherwise, it is discarded. If no improvement is made for <cite>max_moves_without_improvement</cite> steps, the algorithm restarts.</p> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.hill_climber_with_restarts.HillClimberWithRestarts.log_parameters_to><span class="sig-name descname"><span class=pre>log_parameters_to</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>logger</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/hill_climber_with_restarts.html#HillClimberWithRestarts.log_parameters_to><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.hill_climber_with_restarts.HillClimberWithRestarts.log_parameters_to>¶</a><dd><p>Log all parameters of this component as key-value pairs.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>logger</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.utils.html#moptipy.utils.logger.KeyValueLogSection title=moptipy.utils.logger.KeyValueLogSection><code class="xref py py-class docutils literal notranslate"><span class=pre>KeyValueLogSection</span></code></a></span>) – the logger for the parameters</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.hill_climber_with_restarts.HillClimberWithRestarts.max_moves_without_improvement><span class="sig-name descname"><span class=pre>max_moves_without_improvement</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/functions.html#int><code class="xref py py-class docutils literal notranslate"><span class=pre>int</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.hill_climber_with_restarts.HillClimberWithRestarts.max_moves_without_improvement>¶</a><dd><p>the maximum moves without improvement</p></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.hill_climber_with_restarts.HillClimberWithRestarts.solve><span class="sig-name descname"><span class=pre>solve</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>process</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/hill_climber_with_restarts.html#HillClimberWithRestarts.solve><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.hill_climber_with_restarts.HillClimberWithRestarts.solve>¶</a><dd><p>Apply the hill climber with restarts to an optimization problem.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>process</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process title=moptipy.api.process.Process><code class="xref py py-class docutils literal notranslate"><span class=pre>Process</span></code></a></span>) – the black-box process object</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl></dl></section><section id=module-moptipy.algorithms.so.ma><span id=moptipy-algorithms-so-ma-module></span><h2>moptipy.algorithms.so.ma module<a title="Link to this heading"class=headerlink href=#module-moptipy.algorithms.so.ma>¶</a></h2><p>A simple implementation of a (mu+lambda) Memetic Algorithm.<p>A memetic algorithm (<a class="reference internal"href=#moptipy.algorithms.so.ma.MA title=moptipy.algorithms.so.ma.MA><code class="xref py py-class docutils literal notranslate"><span class=pre>MA</span></code></a>) works similar to a (mu+lambda) <a class="reference internal"href=#moptipy.algorithms.so.ea.EA title=moptipy.algorithms.so.ea.EA><code class="xref py py-class docutils literal notranslate"><span class=pre>EA</span></code></a>, but it refines all results of the search operators with a local search <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls title=moptipy.algorithms.so.ma.MA.ls><code class="xref py py-attr docutils literal notranslate"><span class=pre>ls</span></code></a> executed for <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls_fes title=moptipy.algorithms.so.ma.MA.ls_fes><code class="xref py py-attr docutils literal notranslate"><span class=pre>ls_fes</span></code></a> objective function evaluations. It also only employs the nullary search operator (to create the initial random solutions) and the binary search operator (to combine two selected parental solutions).<p>This is the general form of the Memetic Algorithm of the type “EA+something else.” A specialized version combining an <a class="reference internal"href=#module-moptipy.algorithms.so.ea title=moptipy.algorithms.so.ea><code class="xref py py-mod docutils literal notranslate"><span class=pre>ea</span></code></a> with <a class="reference internal"href=#module-moptipy.algorithms.so.rls title=moptipy.algorithms.so.rls><code class="xref py py-mod docutils literal notranslate"><span class=pre>rls</span></code></a> can be found in <a class="reference internal"href=#module-moptipy.algorithms.so.marls title=moptipy.algorithms.so.marls><code class="xref py py-mod docutils literal notranslate"><span class=pre>marls</span></code></a>.<p>This Memetic Algorithm implementation begins by sampling <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.mu title=moptipy.algorithms.so.ma.MA.mu><code class="xref py py-attr docutils literal notranslate"><span class=pre>mu</span></code></a> solutions using the nullary search operation <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm0.op0 title=moptipy.api.algorithm.Algorithm0.op0><code class="xref py py-attr docutils literal notranslate"><span class=pre>op0</span></code></a>. Each of these initial solutions is used as a starting point of a local search <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls title=moptipy.algorithms.so.ma.MA.ls><code class="xref py py-attr docutils literal notranslate"><span class=pre>ls</span></code></a>, which is executed for <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls_fes title=moptipy.algorithms.so.ma.MA.ls_fes><code class="xref py py-attr docutils literal notranslate"><span class=pre>ls_fes</span></code></a> objective function evaluations. In each iteration, it then uses the <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.mu title=moptipy.algorithms.so.ma.MA.mu><code class="xref py py-attr docutils literal notranslate"><span class=pre>mu</span></code></a> existing solutions as input for the binary search operator <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.op2 title=moptipy.algorithms.so.ma.MA.op2><code class="xref py py-attr docutils literal notranslate"><span class=pre>op2</span></code></a> to create <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.lambda_ title=moptipy.algorithms.so.ma.MA.lambda_><code class="xref py py-attr docutils literal notranslate"><span class=pre>lambda_</span></code></a> new solutions, each of which is again used as a starting point of a local search <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls title=moptipy.algorithms.so.ma.MA.ls><code class="xref py py-attr docutils literal notranslate"><span class=pre>ls</span></code></a> executed for <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls_fes title=moptipy.algorithms.so.ma.MA.ls_fes><code class="xref py py-attr docutils literal notranslate"><span class=pre>ls_fes</span></code></a> objective function evaluations. The results of the local searches enter the population and in the next iteration, the <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.mu title=moptipy.algorithms.so.ma.MA.mu><code class="xref py py-attr docutils literal notranslate"><span class=pre>mu</span></code></a> best solutions of the <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.mu title=moptipy.algorithms.so.ma.MA.mu><code class="xref py py-attr docutils literal notranslate"><span class=pre>mu</span></code></a> + <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.lambda_ title=moptipy.algorithms.so.ma.MA.lambda_><code class="xref py py-attr docutils literal notranslate"><span class=pre>lambda_</span></code></a> ones in the population are retained.<p>Due to the <a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process title=moptipy.api.process.Process><code class="xref py py-class docutils literal notranslate"><span class=pre>Process</span></code></a> and <a class="reference internal"href=moptipy.api.html#module-moptipy.api.subprocesses title=moptipy.api.subprocesses><code class="xref py py-mod docutils literal notranslate"><span class=pre>subprocesses</span></code></a> API of <cite>moptipy</cite>, you can use almost arbitrary algorithms as local search <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls title=moptipy.algorithms.so.ma.MA.ls><code class="xref py py-attr docutils literal notranslate"><span class=pre>ls</span></code></a>. The only requirement is that is a subclass of <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm0 title=moptipy.api.algorithm.Algorithm0><code class="xref py py-class docutils literal notranslate"><span class=pre>Algorithm0</span></code></a> and uses it uses an instance of <a class="reference internal"href=moptipy.operators.html#moptipy.operators.op0_forward.Op0Forward title=moptipy.operators.op0_forward.Op0Forward><code class="xref py py-class docutils literal notranslate"><span class=pre>moptipy.operators.op0_forward.Op0Forward</span></code></a> as nullary search operator (<a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm0.op0 title=moptipy.api.algorithm.Algorithm0.op0><code class="xref py py-attr docutils literal notranslate"><span class=pre>op0</span></code></a>). This allows the MA to set a solution as starting point for the inner algorithm <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls title=moptipy.algorithms.so.ma.MA.ls><code class="xref py py-attr docutils literal notranslate"><span class=pre>ls</span></code></a>.<p>It should be noted that it is by no means required that the inner algorithm <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls title=moptipy.algorithms.so.ma.MA.ls><code class="xref py py-attr docutils literal notranslate"><span class=pre>ls</span></code></a> needs to be a local search. Any algorithm that fulfills the above requirements could be used. For example, if we were conducting numerical optimization, it would be totally OK to plug an instance of the Sequential Least Squares Programming (<a class="reference internal"href=moptipy.algorithms.so.vector.html#moptipy.algorithms.so.vector.scipy.SLSQP title=moptipy.algorithms.so.vector.scipy.SLSQP><code class="xref py py-class docutils literal notranslate"><span class=pre>SLSQP</span></code></a>) algorithm into the memetic algorithm&amphellip;<p>Further reading on how to realize using one algorithm as a sub-algorithm of another one can be found in the documentation of <a class="reference internal"href=moptipy.api.html#moptipy.api.subprocesses.from_starting_point title=moptipy.api.subprocesses.from_starting_point><code class="xref py py-func docutils literal notranslate"><span class=pre>from_starting_point()</span></code></a>, <a class="reference internal"href=moptipy.api.html#moptipy.api.subprocesses.for_fes title=moptipy.api.subprocesses.for_fes><code class="xref py py-func docutils literal notranslate"><span class=pre>for_fes()</span></code></a>, and <a class="reference internal"href=moptipy.operators.html#moptipy.operators.op0_forward.Op0Forward title=moptipy.operators.op0_forward.Op0Forward><code class="xref py py-class docutils literal notranslate"><span class=pre>moptipy.operators.op0_forward.Op0Forward</span></code></a>.<ol class="arabic simple"><li><p>Pablo Moscato. <em>On Evolution, Search, Optimization, Genetic Algorithms and Martial Arts: Towards Memetic Algorithms.</em> Caltech Concurrent Computation Program Report C3P 826. 1989. Pasadena, CA, USA: California Institute of Technology (Caltech), Caltech Concurrent Computation Program (C3P). <a class="reference external"href=https://www.researchgate.net/publication/2354457>https://www.researchgate.net/publication/2354457</a><li><p>Carlos Cotta, Luke Mathieson, and Pablo Moscato. Memetic Algorithms. In Rafael Martí, Panos M. Pardalos, and Mauricio G. C. Resende, editors, <em>Handbook of Heuristics.</em> Part~III: Metaheuristics, pages 607-638. 2018. Cham, Switzerland: Springer. ISBN: 978-3-319-07123-7. doi: <a class="reference external"href=https://doi.org/10.1007/978-3-319-07153-4_29-1>https://doi.org/10.1007/978-3-319-07153-4_29-1</a> <a class="reference external"href=https://www.researchgate.net/publication/315660932>https://www.researchgate.net/publication/315660932</a><li><p>William Eugene Hart, James E. Smith, and Natalio Krasnogor, editors. <em>Recent Advances in Memetic Algorithms.</em> Studies in Fuzziness and Soft Computing (STUDFUZZ), volume 166. 2005. Berlin/Heidelberg, Germany: Springer. ISBN: 978-3-540-22904-9. doi: <a class="reference external"href=https://doi.org/10.1007/3-540-32363-5>https://doi.org/10.1007/3-540-32363-5</a><li><p>Ferrante Neri, Carlos Cotta, and Pablo Moscato. <em>Handbook of Memetic Algorithms.</em> Volume 379 of Studies in Computational Intelligence (SCI). 2012. Berlin/Heidelberg, Germany: Springer. ISBN: 978-3-642-23246-6 doi <a class="reference external"href=https://doi.org/10.1007/978-3-642-23247-3>https://doi.org/10.1007/978-3-642-23247-3</a>.<li><p>L. Darrell Whitley, V. Scott Gordon, and Keith E. Mathias. Lamarckian Evolution, The Baldwin Effect and Function Optimization. In Yuval Davidor, Hans-Paul Schwefel, and Reinhard Männer, editors, <em>Proceedings of the Third Conference on Parallel Problem Solving from Nature; International Conference on Evolutionary Computation (PPSN III),</em> October 9-14, 1994, Jerusalem, Israel, pages 5-15. Volume 866/1994 of Lecture Notes in Computer Science, Berlin, Germany: Springer-Verlag GmbH. ISBN 0387584846. doi: <a class="reference external"href=https://doi.org/10.1007/3-540-58484-6_245>https://doi.org/10.1007/3-540-58484-6_245</a>. <a class="reference external"href=https://www.researchgate.net/publication/2521727>https://www.researchgate.net/publication/2521727</a></ol><dl class="py class"><dt class="sig sig-object py"id=moptipy.algorithms.so.ma.MA><em class=property><span class=k><span class=pre>class</span></span><span class=w> </span></em><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.ma.</span></span><span class="sig-name descname"><span class=pre>MA</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>op0</span></span></em>, <em class=sig-param><span class=n><span class=pre>op2</span></span></em>, <em class=sig-param><span class=n><span class=pre>ls</span></span></em>, <em class=sig-param><span class=n><span class=pre>mu</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>2</span></span></em>, <em class=sig-param><span class=n><span class=pre>lambda_</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>1</span></span></em>, <em class=sig-param><span class=n><span class=pre>ls_fes</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>1000</span></span></em>, <em class=sig-param><span class=n><span class=pre>name</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>'ma'</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/ma.html#MA><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ma.MA>¶</a><dd><p>Bases: <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm0 title=moptipy.api.algorithm.Algorithm0><code class="xref py py-class docutils literal notranslate"><span class=pre>Algorithm0</span></code></a></p> <p>An MA is a population-based algorithm using binary operators.</p> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.ma.MA.initialize><span class="sig-name descname"><span class=pre>initialize</span></span><span class=sig-paren>(</span><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/ma.html#MA.initialize><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ma.MA.initialize>¶</a><dd><p>Initialize the memetic algorithm.</p> <dl class="field-list simple"><dt class=field-odd>Return type<span class=colon>:</span><dd class=field-odd><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.ma.MA.lambda_><span class="sig-name descname"><span class=pre>lambda_</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/functions.html#int><code class="xref py py-class docutils literal notranslate"><span class=pre>int</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ma.MA.lambda_>¶</a><dd><p>the number of offsprings per generation</p></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.ma.MA.log_parameters_to><span class="sig-name descname"><span class=pre>log_parameters_to</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>logger</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/ma.html#MA.log_parameters_to><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ma.MA.log_parameters_to>¶</a><dd><p>Log the parameters of the algorithm to a logger.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>logger</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.utils.html#moptipy.utils.logger.KeyValueLogSection title=moptipy.utils.logger.KeyValueLogSection><code class="xref py py-class docutils literal notranslate"><span class=pre>KeyValueLogSection</span></code></a></span>) – the logger for the parameters</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.ma.MA.ls><span class="sig-name descname"><span class=pre>ls</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm0 title=moptipy.api.algorithm.Algorithm0><code class="xref py py-class docutils literal notranslate"><span class=pre>Algorithm0</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ma.MA.ls>¶</a><dd><p>the local search algorithm</p></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.ma.MA.ls_fes><span class="sig-name descname"><span class=pre>ls_fes</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/functions.html#int><code class="xref py py-class docutils literal notranslate"><span class=pre>int</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ma.MA.ls_fes>¶</a><dd><p>the number of FEs per local search run</p></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.ma.MA.mu><span class="sig-name descname"><span class=pre>mu</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/functions.html#int><code class="xref py py-class docutils literal notranslate"><span class=pre>int</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ma.MA.mu>¶</a><dd><p>the number of records to survive in each generation</p></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.ma.MA.op2><span class="sig-name descname"><span class=pre>op2</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference internal"href=moptipy.api.html#moptipy.api.operators.Op2 title=moptipy.api.operators.Op2><code class="xref py py-class docutils literal notranslate"><span class=pre>Op2</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ma.MA.op2>¶</a><dd><p>The binary search operator.</p></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.ma.MA.solve><span class="sig-name descname"><span class=pre>solve</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>process</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/ma.html#MA.solve><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ma.MA.solve>¶</a><dd><p>Apply the MA to an optimization problem.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>process</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process title=moptipy.api.process.Process><code class="xref py py-class docutils literal notranslate"><span class=pre>Process</span></code></a></span>) – the black-box process object</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl></dl></section><section id=module-moptipy.algorithms.so.marls><span id=moptipy-algorithms-so-marls-module></span><h2>moptipy.algorithms.so.marls module<a title="Link to this heading"class=headerlink href=#module-moptipy.algorithms.so.marls>¶</a></h2><p>A (mu+lambda) Memetic Algorithm using Randomized Local Search (RLS).<p>A memetic algorithm (<a class="reference internal"href=#moptipy.algorithms.so.ma.MA title=moptipy.algorithms.so.ma.MA><code class="xref py py-class docutils literal notranslate"><span class=pre>MA</span></code></a>) works similar to a (mu+lambda) <a class="reference internal"href=#moptipy.algorithms.so.ea.EA title=moptipy.algorithms.so.ea.EA><code class="xref py py-class docutils literal notranslate"><span class=pre>EA</span></code></a>, but it refines all results of the search operators with a local search, in this case, <a class="reference internal"href=#moptipy.algorithms.so.rls.RLS title=moptipy.algorithms.so.rls.RLS><code class="xref py py-class docutils literal notranslate"><span class=pre>RLS</span></code></a>, which is executed for <a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls_fes title=moptipy.algorithms.so.ma.MA.ls_fes><code class="xref py py-attr docutils literal notranslate"><span class=pre>ls_fes</span></code></a> objective function evaluations. It also only employs the nullary search operator (to create the initial random solutions) and the binary search operator (to combine two selected parental solutions), leaving the application of the unary search operator to the RLS.<p>A general implementation of a Memetic Algorithm into which arbitrary algorithms can be plugged is given in <a class="reference internal"href=#module-moptipy.algorithms.so.ma title=moptipy.algorithms.so.ma><code class="xref py py-mod docutils literal notranslate"><span class=pre>ma</span></code></a>. Here, the RLS part and the EA part of the MA are directly merged in a hard-coded fashion. If the general <a class="reference internal"href=#moptipy.algorithms.so.ma.MA title=moptipy.algorithms.so.ma.MA><code class="xref py py-class docutils literal notranslate"><span class=pre>MA</span></code></a> is configured equivalently to the <a class="reference internal"href=#moptipy.algorithms.so.marls.MARLS title=moptipy.algorithms.so.marls.MARLS><code class="xref py py-class docutils literal notranslate"><span class=pre>MARLS</span></code></a> here, i.e., uses the same search operators, same <cite>mu</cite>, <cite>lambda_</cite>, and <cite>ls_fes</cite>, then both algorithms will do exactly the same search steps.<ol class="arabic simple"><li><p>Pablo Moscato. <em>On Evolution, Search, Optimization, Genetic Algorithms and Martial Arts: Towards Memetic Algorithms.</em> Caltech Concurrent Computation Program Report C3P 826. 1989. Pasadena, CA, USA: California Institute of Technology (Caltech), Caltech Concurrent Computation Program (C3P). <a class="reference external"href=https://www.researchgate.net/publication/2354457>https://www.researchgate.net/publication/2354457</a><li><p>Carlos Cotta, Luke Mathieson, and Pablo Moscato. Memetic Algorithms. In Rafael Martí, Panos M. Pardalos, and Mauricio G. C. Resende, editors, <em>Handbook of Heuristics.</em> Part~III: Metaheuristics, pages 607-638. 2018. Cham, Switzerland: Springer. ISBN: 978-3-319-07123-7. doi: <a class="reference external"href=https://doi.org/10.1007/978-3-319-07153-4_29-1>https://doi.org/10.1007/978-3-319-07153-4_29-1</a> <a class="reference external"href=https://www.researchgate.net/publication/315660932>https://www.researchgate.net/publication/315660932</a><li><p>William Eugene Hart, James E. Smith, and Natalio Krasnogor, editors. <em>Recent Advances in Memetic Algorithms.</em> Studies in Fuzziness and Soft Computing (STUDFUZZ), volume 166. 2005. Berlin/Heidelberg, Germany: Springer. ISBN: 978-3-540-22904-9. doi: <a class="reference external"href=https://doi.org/10.1007/3-540-32363-5>https://doi.org/10.1007/3-540-32363-5</a><li><p>Ferrante Neri, Carlos Cotta, and Pablo Moscato. <em>Handbook of Memetic Algorithms.</em> Volume 379 of Studies in Computational Intelligence (SCI). 2012. Berlin/Heidelberg, Germany: Springer. ISBN: 978-3-642-23246-6 doi <a class="reference external"href=https://doi.org/10.1007/978-3-642-23247-3>https://doi.org/10.1007/978-3-642-23247-3</a>.<li><p>L. Darrell Whitley, V. Scott Gordon, and Keith E. Mathias. Lamarckian Evolution, The Baldwin Effect and Function Optimization. In Yuval Davidor, Hans-Paul Schwefel, and Reinhard Männer, editors, <em>Proceedings of the Third Conference on Parallel Problem Solving from Nature; International Conference on Evolutionary Computation (PPSN III),</em> October 9-14, 1994, Jerusalem, Israel, pages 5-15. Volume 866/1994 of Lecture Notes in Computer Science, Berlin, Germany: Springer-Verlag GmbH. ISBN 0387584846. doi: <a class="reference external"href=https://doi.org/10.1007/3-540-58484-6_245>https://doi.org/10.1007/3-540-58484-6_245</a>. <a class="reference external"href=https://www.researchgate.net/publication/2521727>https://www.researchgate.net/publication/2521727</a></ol><dl class="py class"><dt class="sig sig-object py"id=moptipy.algorithms.so.marls.MARLS><em class=property><span class=k><span class=pre>class</span></span><span class=w> </span></em><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.marls.</span></span><span class="sig-name descname"><span class=pre>MARLS</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>op0</span></span></em>, <em class=sig-param><span class=n><span class=pre>op1</span></span></em>, <em class=sig-param><span class=n><span class=pre>op2</span></span></em>, <em class=sig-param><span class=n><span class=pre>mu</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>1</span></span></em>, <em class=sig-param><span class=n><span class=pre>lambda_</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>1</span></span></em>, <em class=sig-param><span class=n><span class=pre>ls_fes</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>1000</span></span></em>, <em class=sig-param><span class=n><span class=pre>name</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>'marls'</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/marls.html#MARLS><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.marls.MARLS>¶</a><dd><p>Bases: <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm2 title=moptipy.api.algorithm.Algorithm2><code class="xref py py-class docutils literal notranslate"><span class=pre>Algorithm2</span></code></a></p> <p>A Memetic Algorithm as Evolutionary Algorithm + Randomized Local Search.</p> <p>This class implements a Memetic Algorithm (MA) basically as an Evolutionary Algorithm (EA), which only uses the nullary and binary search operators, and that refines each newly generated solution by applying a Randomized Local Search (RLS), which employs the unary search operator.</p> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.marls.MARLS.lambda_><span class="sig-name descname"><span class=pre>lambda_</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/functions.html#int><code class="xref py py-class docutils literal notranslate"><span class=pre>int</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.marls.MARLS.lambda_>¶</a><dd><p>the number of offsprings per generation</p></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.marls.MARLS.log_parameters_to><span class="sig-name descname"><span class=pre>log_parameters_to</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>logger</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/marls.html#MARLS.log_parameters_to><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.marls.MARLS.log_parameters_to>¶</a><dd><p>Log the parameters of the algorithm to a logger.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>logger</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.utils.html#moptipy.utils.logger.KeyValueLogSection title=moptipy.utils.logger.KeyValueLogSection><code class="xref py py-class docutils literal notranslate"><span class=pre>KeyValueLogSection</span></code></a></span>) – the logger for the parameters</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.marls.MARLS.ls_fes><span class="sig-name descname"><span class=pre>ls_fes</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/functions.html#int><code class="xref py py-class docutils literal notranslate"><span class=pre>int</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.marls.MARLS.ls_fes>¶</a><dd><p>the number of FEs per local search run</p></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.marls.MARLS.mu><span class="sig-name descname"><span class=pre>mu</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/functions.html#int><code class="xref py py-class docutils literal notranslate"><span class=pre>int</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.marls.MARLS.mu>¶</a><dd><p>the number of records to survive in each generation</p></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.marls.MARLS.solve><span class="sig-name descname"><span class=pre>solve</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>process</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/marls.html#MARLS.solve><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.marls.MARLS.solve>¶</a><dd><p>Apply the MA=EA+RLS to an optimization problem.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>process</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process title=moptipy.api.process.Process><code class="xref py py-class docutils literal notranslate"><span class=pre>Process</span></code></a></span>) – the black-box process object</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl></dl></section><section id=module-moptipy.algorithms.so.ppa><span id=moptipy-algorithms-so-ppa-module></span><h2>moptipy.algorithms.so.ppa module<a title="Link to this heading"class=headerlink href=#module-moptipy.algorithms.so.ppa>¶</a></h2><p>A simple implementation of a Plant Propagation Algorithm (PPA).<p>This is a simple implementation of the Plant Propagation Algorithm, PPA for short, with some tweaks and modifications. Our PPA implementation works as follows:<ol class="arabic simple"><li><p>It starts with a set of <a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.m title=moptipy.algorithms.so.ppa.PPA.m><code class="xref py py-attr docutils literal notranslate"><span class=pre>m</span></code></a> randomly sampled solutions in the list <cite>lst</cite>. Each solution <cite>x</cite> is evaluated and its objective value <cite>f(x)</cite> is remembered.<li><p>In the main loop…</p> <ol class="loweralpha simple"><li><p>First, the range <cite>[fmin,fmax]</cite> of the objective values of the first <a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.m title=moptipy.algorithms.so.ppa.PPA.m><code class="xref py py-attr docutils literal notranslate"><span class=pre>m</span></code></a> solutions in <cite>lst</cite> is determined. We set <cite>frange = fmax - fmin</cite>, where <cite>fmax</cite> is the largest objective value of any of the first <cite>m</cite> solutions in <cite>lst</cite> and <cite>fmin</cite> is the smallest one. If <cite>frange > 0</cite>, then the fitness <cite>z(x)</cite> of each element be <cite>(f(x) - fmin) / frange</cite>. Otherwise, i.e., if all solutions in <cite>lst</cite> have the same objective value, we set <cite>z(x)</cite> to be a random number uniformly distributed in <cite>[0,1)</cite> and drawn separately for each solution.<li><p>For each of the first <a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.m title=moptipy.algorithms.so.ppa.PPA.m><code class="xref py py-attr docutils literal notranslate"><span class=pre>m</span></code></a> solutions <cite>x</cite> in <cite>lst</cite>, we create <cite>1 + int(nmax * r * (1 - z(x)))</cite> offspring, where <a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.nmax title=moptipy.algorithms.so.ppa.PPA.nmax><code class="xref py py-attr docutils literal notranslate"><span class=pre>nmax</span></code></a> is the maximum number of offspring per solution and <cite>r</cite> be again an independently drawn random number uniformly distributed in <cite>[0,1)</cite>. In other words, solutions with a fitness close to zero will produce more offspring. If the solutions in the list <cite>lst</cite> have different objective values, then this means that better solutions produce more offsprings. Each such offspring is the result of the application of a unary operator with step size, i.e., an instance of <a class="reference internal"href=moptipy.api.html#moptipy.api.operators.Op1WithStepSize title=moptipy.api.operators.Op1WithStepSize><code class="xref py py-class docutils literal notranslate"><span class=pre>Op1WithStepSize</span></code></a>. The step size is set to <cite>r * max_step * z(x)</cite>, where <cite>r</cite> again is a freshly and independently drawn random number uniformly distributed in <cite>[0,1)</cite>. This means that better solutions are modified with smaller step sizes and worse solutions are modified more strongly. <a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.max_step title=moptipy.algorithms.so.ppa.PPA.max_step><code class="xref py py-attr docutils literal notranslate"><span class=pre>max_step</span></code></a> is a parameter of the algorithm that determines the maximum permissible step size. It is always from the interval <cite>[0,1]</cite>. Examples for such operators are given in <a class="reference internal"href=moptipy.operators.permutations.html#module-moptipy.operators.permutations.op1_swap_exactly_n title=moptipy.operators.permutations.op1_swap_exactly_n><code class="xref py py-mod docutils literal notranslate"><span class=pre>op1_swap_exactly_n</span></code></a>, <a class="reference internal"href=moptipy.operators.permutations.html#module-moptipy.operators.permutations.op1_swap_try_n title=moptipy.operators.permutations.op1_swap_try_n><code class="xref py py-mod docutils literal notranslate"><span class=pre>op1_swap_try_n</span></code></a>, or <a class="reference internal"href=moptipy.operators.bitstrings.html#module-moptipy.operators.bitstrings.op1_flip_m title=moptipy.operators.bitstrings.op1_flip_m><code class="xref py py-mod docutils literal notranslate"><span class=pre>op1_flip_m</span></code></a>. The new solutions are appended into <cite>lst</cite> and their objective values are computed.<li><p>The list is then sorted by objective values in ascending order, meaning that the best solutions are up front.</ol></ol><p>The main differences between this procedure and the “standard-PPA” are as follows:<ol class="upperalpha simple"><li><p>The algorithm is implemented for minimization and all equations are modified accordingly.<li><p>After normalizing the objective values in the population, the <cite>tanh</cite>-based scaling is <em>not</em> applied. Instead, the normalized objective values, where <cite>0</cite> is best and <cite>1</cite> is worst, are used directly to determine the number of offspring per record and the step length.<li><p>The fitness of a record equals its normalized objective value (in <cite>[0, 1]</cite>), unless all records have the same objective value, in which case the fitness of each record is set to a random number uniformly distributed in <cite>[0, 1)</cite>. If all elements in the population have the same objective value, normalizing is not possible as it would lead to a division by zero. One could use a constant value, say <cite>0.5</cite>, in this case, but there is no guarantee that this would be a good choice. We therefore use random values from <cite>[0, 1)</cite> instead. These may sometimes be suitable, sometimes not. But at least they likely are not <em>always</em> a bad choice, which might happen in some scenarios with <cite>0.5</cite> or any other constant.<li><p>The decisions regarding the number of offspring per selected record and the step-width of the search moves are made only based on this fitness (and, again, not on the <cite>tanh</cite> scaling which is not used). Since we normally do not know the characteristics of the objective function in advance, I think that we also often do not know whether a <cite>tanh</cite> scaling (that emphasizes objective values close to the best and close to the worst) is necessary or a good idea. It could be good in some cases, but it might as well be a bad choice in others. For now, I have thus not implemented this and just use the raw normalized objective values.<li><p>As unary operators, we employ instances of the class <a class="reference internal"href=moptipy.api.html#moptipy.api.operators.Op1WithStepSize title=moptipy.api.operators.Op1WithStepSize><code class="xref py py-class docutils literal notranslate"><span class=pre>Op1WithStepSize</span></code></a>, which provides a unary operator with a step size between <cite>0</cite> (smallest possible modification) to <cite>1</cite> (largest possible modification) and will scale appropriately between the two extremes. Often, instances of this class will determine the number or magnitude of changes based on an exponential scaling (see <a class="reference internal"href=moptipy.operators.html#moptipy.operators.tools.exponential_step_size title=moptipy.operators.tools.exponential_step_size><code class="xref py py-func docutils literal notranslate"><span class=pre>exponential_step_size()</span></code></a>) of the step length. The idea is that small step sizes should be emphasized and that really big step sizes are often rarely needed. This thus effectively takes the place of the <cite>tanh</cite> scaling.<li><p>Maximum step lengths, i.e., the parameter <a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.max_step title=moptipy.algorithms.so.ppa.PPA.max_step><code class="xref py py-attr docutils literal notranslate"><span class=pre>max_step</span></code></a>, are not always explicitly used in some of the papers.</ol><p>In order to understand the behavior of the algorithm, consider the following case. Assume that we set the maximum number (<a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.nmax title=moptipy.algorithms.so.ppa.PPA.nmax><code class="xref py py-attr docutils literal notranslate"><span class=pre>nmax</span></code></a>) of offspring per solution to <cite>1</cite> and the number <a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.m title=moptipy.algorithms.so.ppa.PPA.m><code class="xref py py-attr docutils literal notranslate"><span class=pre>m</span></code></a> of solutions to survive selection to <cite>1</cite> as well. In this case, the PPA has exactly the same “population structure” as the Randomized Local Search (<a class="reference internal"href=#module-moptipy.algorithms.so.rls title=moptipy.algorithms.so.rls><code class="xref py py-mod docutils literal notranslate"><span class=pre>rls</span></code></a>), namely it preserves the best-so-far solution and generates one new solution in each step, which then competes with that best-so-far solution. The two algorithms then only differ in their search operator: The step-length of the unary operator used in PPA depends on the relative objective value and the one of the RLS does not. However, there are many situations where the two could still be equivalent. For example, if the current and new solution have different objective values, normalizing the objective value will mean that the best of the two has normalized objective value “0”. This equates to the shortest possible step length. In this case, for example, the step-length based operator <a class="reference internal"href=moptipy.operators.permutations.html#module-moptipy.operators.permutations.op1_swap_try_n title=moptipy.operators.permutations.op1_swap_try_n><code class="xref py py-mod docutils literal notranslate"><span class=pre>op1_swap_try_n</span></code></a> behaves exactly like the <a class="reference internal"href=moptipy.operators.permutations.html#module-moptipy.operators.permutations.op1_swap2 title=moptipy.operators.permutations.op1_swap2><code class="xref py py-mod docutils literal notranslate"><span class=pre>op1_swap2</span></code></a> operator and the step-length based <a class="reference internal"href=moptipy.operators.bitstrings.html#module-moptipy.operators.bitstrings.op1_flip_m title=moptipy.operators.bitstrings.op1_flip_m><code class="xref py py-mod docutils literal notranslate"><span class=pre>op1_flip_m</span></code></a> operator behaves like the <a class="reference internal"href=moptipy.operators.bitstrings.html#module-moptipy.operators.bitstrings.op1_flip1 title=moptipy.operators.bitstrings.op1_flip1><code class="xref py py-mod docutils literal notranslate"><span class=pre>op1_flip1</span></code></a>. Of course, if both the current and the new solution have the same objective value, then we use a random number from <cite>[0,1)</cite> as normalized objective value, so the operators would not behave the same. Then again, one could set the maximum step length <a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.max_step title=moptipy.algorithms.so.ppa.PPA.max_step><code class="xref py py-attr docutils literal notranslate"><span class=pre>max_step</span></code></a> to <cite>0</cite>. In this case, the step length is always zero and most of our step-length based operations will behave like fixed small step-length based counterparts, as mentioned above. So in other words, if we set both <a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.m title=moptipy.algorithms.so.ppa.PPA.m><code class="xref py py-attr docutils literal notranslate"><span class=pre>m</span></code></a> and <a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.nmax title=moptipy.algorithms.so.ppa.PPA.nmax><code class="xref py py-attr docutils literal notranslate"><span class=pre>nmax</span></code></a> to <cite>1</cite> and set <a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.max_step title=moptipy.algorithms.so.ppa.PPA.max_step><code class="xref py py-attr docutils literal notranslate"><span class=pre>max_step</span></code></a> to <cite>0</cite>, our PPA behaves like <a class="reference internal"href=#module-moptipy.algorithms.so.rls title=moptipy.algorithms.so.rls><code class="xref py py-mod docutils literal notranslate"><span class=pre>rls</span></code></a> (if the search operators are appropriately chosen).<p>Now <a class="reference internal"href=#module-moptipy.algorithms.so.rls title=moptipy.algorithms.so.rls><code class="xref py py-mod docutils literal notranslate"><span class=pre>rls</span></code></a> is also known as the (1+1) EA and indeed, it is a special case of the (mu+lambda) EA implemented in <a class="reference internal"href=#module-moptipy.algorithms.so.ea title=moptipy.algorithms.so.ea><code class="xref py py-mod docutils literal notranslate"><span class=pre>ea</span></code></a>. I think with some appropriate settings of the parameter, we can probably construct some setups of both algorithms with larger populations that should be equivalent or close-to-equivalent in the big picture.<p>Below, you can find references on the PPA.<ol class="arabic simple"><li><p>Abdellah Salhi and Eric Serafin Fraga. Nature-Inspired Optimisation Approaches and the New Plant Propagation Algorithm. <em>Proceeding of the International Conference on Numerical Analysis and Optimization (ICeMATH’2011),</em> June 6-8, 2011, Yogyakarta, Indonesia, volume 1, pages K2-1–K2-8. ISBN: 978-602-98919-1-1. <a class="reference external"href=https://doi.org/10.13140/2.1.3262.0806>https://doi.org/10.13140/2.1.3262.0806</a>. <a class="reference external"href=https://repository.essex.ac.uk/9974/1/paper.pdf>https://repository.essex.ac.uk/9974/1/paper.pdf</a>.<li><p>Misha Paauw and Daan van den Berg. Paintings, Polygons and Plant Propagation. In Anikó Ekárt, Antonios Liapis, and María Luz Castro Pena, editors, <em>Proceedings of the 8th International Conference on Computational Intelligence in Music, Sound, Art and Design (EvoMUSART’19, Part of EvoStar)</em>, April 24-26, 2019, Leipzig, Germany, Lecture Notes in Computer Science (LNCS), volume 11453, pages 84-97. ISBN: 978-3-030-16666-3. Cham, Switzerland: Springer. <a class="reference external"href=https://doi.org/10.1007/978-3-030-16667-0_6>https://doi.org/10.1007/978-3-030-16667-0_6</a>. <a class="reference external"href=https://www.researchgate.net/publication/332328080>https://www.researchgate.net/publication/332328080</a>.<li><p>Muhammad Sulaiman, Abdellah Salhi, Eric Serafin Fraga, Wali Khan Mashwa, and Muhammad M. Rashi. A Novel Plant Propagation Algorithm: Modifications and Implementation. <em>Science International (Lahore)</em> 28(1):201-209, #2330, January/February 2016. <a class="reference external"href=http://www.sci-int.com/pdf/4066579081%20a%20201-209%20PPA%20Science%20international_Wali.pdf>http://www.sci-int.com/pdf/4066579081%20a%20201-209%20PPA%20Science%20international_Wali.pdf</a>. <a class="reference external"href=https://arxiv.org/pdf/1412.4290.pdf>https://arxiv.org/pdf/1412.4290.pdf</a><li><p>Hussein Fouad Almazini, Salah Mortada, Hassan Fouad Abbas Al-Mazini, Hayder Naser Khraibet AL-Behadili, and Jawad Alkenani. Improved Discrete Plant Propagation Algorithm for Solving the Traveling Salesman Problem. <em>IAES International Journal of Artificial Intelligence (IJ-AI)</em> 11(1):13-22. March 2022. <a class="reference external"href=http://doi.org/10.11591/ijai.v11.i1.pp13-22>http://doi.org/10.11591/ijai.v11.i1.pp13-22</a>. <a class="reference external"href=https://www.researchgate.net/publication/357484222>https://www.researchgate.net/publication/357484222</a>.<li><p>Birsen İrem Selamoğlu and Abdellah Salhi. The Plant Propagation Algorithm for Discrete Optimisation: The Case of the Travelling Salesman Problem. In Xin-She Yang, editor, <em>Nature-Inspired Computation in Engineering,</em> pages 43-61. Studies in Computational Intelligence (SCI), Volume 637. March 2016. Cham, Switzerland: Springer. <a class="reference external"href=https://doi.org/10.1007/978-3-319-30235-5_3>https://doi.org/10.1007/978-3-319-30235-5_3</a>. <a class="reference external"href=https://www.researchgate.net/publication/299286896>https://www.researchgate.net/publication/299286896</a>.<li><p>Marleen de Jonge and Daan van den Berg. Parameter Sensitivity Patterns in the Plant Propagation Algorithm. In Juan Julián Merelo Guervós, Jonathan M. Garibaldi, Christian Wagner, Thomas Bäck, Kurosh Madani, and Kevin Warwick, editors, <em>Proceedings of the 12th International Joint Conference on Computational Intelligence</em> (IJCCI’20), November 2-4, 2020, Budapest, Hungary, pages 92-99. Setúbal, Portugal: SciTePress. <a class="reference external"href=https://doi.org/10.5220/0010134300920099>https://doi.org/10.5220/0010134300920099</a>. <a class="reference external"href=https://www.researchgate.net/publication/346829569>https://www.researchgate.net/publication/346829569</a>.<li><p>Ege de Bruin. Escaping Local Optima by Preferring Rarity with the Frequency Fitness Assignment. Master’s Thesis at Vrije Universiteit Amsterdam, Amsterdam, the Netherlands. 2022.<li><p>Wouter Vrielink and Daan van den Berg. Parameter control for the Plant Propagation Algorithm. In Antonio M. Mora and Anna Isabel Esparcia-Alcázar, editors, <em>Late-Breaking Abstracts of EvoStar’21</em>, April 7-9, 2021, online conference. <a class="reference external"href=https://arxiv.org/pdf/2106.11804.pdf>https://arxiv.org/pdf/2106.11804.pdf</a>. <a class="reference external"href=https://www.researchgate.net/publication/350328314>https://www.researchgate.net/publication/350328314</a>.<li><p>Levi Koppenhol, Nielis Brouwer, Danny Dijkzeul, Iris Pijning, Joeri Sleegers, and Daan van den Berg. Exactly Characterizable Parameter Settings in a Crossoverless Evolutionary Algorithm. In Jonathan E. Fieldsend and Markus Wagner, editors, Genetic and Evolutionary Computation Conference (GECCO’22) Companion Volume, July 9-13, 2022, Boston, MA, USA, pages 1640-1649. New York, NY, USA: ACM. <a class="reference external"href=https://doi.org/10.1145/3520304.3533968>https://doi.org/10.1145/3520304.3533968</a>. <a class="reference external"href=https://www.researchgate.net/publication/362120506>https://www.researchgate.net/publication/362120506</a>.</ol><dl class="py class"><dt class="sig sig-object py"id=moptipy.algorithms.so.ppa.PPA><em class=property><span class=k><span class=pre>class</span></span><span class=w> </span></em><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.ppa.</span></span><span class="sig-name descname"><span class=pre>PPA</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>op0</span></span></em>, <em class=sig-param><span class=n><span class=pre>op1</span></span></em>, <em class=sig-param><span class=n><span class=pre>m</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>30</span></span></em>, <em class=sig-param><span class=n><span class=pre>nmax</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>5</span></span></em>, <em class=sig-param><span class=n><span class=pre>max_step</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>0.3</span></span></em>, <em class=sig-param><span class=n><span class=pre>name</span></span><span class=o><span class=pre>=</span></span><span class=default_value><span class=pre>'ppa'</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/ppa.html#PPA><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ppa.PPA>¶</a><dd><p>Bases: <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm1 title=moptipy.api.algorithm.Algorithm1><code class="xref py py-class docutils literal notranslate"><span class=pre>Algorithm1</span></code></a></p> <p>The Plant Propagation Algorithm (PPA).</p> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.ppa.PPA.log_parameters_to><span class="sig-name descname"><span class=pre>log_parameters_to</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>logger</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/ppa.html#PPA.log_parameters_to><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ppa.PPA.log_parameters_to>¶</a><dd><p>Log the parameters of the algorithm to a logger.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>logger</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.utils.html#moptipy.utils.logger.KeyValueLogSection title=moptipy.utils.logger.KeyValueLogSection><code class="xref py py-class docutils literal notranslate"><span class=pre>KeyValueLogSection</span></code></a></span>) – the logger for the parameters</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.ppa.PPA.m><span class="sig-name descname"><span class=pre>m</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><span class=pre>Final[int]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ppa.PPA.m>¶</a><dd><p>the number of records to survive in each generation</p></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.ppa.PPA.max_step><span class="sig-name descname"><span class=pre>max_step</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><span class=pre>Final[float]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ppa.PPA.max_step>¶</a><dd><p>the maximum step length</p></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.ppa.PPA.nmax><span class="sig-name descname"><span class=pre>nmax</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><span class=pre>Final[int]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ppa.PPA.nmax>¶</a><dd><p>the maximum number of offsprings per solution per iteration</p></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.ppa.PPA.solve><span class="sig-name descname"><span class=pre>solve</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>process</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/ppa.html#PPA.solve><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.ppa.PPA.solve>¶</a><dd><p>Apply the PPA to an optimization problem.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>process</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process title=moptipy.api.process.Process><code class="xref py py-class docutils literal notranslate"><span class=pre>Process</span></code></a></span>) – the black-box process object</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl></dl></section><section id=module-moptipy.algorithms.so.record><span id=moptipy-algorithms-so-record-module></span><h2>moptipy.algorithms.so.record module<a title="Link to this heading"class=headerlink href=#module-moptipy.algorithms.so.record>¶</a></h2><p>A simple record for storing a solution with its quality.<dl class="py class"><dt class="sig sig-object py"id=moptipy.algorithms.so.record.Record><em class=property><span class=k><span class=pre>class</span></span><span class=w> </span></em><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.record.</span></span><span class="sig-name descname"><span class=pre>Record</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>x</span></span></em>, <em class=sig-param><span class=n><span class=pre>f</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/record.html#Record><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.record.Record>¶</a><dd><p>Bases: <a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/functions.html#object><code class="xref py py-class docutils literal notranslate"><span class=pre>object</span></code></a></p> <p>A point in the search space, its quality, and creation time.</p> <p>A record stores a point in the search space <a class="reference internal"href=#moptipy.algorithms.so.record.Record.x title=moptipy.algorithms.so.record.Record.x><code class="xref py py-attr docutils literal notranslate"><span class=pre>x</span></code></a> together with the corresponding objective value <a class="reference internal"href=#moptipy.algorithms.so.record.Record.f title=moptipy.algorithms.so.record.Record.f><code class="xref py py-attr docutils literal notranslate"><span class=pre>f</span></code></a>. It also stores a “iteration index” <a class="reference internal"href=#moptipy.algorithms.so.record.Record.it title=moptipy.algorithms.so.record.Record.it><code class="xref py py-attr docutils literal notranslate"><span class=pre>it</span></code></a>, i.e., the time when the point was created or modified.</p> <p>This allows for representing and storing solutions in a population. If the population is sorted, then records with better objective value will be moved to the beginning of the list. Ties are broken such that younger individuals (with higher <a class="reference internal"href=#moptipy.algorithms.so.record.Record.it title=moptipy.algorithms.so.record.Record.it><code class="xref py py-attr docutils literal notranslate"><span class=pre>it</span></code></a> value) are preferred.</p> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.record.Record.f><span class="sig-name descname"><span class=pre>f</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/functions.html#int><code class="xref py py-class docutils literal notranslate"><span class=pre>int</span></code></a> <span class=pre>|</span> <a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/functions.html#float><code class="xref py py-class docutils literal notranslate"><span class=pre>float</span></code></a></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.record.Record.f>¶</a><dd><p>the objective value corresponding to <a class="reference internal"href=#moptipy.algorithms.so.record.Record.x title=moptipy.algorithms.so.record.Record.x><code class="xref py py-attr docutils literal notranslate"><span class=pre>x</span></code></a></p></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.record.Record.it><span class="sig-name descname"><span class=pre>it</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/functions.html#int><code class="xref py py-class docutils literal notranslate"><span class=pre>int</span></code></a></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.record.Record.it>¶</a><dd><p>the iteration index when <a class="reference internal"href=#moptipy.algorithms.so.record.Record.x title=moptipy.algorithms.so.record.Record.x><code class="xref py py-attr docutils literal notranslate"><span class=pre>x</span></code></a> was sampled</p></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.record.Record.x><span class="sig-name descname"><span class=pre>x</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.record.Record.x>¶</a><dd><p>the point in the search space</p></dl></dl></section><section id=module-moptipy.algorithms.so.rls><span id=moptipy-algorithms-so-rls-module></span><h2>moptipy.algorithms.so.rls module<a title="Link to this heading"class=headerlink href=#module-moptipy.algorithms.so.rls>¶</a></h2><p>The implementation of the Randomized Local Search algorithm <cite>rls</cite>.<p>The algorithm starts by applying the nullary search operator, an implementation of <a class="reference internal"href=moptipy.api.html#moptipy.api.operators.Op0.op0 title=moptipy.api.operators.Op0.op0><code class="xref py py-meth docutils literal notranslate"><span class=pre>op0()</span></code></a>, to sample one fully random solution. This is the first best-so-far solution. In each step, it applies the unary operator, an implementation of <a class="reference internal"href=moptipy.api.html#moptipy.api.operators.Op1.op1 title=moptipy.api.operators.Op1.op1><code class="xref py py-meth docutils literal notranslate"><span class=pre>op1()</span></code></a>, to the best-so-far solution to obtain a new, similar solution. If this new solution is not worse than the current best-so-far solution, it replaces this solution. Otherwise, it is discarded.<p>The <cite>rls</cite> algorithm is a simple local search that accepts all non-deteriorating moves. It is thus similar to the simple hill climber <cite>hc</cite> implemented in <a class="reference internal"href=#moptipy.algorithms.so.hill_climber.HillClimber title=moptipy.algorithms.so.hill_climber.HillClimber><code class="xref py py-class docutils literal notranslate"><span class=pre>HillClimber</span></code></a>, which, however, accepts strictly improving moves. <cite>rls</cite> is also equivalent to a <cite>(mu+lambda)</cite>-EA without crossover as implemented in <a class="reference internal"href=#moptipy.algorithms.so.ea.EA title=moptipy.algorithms.so.ea.EA><code class="xref py py-class docutils literal notranslate"><span class=pre>EA</span></code></a> if the same unary and nullary operator are used and <cite>mu=1</cite>, <cite>lambda=1</cite>, and <cite>br=0</cite>. <cite>rls</cite>, however, will be faster as it does not represent a population of solutions as list of objects but can directly utilize local variables.<p>Strictly speaking, the name “Randomized Local Search” only fits partially to the algorithm we implement here. Take the discrete search domain, where the search spaces are bit strings of a fixed length <cite>n</cite>, as an example. The name “Randomized Local Search” and the abbreviation <cite>rls</cite> has a fixed meaning on this domain: It is the algorithm that starts with a random solution and flips exactly one randomly chosen bit in each step. This corresponds to our <cite>rls</cite> algorithm with the operator <a class="reference internal"href=moptipy.operators.bitstrings.html#moptipy.operators.bitstrings.op1_flip1.Op1Flip1 title=moptipy.operators.bitstrings.op1_flip1.Op1Flip1><code class="xref py py-class docutils literal notranslate"><span class=pre>Op1Flip1</span></code></a>. However, an algorithm that starts with a random solution and flips a number of bits sampled from a Binomial distribution is called <cite>(1+1) EA</cite>. Now this algorithm corresponds again to our <cite>rls</cite> algorithm, but this time with operator <a class="reference internal"href=moptipy.operators.bitstrings.html#moptipy.operators.bitstrings.op1_m_over_n_flip.Op1MoverNflip title=moptipy.operators.bitstrings.op1_m_over_n_flip.Op1MoverNflip><code class="xref py py-class docutils literal notranslate"><span class=pre>Op1MoverNflip</span></code></a>. In other words, we can implement (at least) two algorithms with well-known and fixed names by plugging different operators into our <cite>rls</cite> approach. One of them is called <cite>RLS</cite>, the other one is called <cite>(1+1) EA</cite>. Now this is somewhat confusing but results from the general nature of our basic framework. Regardless of what we do, we will have some form of name clash here. We advise the user of our algorithms to be careful with respect to literature and scientific conventions when using our framework.<ol class="arabic simple"><li><p>Frank Neumann and Ingo Wegener. Randomized Local Search, Evolutionary Algorithms, and the Minimum Spanning Tree Problem. <em>Theoretical Computer Science.</em> 378(1):32-40, June 2007. <a class="reference external"href=https://doi.org/10.1016/j.tcs.2006.11.002>https://doi.org/10.1016/j.tcs.2006.11.002</a>, <a class="reference external"href=https://eldorado.tu-dortmund.de/bitstream/2003/5454/1/165.pdf>https://eldorado.tu-dortmund.de/bitstream/2003/5454/1/165.pdf</a><li><p>Holger H. Hoos and Thomas Stützle. <em>Stochastic Local Search: Foundations and Applications.</em> 2005. ISBN: 1493303732. In The Morgan Kaufmann Series in Artificial Intelligence. Amsterdam, The Netherlands: Elsevier.<li><p>Thomas Weise. <em>Optimization Algorithms.</em> 2021. Hefei, Anhui, China: Institute of Applied Optimization (IAO), School of Artificial Intelligence and Big Data, Hefei University. <a class="reference external"href=http://thomasweise.github.io/oa/>http://thomasweise.github.io/oa/</a></ol><dl class="py class"><dt class="sig sig-object py"id=moptipy.algorithms.so.rls.RLS><em class=property><span class=k><span class=pre>class</span></span><span class=w> </span></em><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.rls.</span></span><span class="sig-name descname"><span class=pre>RLS</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>op0</span></span></em>, <em class=sig-param><span class=n><span class=pre>op1</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/rls.html#RLS><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.rls.RLS>¶</a><dd><p>Bases: <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm1 title=moptipy.api.algorithm.Algorithm1><code class="xref py py-class docutils literal notranslate"><span class=pre>Algorithm1</span></code></a></p> <p>The RLS is a simple local search accepting all non-worsening moves.</p> <p>In each step, an RLS creates a modified copy <cite>new_x</cite> of the current best solution <cite>best_x</cite>. If <cite>new_x</cite> is not worse than <cite>best_x</cite>, it becomes the new <cite>best_x</cite>. Otherwise, it is discarded.</p> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.rls.RLS.solve><span class="sig-name descname"><span class=pre>solve</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>process</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/rls.html#RLS.solve><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.rls.RLS.solve>¶</a><dd><p>Apply the RLS to an optimization problem.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>process</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process title=moptipy.api.process.Process><code class="xref py py-class docutils literal notranslate"><span class=pre>Process</span></code></a></span>) – the black-box process object</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl></dl></section><section id=module-moptipy.algorithms.so.simulated_annealing><span id=moptipy-algorithms-so-simulated-annealing-module></span><h2>moptipy.algorithms.so.simulated_annealing module<a title="Link to this heading"class=headerlink href=#module-moptipy.algorithms.so.simulated_annealing>¶</a></h2><p>The simulated annealing algorithm with configurable temperature schedule.<p>A basic randomized local search (<a class="reference internal"href=#module-moptipy.algorithms.so.rls title=moptipy.algorithms.so.rls><code class="xref py py-mod docutils literal notranslate"><span class=pre>rls</span></code></a>) maintains one interesting solution and derives one new solution from it using the unary search operator (<a class="reference internal"href=moptipy.api.html#moptipy.api.operators.Op1 title=moptipy.api.operators.Op1><code class="xref py py-class docutils literal notranslate"><span class=pre>Op1</span></code></a>). The new solution replaces the current solution if it is not worse, i.e., better or equally good. Simulated Annealing is similar to the <a class="reference internal"href=#module-moptipy.algorithms.so.rls title=moptipy.algorithms.so.rls><code class="xref py py-mod docutils literal notranslate"><span class=pre>rls</span></code></a>, but it sometimes also accepts solutions that are worse than the current one. It does so with a probability that becomes smaller the worse the new solution is and also becomes smaller the smaller the current “temperature” is.<p>Simulated Annealing applies a so-called temperature schedule (see <a class="reference internal"href=moptipy.algorithms.modules.html#module-moptipy.algorithms.modules.temperature_schedule title=moptipy.algorithms.modules.temperature_schedule><code class="xref py py-mod docutils literal notranslate"><span class=pre>temperature_schedule</span></code></a>), which basically is function that relates the index of the algorithm iteration (i.e., the index of the current objective function evaluation) to a temperature. It therefore is a function accepting an integer value as input and returning a float temperature. This function is usually monotonously decreasing over time, meaning that the initial “temperature” is high and then becomes smaller. The algorithm therefore is more likely to accept worse solutions at its beginning, whereas it behaves basically like a <a class="reference internal"href=#module-moptipy.algorithms.so.rls title=moptipy.algorithms.so.rls><code class="xref py py-mod docutils literal notranslate"><span class=pre>rls</span></code></a> at the end of its computational budget (if configured correctly).<p>Simulated Annealing was independently developed by several researchers [1-4]. The idea is inspired by Metropolis’ approximation of how annealing can be simulated [5].<ol class="arabic simple"><li><p>Scott Kirkpatrick, C. Daniel Gelatt, Jr., and Mario P. Vecchi. Optimization by Simulated Annealing. <em>Science Magazine.</em> 220(4598):671-680. May 13, 1983. doi: <a class="reference external"href=https://doi.org/10.1126/science.220.4598.671>https://doi.org/10.1126/science.220.4598.671</a>. <a class="reference external"href=https://www.researchgate.net/publication/6026283>https://www.researchgate.net/publication/6026283</a><li><p>Vladimír Černý. Thermodynamical Approach to the Traveling Salesman Problem: An Efficient Simulation Algorithm. <em>Journal of Optimization Theory and Applications.</em> 45(1):41-51. January 1985. doi: <a class="reference external"href=https://doi.org/10.1007/BF00940812>https://doi.org/10.1007/BF00940812</a>. <a class="reference external"href=http://mkweb.bcgsc.ca/papers/cerny-travelingsalesman.pdf>http://mkweb.bcgsc.ca/papers/cerny-travelingsalesman.pdf</a>.<li><p>Dean Jacobs, Jan Prins, Peter Siegel, and Kenneth Wilson. Monte Carlo Techniques in Code Optimization. <em>ACM SIGMICRO Newsletter.</em> 13(4):143-148. December 1982. Also in Proceedings of the 15th Annual Workshop on Microprogramming (MICRO 15), October 5-7, 1982, Palo Alto, CA, USA, New York, NY, USA: ACM. doi: <a class="reference external"href=http://doi.org/10.1145/1014194.800944>http://doi.org/10.1145/1014194.800944</a>.<li><p>Martin Pincus. Letter to the Editor - A Monte Carlo Method for the Approximate Solution of Certain Types of Constrained Optimization Problems. <em>Operations Research.</em> 18(6):1225-1228. November/December 1970. doi: <a class="reference external"href=https://doi.org/10.1287/opre.18.6.1225>https://doi.org/10.1287/opre.18.6.1225</a>.<li><p>Nicholas Metropolis, Arianna W. Rosenbluth, Marshall Nicholas Rosenbluth, Augusta H. Teller, Edward Teller. Equation of State Calculations by Fast Computing Machines. <em>The Journal of Chemical Physics</em>. 21(6):1087-1092. June 1953. doi: <a class="reference external"href=https://doi.org/10.1063/1.1699114>https://doi.org/10.1063/1.1699114</a>. <a class="reference external"href=http://scienze-como.uninsubria.it/bressanini/montecarlo-history/mrt2.pdf>http://scienze-como.uninsubria.it/bressanini/montecarlo-history/mrt2.pdf</a>.</ol><dl class="py class"><dt class="sig sig-object py"id=moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing><em class=property><span class=k><span class=pre>class</span></span><span class=w> </span></em><span class="sig-prename descclassname"><span class=pre>moptipy.algorithms.so.simulated_annealing.</span></span><span class="sig-name descname"><span class=pre>SimulatedAnnealing</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>op0</span></span></em>, <em class=sig-param><span class=n><span class=pre>op1</span></span></em>, <em class=sig-param><span class=n><span class=pre>schedule</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/simulated_annealing.html#SimulatedAnnealing><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing>¶</a><dd><p>Bases: <a class="reference internal"href=moptipy.api.html#moptipy.api.algorithm.Algorithm1 title=moptipy.api.algorithm.Algorithm1><code class="xref py py-class docutils literal notranslate"><span class=pre>Algorithm1</span></code></a></p> <p>Simulated Annealing is an RLS sometimes accepting worsening moves.</p> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing.initialize><span class="sig-name descname"><span class=pre>initialize</span></span><span class=sig-paren>(</span><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/simulated_annealing.html#SimulatedAnnealing.initialize><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing.initialize>¶</a><dd><p>Initialize the algorithm.</p> <dl class="field-list simple"><dt class=field-odd>Return type<span class=colon>:</span><dd class=field-odd><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing.log_parameters_to><span class="sig-name descname"><span class=pre>log_parameters_to</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>logger</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/simulated_annealing.html#SimulatedAnnealing.log_parameters_to><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing.log_parameters_to>¶</a><dd><p>Log all parameters of the simulated annealing algorithm.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>logger</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.utils.html#moptipy.utils.logger.KeyValueLogSection title=moptipy.utils.logger.KeyValueLogSection><code class="xref py py-class docutils literal notranslate"><span class=pre>KeyValueLogSection</span></code></a></span>) – the logger for the parameters</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl> <dl class="py attribute"><dt class="sig sig-object py"id=moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing.schedule><span class="sig-name descname"><span class=pre>schedule</span></span><em class=property><span class=p><span class=pre>:</span></span><span class=w> </span><code class="xref py py-class docutils literal notranslate"><span class=pre>Final</span></code><span class=pre>[</span><a class="reference internal"href=moptipy.algorithms.modules.html#moptipy.algorithms.modules.temperature_schedule.TemperatureSchedule title=moptipy.algorithms.modules.temperature_schedule.TemperatureSchedule><code class="xref py py-class docutils literal notranslate"><span class=pre>TemperatureSchedule</span></code></a><span class=pre>]</span></em><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing.schedule>¶</a><dd><p>the temperature schedule</p></dl> <dl class="py method"><dt class="sig sig-object py"id=moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing.solve><span class="sig-name descname"><span class=pre>solve</span></span><span class=sig-paren>(</span><em class=sig-param><span class=n><span class=pre>process</span></span></em><span class=sig-paren>)</span><a class="reference internal"href=_modules/moptipy/algorithms/so/simulated_annealing.html#SimulatedAnnealing.solve><span class=viewcode-link><span class=pre>[source]</span></span></a><a title="Link to this definition"class=headerlink href=#moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing.solve>¶</a><dd><p>Apply the simulated annealing algorithm to an optimization problem.</p> <dl class="field-list simple"><dt class=field-odd>Parameters<span class=colon>:</span><dd class=field-odd><p><strong>process</strong> (<span class=sphinx_autodoc_typehints-type><a class="reference internal"href=moptipy.api.html#moptipy.api.process.Process title=moptipy.api.process.Process><code class="xref py py-class docutils literal notranslate"><span class=pre>Process</span></code></a></span>) – the black-box process object</p><dt class=field-even>Return type<span class=colon>:</span><dd class=field-even><p><span class=sphinx_autodoc_typehints-type><a class="reference external"title="(in Python v3.14)"href=https://docs.python.org/3/library/constants.html#None><code class="xref py py-obj docutils literal notranslate"><span class=pre>None</span></code></a></span></p></dl></dl></dl></section></section><div class=clearer></div></div></div></div><div aria-label=Main class=sphinxsidebar role=navigation><div class=sphinxsidebarwrapper><div><h3><a href=index.html>Table of Contents</a></h3><ul><li><a class="reference internal"href=#>moptipy.algorithms.so package</a><ul><li><a class="reference internal"href=#subpackages>Subpackages</a><li><a class="reference internal"href=#submodules>Submodules</a><li><a class="reference internal"href=#module-moptipy.algorithms.so.ea>moptipy.algorithms.so.ea module</a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.ea.EA><code class="docutils literal notranslate"><span class=pre>EA</span></code></a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.ea.EA.br><code class="docutils literal notranslate"><span class=pre>EA.br</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ea.EA.lambda_><code class="docutils literal notranslate"><span class=pre>EA.lambda_</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ea.EA.log_parameters_to><code class="docutils literal notranslate"><span class=pre>EA.log_parameters_to()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ea.EA.mu><code class="docutils literal notranslate"><span class=pre>EA.mu</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ea.EA.solve><code class="docutils literal notranslate"><span class=pre>EA.solve()</span></code></a></ul></ul><li><a class="reference internal"href=#module-moptipy.algorithms.so.fitness>moptipy.algorithms.so.fitness module</a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.fitness.FRecord><code class="docutils literal notranslate"><span class=pre>FRecord</span></code></a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.fitness.FRecord.fitness><code class="docutils literal notranslate"><span class=pre>FRecord.fitness</span></code></a></ul><li><a class="reference internal"href=#moptipy.algorithms.so.fitness.Fitness><code class="docutils literal notranslate"><span class=pre>Fitness</span></code></a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.fitness.Fitness.assign_fitness><code class="docutils literal notranslate"><span class=pre>Fitness.assign_fitness()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.fitness.Fitness.log_information_after_run><code class="docutils literal notranslate"><span class=pre>Fitness.log_information_after_run()</span></code></a></ul><li><a class="reference internal"href=#moptipy.algorithms.so.fitness.check_fitness><code class="docutils literal notranslate"><span class=pre>check_fitness()</span></code></a></ul><li><a class="reference internal"href=#module-moptipy.algorithms.so.general_ea>moptipy.algorithms.so.general_ea module</a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.general_ea.GeneralEA><code class="docutils literal notranslate"><span class=pre>GeneralEA</span></code></a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.general_ea.GeneralEA.fitness><code class="docutils literal notranslate"><span class=pre>GeneralEA.fitness</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.general_ea.GeneralEA.initialize><code class="docutils literal notranslate"><span class=pre>GeneralEA.initialize()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.general_ea.GeneralEA.log_parameters_to><code class="docutils literal notranslate"><span class=pre>GeneralEA.log_parameters_to()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.general_ea.GeneralEA.mating><code class="docutils literal notranslate"><span class=pre>GeneralEA.mating</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.general_ea.GeneralEA.solve><code class="docutils literal notranslate"><span class=pre>GeneralEA.solve()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.general_ea.GeneralEA.survival><code class="docutils literal notranslate"><span class=pre>GeneralEA.survival</span></code></a></ul></ul><li><a class="reference internal"href=#module-moptipy.algorithms.so.general_ma>moptipy.algorithms.so.general_ma module</a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.general_ma.GeneralMA><code class="docutils literal notranslate"><span class=pre>GeneralMA</span></code></a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.general_ma.GeneralMA.fitness><code class="docutils literal notranslate"><span class=pre>GeneralMA.fitness</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.general_ma.GeneralMA.initialize><code class="docutils literal notranslate"><span class=pre>GeneralMA.initialize()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.general_ma.GeneralMA.log_parameters_to><code class="docutils literal notranslate"><span class=pre>GeneralMA.log_parameters_to()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.general_ma.GeneralMA.mating><code class="docutils literal notranslate"><span class=pre>GeneralMA.mating</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.general_ma.GeneralMA.solve><code class="docutils literal notranslate"><span class=pre>GeneralMA.solve()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.general_ma.GeneralMA.survival><code class="docutils literal notranslate"><span class=pre>GeneralMA.survival</span></code></a></ul></ul><li><a class="reference internal"href=#module-moptipy.algorithms.so.greedy_2plus1_ea_mod>moptipy.algorithms.so.greedy_2plus1_ea_mod module</a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.greedy_2plus1_ea_mod.GreedyTwoPlusOneEAmod><code class="docutils literal notranslate"><span class=pre>GreedyTwoPlusOneEAmod</span></code></a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.greedy_2plus1_ea_mod.GreedyTwoPlusOneEAmod.solve><code class="docutils literal notranslate"><span class=pre>GreedyTwoPlusOneEAmod.solve()</span></code></a></ul></ul><li><a class="reference internal"href=#module-moptipy.algorithms.so.hill_climber>moptipy.algorithms.so.hill_climber module</a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.hill_climber.HillClimber><code class="docutils literal notranslate"><span class=pre>HillClimber</span></code></a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.hill_climber.HillClimber.solve><code class="docutils literal notranslate"><span class=pre>HillClimber.solve()</span></code></a></ul></ul><li><a class="reference internal"href=#module-moptipy.algorithms.so.hill_climber_with_restarts>moptipy.algorithms.so.hill_climber_with_restarts module</a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.hill_climber_with_restarts.HillClimberWithRestarts><code class="docutils literal notranslate"><span class=pre>HillClimberWithRestarts</span></code></a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.hill_climber_with_restarts.HillClimberWithRestarts.log_parameters_to><code class="docutils literal notranslate"><span class=pre>HillClimberWithRestarts.log_parameters_to()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.hill_climber_with_restarts.HillClimberWithRestarts.max_moves_without_improvement><code class="docutils literal notranslate"><span class=pre>HillClimberWithRestarts.max_moves_without_improvement</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.hill_climber_with_restarts.HillClimberWithRestarts.solve><code class="docutils literal notranslate"><span class=pre>HillClimberWithRestarts.solve()</span></code></a></ul></ul><li><a class="reference internal"href=#module-moptipy.algorithms.so.ma>moptipy.algorithms.so.ma module</a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.ma.MA><code class="docutils literal notranslate"><span class=pre>MA</span></code></a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.ma.MA.initialize><code class="docutils literal notranslate"><span class=pre>MA.initialize()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ma.MA.lambda_><code class="docutils literal notranslate"><span class=pre>MA.lambda_</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ma.MA.log_parameters_to><code class="docutils literal notranslate"><span class=pre>MA.log_parameters_to()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls><code class="docutils literal notranslate"><span class=pre>MA.ls</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ma.MA.ls_fes><code class="docutils literal notranslate"><span class=pre>MA.ls_fes</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ma.MA.mu><code class="docutils literal notranslate"><span class=pre>MA.mu</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ma.MA.op2><code class="docutils literal notranslate"><span class=pre>MA.op2</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ma.MA.solve><code class="docutils literal notranslate"><span class=pre>MA.solve()</span></code></a></ul></ul><li><a class="reference internal"href=#module-moptipy.algorithms.so.marls>moptipy.algorithms.so.marls module</a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.marls.MARLS><code class="docutils literal notranslate"><span class=pre>MARLS</span></code></a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.marls.MARLS.lambda_><code class="docutils literal notranslate"><span class=pre>MARLS.lambda_</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.marls.MARLS.log_parameters_to><code class="docutils literal notranslate"><span class=pre>MARLS.log_parameters_to()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.marls.MARLS.ls_fes><code class="docutils literal notranslate"><span class=pre>MARLS.ls_fes</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.marls.MARLS.mu><code class="docutils literal notranslate"><span class=pre>MARLS.mu</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.marls.MARLS.solve><code class="docutils literal notranslate"><span class=pre>MARLS.solve()</span></code></a></ul></ul><li><a class="reference internal"href=#module-moptipy.algorithms.so.ppa>moptipy.algorithms.so.ppa module</a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA><code class="docutils literal notranslate"><span class=pre>PPA</span></code></a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.log_parameters_to><code class="docutils literal notranslate"><span class=pre>PPA.log_parameters_to()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.m><code class="docutils literal notranslate"><span class=pre>PPA.m</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.max_step><code class="docutils literal notranslate"><span class=pre>PPA.max_step</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.nmax><code class="docutils literal notranslate"><span class=pre>PPA.nmax</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.ppa.PPA.solve><code class="docutils literal notranslate"><span class=pre>PPA.solve()</span></code></a></ul></ul><li><a class="reference internal"href=#module-moptipy.algorithms.so.record>moptipy.algorithms.so.record module</a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.record.Record><code class="docutils literal notranslate"><span class=pre>Record</span></code></a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.record.Record.f><code class="docutils literal notranslate"><span class=pre>Record.f</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.record.Record.it><code class="docutils literal notranslate"><span class=pre>Record.it</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.record.Record.x><code class="docutils literal notranslate"><span class=pre>Record.x</span></code></a></ul></ul><li><a class="reference internal"href=#module-moptipy.algorithms.so.rls>moptipy.algorithms.so.rls module</a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.rls.RLS><code class="docutils literal notranslate"><span class=pre>RLS</span></code></a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.rls.RLS.solve><code class="docutils literal notranslate"><span class=pre>RLS.solve()</span></code></a></ul></ul><li><a class="reference internal"href=#module-moptipy.algorithms.so.simulated_annealing>moptipy.algorithms.so.simulated_annealing module</a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing><code class="docutils literal notranslate"><span class=pre>SimulatedAnnealing</span></code></a><ul><li><a class="reference internal"href=#moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing.initialize><code class="docutils literal notranslate"><span class=pre>SimulatedAnnealing.initialize()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing.log_parameters_to><code class="docutils literal notranslate"><span class=pre>SimulatedAnnealing.log_parameters_to()</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing.schedule><code class="docutils literal notranslate"><span class=pre>SimulatedAnnealing.schedule</span></code></a><li><a class="reference internal"href=#moptipy.algorithms.so.simulated_annealing.SimulatedAnnealing.solve><code class="docutils literal notranslate"><span class=pre>SimulatedAnnealing.solve()</span></code></a></ul></ul></ul></ul></div><div><h4>Previous topic</h4><p class=topless><a title="previous chapter"href=moptipy.algorithms.modules.selections.html>moptipy.algorithms.modules.selections package</a></div><div><h4>Next topic</h4><p class=topless><a title="next chapter"href=moptipy.algorithms.so.ffa.html>moptipy.algorithms.so.ffa package</a></div><div aria-label="source link"role=note><h3>This Page</h3><ul class=this-page-menu><li><a href=_sources/moptipy.algorithms.so.rst.txt rel=nofollow>Show Source</a></ul></div><search id=searchbox role=search style=display:none> <h3 id=searchlabel>Quick search</h3> <div class=searchformwrapper><form action=search.html class=search><input aria-labelledby=searchlabel autocapitalize=off autocomplete=off autocorrect=off name=q spellcheck=false><input type=submit value=Go></form></div> </search><script>document.getElementById(`searchbox`).style.display=`block`;</script></div></div><div class=clearer></div></div><div aria-label=Related class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="General Index"href=genindex.html>index</a><li class=right><a title="Python Module Index"href=py-modindex.html>modules</a> |<li class=right><a title="moptipy.algorithms.so.ffa package"href=moptipy.algorithms.so.ffa.html>next</a> |<li class=right><a title="moptipy.algorithms.modules.selections package"href=moptipy.algorithms.modules.selections.html>previous</a> |<li class="nav-item nav-item-0"><a href=index.html>moptipy 0.9.172 documentation</a> »<li class="nav-item nav-item-1"><a href=modules.html>moptipy</a> »<li class="nav-item nav-item-2"><a href=moptipy.html>moptipy package</a> »<li class="nav-item nav-item-3"><a href=moptipy.algorithms.html>moptipy.algorithms package</a> »<li class="nav-item nav-item-this"><a href>moptipy.algorithms.so package</a></ul></div><div class=footer role=contentinfo>© Copyright 2022-2026, Thomas Weise.</div>
